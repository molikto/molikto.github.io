<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>mathematics</title>
        <link rel="stylesheet" type="text/css" href="./css/snailya.css" />
    </head>
    <body>
    <script src="./js/jquery.min.js"></script>

    <div class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="./">snailya</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="./mathematics.html">mathematics</a></li>
            <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">random notes <b class="caret"></b></a>
                <ul class="dropdown-menu">
                
                    <li><a href="./random-notes/abstract-algebra-chapter-0-solution.html">abstract-algebra-chapter-0-solution</a></li>
                
                    <li><a href="./random-notes/pl-ideas.html">pl-ideas</a></li>
                
                    <li><a href="./random-notes/scope.html">scope</a></li>
                
                    <li><a href="./random-notes/yhbkj.html">yhbkj</a></li>
                
                </ul>
            </li>
            <li><a href="./posts.html">posts</a></li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li><a href="https://github.com/molikto">github</a></li>
            <li><a href="http://www.douban.com/people/66654255/">douban</a></li>
            <li><a href="./calendar.html">calendar</a></li>
          </ul>
        </div>
      </div>
    </div>
  <div class="body small-container" id="content">
    



<script>
$("#content").css("max-width", "1100px")
</script>


<div class="row">
    <div class="bs-docs-container">
        <div class="col-md-3">
            <div class="bs-docs-sidebar hidden-print" role="complementary">
            </div>
        </div>
    </div>
    <div class="col-md-8">
        <h1 id="meta-note">meta note</h1>
<ul>
<li>doing mathematics is like exploring a very different universe</li>
<li>mathematics study objects and there structure inside and maps outside. so we divide our notes normally into 3 parts</li>
<li>in an oop view. an mathematical object is an <code>record type</code>(the definitions, restrictions) with <code>functions</code> between same type(morphisms) and between other type(functors), and it has <code>subtyping</code></li>
<li>when study the structure, we have a bunch of methods, like algebraic structure, topological structure</li>
<li>when using the categorical view, we ask what’s the object and morphism in this category, the shape of the category, and relations between objects (not certainly be morphism), what object exists in this category</li>
<li>the definition should be abstract, so you can see what’s essential in it, but must with examples, so you can feel what it is about. when proofing things, feel free to rely on your concrete examples, but always check it is rigid by abstract definitions</li>
<li>it is always helpful to view the picture of mathematics as static, there are no such thing <span class="math">\(x+y\)</span>, it is just an element. for example, finite addition is always well defined, because we can write finitely. but it is not infinite addition. we should rely on a map from <span class="math">\({\mathbb{N}}\)</span> to the group, then show how the addtion is performed and ended</li>
<li>how to proof? it is sufficient to make sure you can write all rigid sentences. you can omitted the writing, but you should always make sure you can freely think rigidly. <strong>only idea is not enough</strong></li>
</ul>
<h1 id="type">type</h1>
<h2 id="idea">idea</h2>
<p><a href="#cross-type-theory">type theory</a> is the underlaying logic of mathematical theory</p>
<h3 id="state-of-art">state of art</h3>
<p>there are two main things in the way for adopting <a href="#cross-hott">hott</a> as a working foundation:</p>
<ul>
<li>general <a href="#cross-hit">hit</a></li>
<li><a href="#cross-computation">computation</a> rule for <span class="math">\(J\)</span> for <a href="#cross-higher-inductive-type">higher inductive type</a> and <a href="#cross-univalence-axiom">univalence axiom</a></li>
</ul>
<h2 id="type-theory">type theory</h2>
<ul>
<li><span><span id="cross-hott"></span><span id="cross-type-theory" class="crosslink">type theory </span></span>
<ul>
<li><span id="cross-judgment" class="crosslink">judgment</span>
<ul>
<li><span class="math">\(\Gamma ctx\)</span></li>
<li><span class="math">\(\Gamma\vdash a: A\)</span></li>
<li><span class="math">\(\Gamma a\equiv a': A\)</span></li>
</ul></li>
<li><span id="cross-inference-rule" class="crosslink">inference rule</span>
<ul>
<li><span id="cross-type-rule" class="crosslink">type rule</span></li>
<li><span id="cross-introduction-rule" class="crosslink">introduction rule</span></li>
<li><span id="cross-elimination-rule" class="crosslink">elimination rule</span></li>
<li><span><span id="cross-computation"></span><span id="cross-computation-rule" class="crosslink">computation rule </span></span></li>
</ul></li>
<li><span id="cross-derivation" class="crosslink">derivation</span></li>
<li><span id="cross-type" class="crosslink">type</span>s
<ul>
<li><span id="cross-universe" class="crosslink">universe</span> <span class="math">\(\mathcal{U}\)</span></li>
<li><span id="cross-function" class="crosslink">function</span></li>
<li><span id="cross-identity-type" class="crosslink">identity type</span>, <span id="cross-reflection" class="crosslink">reflection</span> <span class="math">\({\text{refl}}\)</span>
<ul>
<li><code>open problem</code> how to <span class="math">\(J\)</span> compute with <a href="#cross-univalence-axiom">univalence axiom</a>?</li>
</ul></li>
<li><span><span id="cross-hit"></span><span id="cross-higher-inductive-type" class="crosslink">higher inductive type </span></span>
<ul>
<li><span><span id="cross-W-type"></span><span id="cross-inductive-type" class="crosslink">inductive type</span></span></li>
<li><code>open problem</code> formalize <a href="#cross-hit">hit</a> it like <a href="#cross-W-type">W-type</a></li>
</ul></li>
<li><span id="cross-univalence-axiom" class="crosslink">univalence axiom</span></li>
</ul></li>
</ul></li>
</ul>
<p><em>most rules see <a href="#cross-ref-hott">ref-hott</a> appendix 2</em></p>
<h2 id="random">random</h2>
<p>set theory is static, it just presents the function as the result, and the <span class="math">\(Nat\)</span> as result. but in type theory, it is not the case</p>
<p>one interesting case is function extensionality, which is implied by univalence axiom, which i believe is good, the functions will be equal not just equal, but there is more in here. if we see the fact that it is implied by univalence, then we should inspect why univalence is true, and also, are all <span class="math">\(id\)</span> is freely generated? because we have three source to generate <span class="math">\(id\)</span>, in higher inductive type and in univalence, they are one for <span class="math">\(=_A\)</span> and one for <span class="math">\(=_\mathcal{U}\)</span>, so we are ok here.</p>
<p>one more issue, if we have a good system to do mathematics in computer, then we should have a pretty printer for as but much cleaver, because machines now understand what we are talking about and can give us much more help</p>
<p>remember in set theory, we also have things like universe, it is the class and set structure, but i think the universe idea is more elegant~</p>
<h3 id="syntax-for-inductive-type-and-higher-inductive-type">syntax for inductive type and higher inductive type</h3>
<ul>
<li>it is possible to think that parameterized inductive type actually brings nothing new, it is just a convenient notation?</li>
<li>the truth is in the inductor, because when you apply a match, you should always be careful how you use them, and this is protected by the inductor (?)</li>
<li>for general inductive type, the constructor do not depend on previous constructors, but for higher inductive type, this is inevitable.</li>
<li>so in ordinary mathematics, the notation of function is collapsed, but in hott, we have a better structure, but why? this seems very unreasonable</li>
<li>the thing is all about we can identify more things, we do this not by making things just equal, i.e. like in ETT and set theory, we forget things, but by equivalences, we identify things and as long as we are not caring what the id results in, i.e. in the type checker level, we just have more power, because we can identify more things equal</li>
<li>in type theory, the notation of equal is by <span class="math">\(X=Y: \forall x(x\in X \Leftrightarrow x\in Y)\)</span>, but in HoTT, all equal is freely generated, although the <span class="math">\(J\)</span> is wired</li>
<li>i still do not understand why type theory</li>
<li><p>the thing is always how are you going to define the inductor.</p></li>
<li><p><span class="math">\(J\)</span> hold but not <span class="math">\(UIP\)</span> <a href="http://homotopytypetheory.org/2011/04/10/just-kidding-understanding-identity-elimination-in-homotopy-type-theory">http://homotopytypetheory.org/2011/04/10/just-kidding-understanding-identity-elimination-in-homotopy-type-theory</a></p></li>
</ul>
<h3 id="problems">problems</h3>
<p>let me state the main problems</p>
<ul>
<li>you do not know how to define a higher inductive type, and now as axioms, it is only propositional equal
<ul>
<li>define the accepted form</li>
<li>define the elem and intro</li>
</ul></li>
<li>there are computation lacking in univalence
<ul>
<li>and inductor for hit</li>
</ul></li>
<li><p>finally i can get an feeling about 0-type, if you have two para path, then they must be joined by an surface, if you have two surface, then they must be joint by a 3-dim ball…. then you will have a very strong point, but it is nonetheless a point!!!</p></li>
<li><p>it seems to me that type theory has some mixed things together. i do not know if this is really good, they are like packaged delivery…</p></li>
<li><p>it is really some kind of miracle that it turns out two entirely different things turns out to be the same. h-types etc..</p></li>
<li><p>on the <strong>effectiveness</strong> of type theory and category theory in mathematics…</p></li>
</ul>
<h3 id="ias-notes">IAS notes</h3>
<ul>
<li>definitional eq is just compute to same value… by Martif</li>
</ul>
<h3 id="ref-cmu-course-notes"><a href="#cross-ref-cmu-course">ref-cmu-course</a> notes</h3>
<p>the course has different way telling HTT, it first use IPL, the <em>type theory without variables</em> and corresponding Hayting algebra, then go IPL with type, then ITT… i think this is wired</p>
<ul>
<li>notes of week 1-3 is not about type theory but ITT</li>
<li>week 4
<ul>
<li>judgments</li>
<li>…</li>
</ul></li>
<li><p>in ITT, <span class="math">\(refl\)</span> is the only intro rule!!!!… so it is so boring….</p></li>
<li><p>think <span class="math">\(Id\)</span> as inductively generated family indexed by <span class="math">\(x\)</span> and <span class="math">\(y\)</span></p></li>
<li>in ITT… he saids the <span class="math">\(Id-elem\)</span> is because we only have one <span class="math">\(Id-intro\)</span> so the whole big formula is just… shitty…
<ul>
<li>we will introduce new form of <span class="math">\(Id\)</span> but the shittly rule will continue to be valid… how?</li>
</ul></li>
<li><p>what i am thinking is that, the computation rule of identity is just that applying <span class="math">\(trans(p_1, p_2)\)</span> will not compute because the inductor <span class="math">\(J\)</span> only compute when <span class="math">\(J(a, a, refl_a)\)</span> so we can see that <span class="math">\(refl_x = relf_x^{-1}\)</span> by definition, or say, by computing the inductive, but we are not going to compute for different <span class="math">\(p_1 \neq p_2\)</span> it is just like <span class="math">\(succ(x)\)</span> will not compute, but can we get something out? like in <span class="math">\(\Pi\)</span>?</p></li>
<li><p>fibers</p></li>
<li><p>by computation, we means that all elements of a type has normal representation. so lem is not computation</p></li>
<li><p>what kind of madness will a guy abstract out something called <span class="math">\(J\)</span> to replace the old-good reflective and transitive? but it is just that all these rules like product etc. is meaningless, the meaning is given by us</p></li>
<li><p>so why it is called induction? you proof the <strong>base case</strong> then you have it for all? it is like no matter how many path you define, the only base case you have is <span class="math">\(refl\)</span>, but why?</p></li>
<li><p>so basically form this, you can deduce the functionality for various types, just use the <span class="math">\(refl\)</span>!… this is silly…</p></li>
<li><strong>lifting property</strong>
<ul>
<li>yes… equal <span class="math">\(x\)</span> gives equal type <span class="math">\(A[x]\)</span>, but what this equal means? for example, if we define a type <span class="math">\(A\)</span> indexed by an interval, then what does two <strong>inductive type</strong> equal means? though it means <span class="math">\(tr(p)\)</span>, but what is it?</li>
<li>he shows that the two type is equal, and also there is a bejection</li>
</ul></li>
<li><p>i think by lecture 08 and the exercises i finally have know what it means in identity type…</p></li>
<li><p>the proof of <span class="math">\(B[a]\)</span> is very related by <span class="math">\(B[a']\)</span>!!! this is what proof-relevant!!!</p></li>
<li><p>inaccessible cardinal, he says that <span class="math">\(\omega\)</span> is an inaccessible cardinal… what a brilliant idea!!!</p></li>
<li><p>h-level: things have large size tends to have large dimension</p></li>
<li><p><span class="math">\(\Pi-F\)</span> is just <span class="math">\(U-I-\Pi\)</span></p></li>
<li>universal polymorphism: i should implement it!!!
<ul>
<li>it is dam difficult to write down the code the universe has no solution…</li>
</ul></li>
<li>axiom of extensionality
<ul>
<li>under context <span class="math">\(x\)</span> <span class="math">\(y\)</span>, you can proof <span class="math">\(x +y = y + x\)</span> and you by transport <span class="math">\(\lambda x. \lambda    y.    x + y = \lambda x. \lambda y.y+x\)</span>, but they are not definitional equal, you can always normalize by applying the function, but how can you normalize a lambda? so we add that if <span class="math">\(Id_A(x, y)\)</span> then <span class="math">\(x\equiv y\)</span></li>
<li>so when you want to know if <span class="math">\(x \equiv y\)</span>, then you have terrible things happening… haha!!! so it is a totally bad idea!!!</li>
<li>actually, with out the extensionality, there is no contradiction in my option…</li>
</ul></li>
<li><p>in mathematics, function is one-side-injection relations, they do not tell at all how the elements is get. but in hott, it is different, set theory use extensionality, but in tt, it is not the case</p></li>
<li><p>if we have extensionality, then because <span class="math">\(x +y\equiv y +x\)</span> then <span class="math">\(\lambda x. \lambda y .x + y \equiv \lambda x. \lambda y. y + x\)</span> then we have the <span class="math">\(refl\)</span></p></li>
<li>he has some remarks about ITT and ETT
<ol style="list-style-type: decimal">
<li>something happened in HoTT is bad</li>
<li>ITT type checking is intractable… why?</li>
</ol></li>
<li><p>so my version is not ETT… it is incomplete ITT…</p></li>
<li><p>so in the past, they use ITT just for the decidable type checking, without even thinking they can add more path…</p></li>
<li><p>why not category - groupoid - set, we can pick anyone… actually??</p></li>
<li><p>in ETT, we have <strong>strict sets</strong> they are just eq, but in ITT we proof that the <span class="math">\(Id\)</span> is equal, but not judgementally, which cannot be done</p></li>
<li><p>in the path thing, we can talk about how a proof can be conveyed to a proof in other place!!</p></li>
<li><p>i think because we have new identity, we have trouble with <span class="math">\(J\)</span></p></li>
<li><p>in ITT, everything is cool, but he do not want to go into meta-theory</p></li>
<li><p>for Harper, if it has no computational meaning, it is basically useless</p></li>
<li><p>yes… the inductive rule of identity, it worried me greatly…</p></li>
<li><p>it is the lie holds only by bigger lies…</p></li>
<li><p>so in hott, functors is more basic than functions!</p></li>
<li><p>homotopy is assembly… and hott is advanced pl…</p></li>
<li><p>compile and encoding nat in sets</p></li>
<li>so it is not safe to say <span class="math">\(=_\mathcal{U}\)</span>, but we say… and make them higher!
<ul>
<li>in ITT they are different, in equivalence, we use homtopoy, not function of types</li>
</ul></li>
<li><p>function extensionality: in the ITT setting, we just do not know, in HoTT, we said there are one path, but we cannot define now. and in ETT, we said they are just equal</p></li>
<li><p>negative of type has easy path structure, but positive type has not….</p></li>
<li><p>i think i begin to have a metal model on what’s going on in this kind of things…</p></li>
<li><p>yes… small type matters in theory</p></li>
<li><p>what is universe? if we can identify universe as a small thing, we might make true progress</p></li>
<li><p>i still cannot understand the book i think</p></li>
</ul>
<h2 id="references">references</h2>
<ul>
<li><span id="cross-ref-hott" class="crosslink">ref-hott</span> <em>Homotopy Type Theory</em></li>
<li><span id="cross-ref-cmu-course" class="crosslink">ref-cmu-course</span> <a href="http://www.cs.cmu.edu/~rwh/courses/hott">http://www.cs.cmu.edu/~rwh/courses/hott</a></li>
<li><span id="cross-ref-ias" class="crosslink">ref-ias</span> <a href="http://uf-ias-2012.wikispaces.com/Higher+Inductive+Types">http://uf-ias-2012.wikispaces.com/Higher+Inductive+Types</a></li>
</ul>
<h1 id="category">category</h1>
<h2 id="idea-1">idea</h2>
<p>it is a very good language we use to study the structure</p>
<p>there are things called higher categories, but i think i cannot study them now…</p>
<h2 id="category-1">category</h2>
<h3 id="category-2">category</h3>
<ul>
<li><span><span id="cross-category-theory"></span><span id="cross-category" class="crosslink">category</span></span>
<ul>
<li><span id="cross-object" class="crosslink">object</span></li>
<li><span id="cross-morphism" class="crosslink">morphism</span>
<ul>
<li><span id="cross-domain" class="crosslink">domain</span></li>
<li><span id="cross-codomain" class="crosslink">codomain</span></li>
<li><span id="cross-identity-morphism" class="crosslink">identity morphism</span>. <span class="math">\(\forall f: A\to B: {\text{id}}_B \circ f = f \circ {\text{id}}_A\)</span>
<ul>
<li>identity, it is not <a href="#cross-identity-type">identity type</a>, it should be <a href="#cross-refl">refl</a>, isomorphism is <a href="#cross-identity-type">identity type</a></li>
<li><span id="cross-left-inverse" class="crosslink">left inverse</span>, <span id="cross-right-inverse" class="crosslink">right inverse</span>, <span id="cross-inverse" class="crosslink">inverse</span></li>
<li>unique: if one, must be it, if two, <span class="math">\(a= ab = b\)</span></li>
<li><span class="math">\(ff = f\)</span> is not sufficient: constant map, algebraic inverse</li>
</ul></li>
<li><span id="cross-isomorphism" class="crosslink">isomorphism</span>. two <a href="#cross-morphism">morphism</a> such that diagram <code>id_A A f/g B id_B</code> commute</li>
<li><span id="cross-monomorphism" class="crosslink">monomorphism</span>. <span class="math">\(f g = f h\)</span> implies <span class="math">\(g = h\)</span>
<ul>
<li>if <span class="math">\(f: A\to B\)</span> has a <a href="#cross-left-inverse">left inverse</a> <span class="math">\(g: B\to A\)</span>, <span class="math">\(g f = id_A\)</span>, then <span class="math">\(f\)</span> is monomorphism, and <span class="math">\(g\)</span> is <a href="#cross-epimorphism">epimorphism</a>. it shows that the idea of left/right inverse is useful sometimes</li>
<li>you should think that two map before a monomorphism, then the later structure is compressible, you can study the structure of two map to show things about the two composite</li>
</ul></li>
<li><span id="cross-epimorphism" class="crosslink">epimorphism</span></li>
<li><span><span id="cross-endofunctor"></span><span id="cross-endomorphism" class="crosslink">endomorphism</span></span>. maps to self</li>
<li><span id="cross-automorphism" class="crosslink">automorphism</span>. <a href="#cross-endomorphism">endomorphism</a> and <a href="#cross-isomorphism">isomorphism</a></li>
</ul></li>
<li><a href="#cross-associative">associative</a> . <a href="#cross-composition-law">composition law</a> of <a href="#cross-morphism">morphism</a></li>
<li>exists <a href="#cross-identity-morphism">identity morphism</a></li>
<li><span id="cross-connected-category" class="crosslink">connected category</span></li>
<li><span id="cross-concrete-category" class="crosslink">concrete category</span> <span class="math">\(({\mathcal{C}}, U:{\mathcal{C}}\to\mathcal{Set})\)</span> and <span class="math">\(U\)</span> is <a href="#cross-faithful-functor">faithful functor</a>
<ul>
<li>in concrete category, every <a href="#cross-injective">injective</a> function is <a href="#cross-monomorphism">monomorphism</a>, same for <a href="#cross-epimorphism">epimorphism</a></li>
<li>example of non concrete category, <a href="#cross-homotopy-space">homotopy space</a></li>
</ul></li>
</ul></li>
</ul>
<h3 id="category-category">category category</h3>
<ul>
<li><a href="#cross-category">category</a> of <a href="#cross-category">category</a>, <span class="math">\({\mathcal{Cat}}\)</span> (or all small categories)
<ul>
<li>it is an <a href="#cross-2-category">2-category</a></li>
<li><a href="#cross-object">object</a>. <a href="#cross-category">category</a></li>
<li><a href="#cross-morphism">morphism</a>. <span id="cross-functor" class="crosslink">functor</span>, preserve <a href="#cross-identity-morphism">identity morphism</a> and <a href="#cross-law-of-composition">law of composition</a>: <span class="math">\(F({\text{id}}_x) = {\text{id}}_{F(x)}\)</span>, <span class="math">\(F(g\circ f) = F(g) \circ F(f)\)</span>
<ul>
<li><a href="#cross-identity-morphism">identity morphism</a>: <span id="cross-identity-functor" class="crosslink">identity functor</span></li>
<li>it preserve all commuting diagrams
<ul>
<li>this is not sufficient, consider a functor maps to a constant and a constant map</li>
</ul></li>
<li><span id="cross-full" class="crosslink">full</span> and <span id="cross-faithful" class="crosslink">faithful</span> if the <span class="math">\({\mathcal{C}}(X, Y)\to{\mathcal{D}}(F(X), F(Y))\)</span> is <a href="#cross-epimorphism">epimorphism</a>/<a href="#cross-monomorphism">monomorphism</a>
<ul>
<li><span id="cross-full-subcategory" class="crosslink">full subcategory</span></li>
</ul></li>
<li><span><span id="cross-category-equivalence"></span><span id="cross-equivalence-of-category" class="crosslink">equivalence of category </span></span>. <a href="http://en.wikipedia.org/wiki/Equivalence_of_categories">Wikipedia</a>. it is two map in <span class="math">\({\mathcal{Cat}}\)</span> such that …
<ul>
<li>think you self what an <a href="#cross-isomorphism">isomorphism</a> of category is, it is like <span class="math">\(GF={\text{Id}}_{\mathcal{C}}\)</span>, <span class="math">\(FG={\text{Id}}_{\mathcal{D}}\)</span>, then equivalence of category weaken this condition by replace <span class="math">\(=\)</span> with <a href="#cross-natural-isomorphism">natural isomorphism</a></li>
<li>like <a href="#cross-isomorphism">isomorphism</a>, you should always focus on <strong>which arrows</strong> you are dealing with, not merely they are equivalence</li>
</ul></li>
</ul></li>
<li><a href="#cross-law-of-composition">law of composition</a>. <a href="#cross-function-composition">function composition</a></li>
<li><span id="cross-product-category" class="crosslink">product category</span></li>
<li><span id="cross-dual-category" class="crosslink">dual category</span>
<ul>
<li><span id="cross-contravariant" class="crosslink">contravariant</span></li>
</ul></li>
<li><span id="cross-skeleton-category" class="crosslink">skeleton category</span>
<ul>
<li><a href="#cross-category-equivalence">category equivalence</a>
<ul>
<li>injection <a href="#cross-functor">functor</a>: <span class="math">\(J: \text{sk}\mathcal{l}\to \mathcal{l}\)</span></li>
<li>inverse functor: you know~</li>
</ul></li>
</ul></li>
<li><span id="cross-arrow-category" class="crosslink">arrow category</span></li>
<li><span id="cross-slice-category" class="crosslink">slice category</span>
<ul>
<li><a href="#cross-product">product</a> in <a href="#cross-slice-category">slice category</a> can be viewed as <a href="#cross-pullback">pullback</a></li>
</ul></li>
<li><span id="cross-coslice-category" class="crosslink">coslice category</span>
<ul>
<li><span class="math">\(x\backslash \mathcal{C}\)</span> is the category <span class="math">\(f: x\to y\)</span> as <a href="#cross-object">object</a>s, and <span class="math">\(\lambda:f\to g\)</span> such that <span class="math">\(\lambda \circ f = g\)</span> as <a href="#cross-morphism">morphism</a>s</li>
<li>when the category is a groupoid, then <span class="math">\(\lambda = g \circ f^{-1}\)</span> is determined</li>
</ul></li>
</ul></li>
</ul>
<h3 id="functor-category">functor category</h3>
<ul>
<li><span id="cross-comma-category" class="crosslink">comma category</span>. <span class="math">\((T\downarrow U)\)</span>, <span class="math">\(T:{\mathcal{D}}\to{\mathcal{C}}\)</span>, <span class="math">\(U:\mathcal{A}\to{\mathcal{C}}\)</span>
<ul>
<li><a href="#cross-object">object</a>. <span class="math">\((D, f, A)\)</span>, <span class="math">\(f: T(D)\to T(A)\)</span></li>
<li><a href="#cross-morphism">morphism</a>. <span class="math">\((f_T, f_U)\in ({\mathcal{D}}, \mathcal{A})\)</span>, such that the digram <code>T(f_T) * f_1 = f_2 * U(f_U)</code> computes</li>
<li>is is used to define several important constructs</li>
</ul></li>
<li><a href="#cross-category">category</a> of <a href="#cross-functor">functor</a>s <span class="math">\({\mathcal{D}}\to{\mathcal{C}}= {\mathcal{C}}^{\mathcal{D}}\)</span>
<ul>
<li><a href="#cross-object">object</a>. <a href="#cross-functor">functor</a></li>
<li><a href="#cross-morphism">morphism</a>. <span id="cross-natural-transform" class="crosslink">natural transform</span>, for <span class="math">\(T,U:{\mathcal{D}}\to{\mathcal{C}}\)</span>, <span class="math">\(\tau: {\mathcal{D}}\to (T\downarrow U)\)</span> such that <span class="math">\(P\circ \tau = Q\circ \tau = {\text{Id}}_{\mathcal{D}}\)</span>
<ul>
<li><a href="#cross-isomorphism">isomorphism</a>. <span id="cross-natural-isomorphism" class="crosslink">natural isomorphism</span>, we usually use <span class="math">\(\cong\)</span> as the notation
<ul>
<li>if <span class="math">\(\alpha_A\)</span> is <a href="#cross-isomorphism">isomorphism</a>s, then we have natural isomorphism</li>
</ul></li>
</ul></li>
<li><a href="#cross-law-of-composition">law of composition</a>. you can see it</li>
</ul></li>
</ul>
<h3 id="universal-arrow">universal arrow</h3>
<ul>
<li><span id="cross-universal-arrow" class="crosslink">universal arrow</span>: <a href="#cross-initial">initial</a> in <a href="#cross-comma-category">comma category</a> <span class="math">\((x\downarrow U:{\mathcal{D}}\to{\mathcal{C}})\)</span>, like correlated line and point, and morphism as morphism in <span class="math">\({\mathcal{D}}\)</span>
<ul>
<li><strong>universal arrow</strong> is unique up to <a href="#cross-isomorphism">isomorphism</a>, so is <a href="#cross-colimit">colimit</a> and so is <a href="#cross-limit">limit</a></li>
<li>example: <a href="#cross-forgetful-functor">forgetful functor</a> from <a href="#cross-monoid">monoid</a> <span class="math">\(\mathcal{Mon}\)</span> to <span class="math">\(\mathcal{Set}\)</span>, every set has a universal arrow, by freely generate words in the monoid</li>
</ul></li>
</ul>
<h3 id="colimit-and-limit">colimit and limit</h3>
<ul>
<li><span id="cross-diagram" class="crosslink">diagram</span>
<ul>
<li>a <span class="math">\(\mathcal{D}\)</span>-shaped diagram in <span class="math">\(\mathcal{C}\)</span> is a functor <span class="math">\(F: \mathcal{D}\to \mathcal{C}\)</span></li>
<li><span class="math">\(\mathcal{D}[\mathcal{C}]\)</span> is the category of diagrams</li>
</ul></li>
<li><span id="cross-diagonal-functor" class="crosslink">diagonal functor</span>, <span class="math">\(\Delta:{\mathcal{C}}\to {\mathcal{C}}^{\mathcal{D}}\)</span>
<ul>
<li><a href="#cross-object">object</a>: <span class="math">\(C\in {\mathcal{C}}\)</span> to constant <a href="#cross-diagram">diagram</a> <span class="math">\({\mathcal{D}}\to{\mathcal{C}}\)</span></li>
<li><a href="#cross-morphism">morphism</a>: <a href="#cross-natural-transform">natural transform</a> of them, actually any <a href="#cross-morphism">morphism</a> between <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> will do</li>
</ul></li>
<li><span id="cross-colimit" class="crosslink">colimit</span>: for functor <span class="math">\(J:{\mathcal{D}}\to{\mathcal{C}}\)</span> <a href="#cross-universal-arrow">universal arrow</a> from <span class="math">\(J\)</span> to <a href="#cross-diagonal-functor">diagonal functor</a> <span class="math">\(\Delta:{\mathcal{C}}\to{\mathcal{C}}^{\mathcal{D}}\)</span> <code>fix me</code>. mapping out. the universal arrow is actually a set of arrows, see the picture
<ul>
<li><span id="cross-initial" class="crosslink">initial</span></li>
<li><span id="cross-coproduct" class="crosslink">coproduct</span>
<ul>
<li><span id="cross-generalized-coproduct" class="crosslink">generalized coproduct</span> infinite case?</li>
</ul></li>
<li><span id="cross-coequalizer" class="crosslink">coequalizer</span></li>
<li><span id="cross-pushout" class="crosslink">pushout</span></li>
<li><span id="cross-cocomplete" class="crosslink">cocomplete</span>
<ul>
<li>have all <a href="#cross-colimit">colimit</a>s</li>
<li><a href="#cross-generalized-coproduct">generalized coproduct</a> and <a href="#cross-coequalizer">coequalizer</a> is sufficient <code>fix me</code>
<ul>
<li>proof for <span class="math">\(\mathcal{Set}\)</span> and <span class="math">\(\mathcal{Mon}\)</span> <code>fix me</code></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><img src="./images/limit.jpg" style="width:450px" /></p>
<ul>
<li><span id="cross-limit" class="crosslink">limit</span>: mapping in
<ul>
<li><span id="cross-terminal" class="crosslink">terminal</span>. empty diagram</li>
<li><span id="cross-product" class="crosslink">product</span>. two point diagram</li>
<li><span><span id="cross-fiber-product"></span><span id="cross-pullback" class="crosslink">pullback </span></span>. three point and two morphism diagram
<ul>
<li>has <a href="#cross-equalizer">equalizer</a> and <a href="#cross-product">product</a> then has pullback</li>
</ul></li>
<li><span id="cross-equalizer" class="crosslink">equalizer</span>. two point and two morphism diagram</li>
<li><span id="cross-complete" class="crosslink">complete</span>
<ul>
<li>have all <a href="#cross-limit">limit</a>s</li>
<li><a href="#cross-product">product</a> and <a href="#cross-equalizer">equalizer</a> is sufficient</li>
</ul></li>
</ul></li>
<li><span><span id="cross-preserve-limits"></span><span id="cross-preserve-colimits" class="crosslink">preserve colimits</span></span> <code>fix me</code>
<ul>
<li><span id="cross-cocontinuous" class="crosslink">cocontinuous</span>. preserve colimits</li>
<li><span id="cross-continuous" class="crosslink">continuous</span>. preserve limits</li>
</ul></li>
</ul>
<h3 id="adjoint">adjoint</h3>
<ul>
<li>if every element of <span class="math">\({\mathcal{C}}\)</span> has an <a href="#cross-universal-arrow">universal arrow</a>, then we can define a reverse functor <span class="math">\(F\)</span>, and we can show <a href="#cross-universal-arrow">universal arrow</a>s exists in <span class="math">\({\mathcal{D}}\)</span>, and another <a href="#cross-natural-transform">natural transform</a>
<ul>
<li>see <a href="#cross-ref-category-notes">ref-category-notes</a> for diagram <code>f| A/B =u_A/u_B= UFA/ UFB | UFf</code></li>
<li>check preserve id: ok + unique = defined</li>
<li>check preserve law: think by “moving equal path on graph”</li>
<li>and the arrows is an <a href="#cross-natural-transform">natural transform</a> from <span class="math">\({\text{Id}}_{\mathcal{C}}\)</span> to <span class="math">\(F\)</span></li>
<li>though we do not know if the <a href="#cross-initial">initial</a> is unique, we can still define it</li>
</ul></li>
</ul>
<p><img src="./images/adjoint.jpg" style="width:450px" /></p>
<p><img src="./images/adjoint2.jpg" style="width:450px" /></p>
<ul>
<li><span><span id="cross-category-adjoint"></span><span id="cross-adjoint-functor"></span><span id="cross-adjuction-of-category" class="crosslink">adjuction of category </span></span>. <span class="math">\(F\dashv U\)</span>, <span class="math">\(U\)</span> is <a href="#cross-right-adjoint">right adjoint</a>, <span class="math">\(F\)</span> is <a href="#cross-left-adjoint">left adjoint</a>
<ul>
<li><em>def a from <a href="#cross-ref-category-notes">ref-category-notes</a></em> for <span class="math">\({\mathcal{C}}\)</span> and <span class="math">\({\mathcal{D}}\)</span>, <span class="math">\(F:{\mathcal{C}}\to{\mathcal{D}}\)</span>, <span class="math">\(U:{\mathcal{D}}\to{\mathcal{C}}\)</span>, a bijection <span class="math">\(\varphi_{C, D}: {\mathcal{D}}(FC, D) \cong{\mathcal{C}}(C, UD)\)</span> such that <span class="math">\(\varphi(k\circ g) = Uk\circ \varphi(g)\)</span> and …</li>
<li>in Wikipedia, it says that it means optimization</li>
<li><em>def b</em> <span class="math">\(\eta:{\text{Id}}_{\mathcal{C}}\Rightarrow UF\)</span> and <span class="math">\(\epsilon: FU\Rightarrow{\text{Id}}_{\mathcal{D}}\)</span> such that the diagram holds</li>
<li><span id="cross-left-adjoint" class="crosslink">left adjoint</span>, <span id="cross-right-adjoint" class="crosslink">right adjoint</span>,
<ul>
<li><a href="#cross-left-adjoint">left adjoint</a> is <a href="#cross-cocontinuous">cocontinuous</a>, <a href="#cross-right-adjoint">right adjoint</a> is <a href="#cross-continuous">continuous</a> <code>fix me</code></li>
</ul></li>
<li><span class="math">\(\mathcal{Ab}(F(S), A) \cong\mathcal{S}(S, U(A))\)</span> between the functor take <a href="#cross-set">set</a> to <a href="#cross-freely-generated-abelian-group">freely generated abelian group</a> and the functor that from the group to the set. it means the the morphisms in one category can be fully described by morphisms in another a map from <span class="math">\(S\)</span> to <span class="math">\(U(A)\)</span> fully describe the homomorphisms from <span class="math">\(F(S)\)</span> to <span class="math">\(A\)</span></li>
<li>it further generalize <a href="#cross-equivalence-of-category">equivalence of category</a> by replace <a href="#cross-natural-isomorphism">natural isomorphism</a> by certain <a href="#cross-natural-transformation">natural transformation</a></li>
<li>from <a href="http://ncatlab.org/nlab/show/2-category">nLab</a> we know that we should have a better understanding with <a href="#cross-higher-order-category">higher order category</a> <code>fix me: when you know higher order category</code>, so i should think moving this section again</li>
<li>adjunction induce two <a href="#cross-natural-transformation">natural transformation</a> . <span id="cross-unit-of-adjunction" class="crosslink">unit of adjunction</span> <span class="math">\(eta: {\text{Id}}_{\mathcal{C}}\Rightarrow UF\)</span> and <span id="cross-counit-of-adjunction" class="crosslink">counit of adjunction</span> <span class="math">\(\epsilon : FU\Rightarrow {\text{Id}}_{\mathcal{D}}\)</span>, such that <span id="cross-triangular-identities" class="crosslink">triangular identities</span> holds</li>
<li>and <span class="math">\(\varphi\)</span> is determined by <span class="math">\(\eta\)</span> and <span class="math">\(\epsilon\)</span></li>
<li>adjoint functor determine each other up to isomorphism</li>
</ul></li>
</ul>
<p><img src="./images/adjoint3.jpg" style="width:450px" /></p>
<p><img src="./images/adjoint4.jpg" style="width:450px" /></p>
<h3 id="monads">monads</h3>
<p><code>fix me: finish the lecture</code></p>
<h3 id="references-1">references</h3>
<ul>
<li><span id="cross-ref-youtube-category-video" class="crosslink">ref-youtube-category-video</span> <a href="http://simonwillerton.staff.shef.ac.uk/TheCatsters">http://simonwillerton.staff.shef.ac.uk/TheCatsters</a>
<ul>
<li>i understand <a href="#cross-limit">limit</a> from here</li>
</ul></li>
<li><span id="cross-ref-category-awodey" class="crosslink">ref-category-awodey</span> <em>Category Theory</em>, Awodey
<ul>
<li>my intro book</li>
</ul></li>
<li><span id="cross-ref-category-notes" class="crosslink">ref-category-notes</span> <em>Category Theory Lecture Notes</em>
<ul>
<li>excellent! this will be great for review, but i do not know if one can read this first</li>
<li>most notes here is adapted from these notes</li>
</ul></li>
<li><span id="cross-ref-category-for" class="crosslink">ref-category-for</span> <em>Category Theory for Working Mathematician</em></li>
</ul>
<h2 id="higher-category">higher category</h2>
<ul>
<li><span id="cross-2-category" class="crosslink">2-category</span></li>
</ul>
<h1 id="set">set</h1>
<h2 id="idea-2">idea</h2>
<p>types that has no non-trivial <a href="#cross-identity">identity</a>, 0-type</p>
<p>as an foundation of mathematics, there are so many ideas expressed using these…</p>
<h2 id="basic-set-theory">basic set theory</h2>
<ul>
<li><span id="cross-set" class="crosslink">set</span>, <span class="math">\({\mathcal{Set}}\)</span>
<ul>
<li><a href="#cross-object">object</a>. axioms:
<ul>
<li><span id="cross-extensionality-axiom" class="crosslink">extensionality axiom</span></li>
<li><span id="cross-pairing-axiom" class="crosslink">pairing axiom</span></li>
<li><span id="cross-union-axiom" class="crosslink">union axiom</span></li>
<li><span id="cross-power-axiom" class="crosslink">power axiom</span>
<ul>
<li><a href="#cross-function">function</a> is defined in ZFC using this</li>
</ul></li>
<li><span id="cross-replacement-axiom" class="crosslink">replacement axiom</span></li>
<li><span id="cross-infinity-axiom" class="crosslink">infinity axiom</span></li>
<li><span id="cross-regularity-axiom" class="crosslink">regularity axiom</span>. has <span class="math">\(\in\)</span>-minimum element</li>
</ul></li>
<li><a href="#cross-morphism">morphism</a>. <a href="#cross-function">function</a>
<ul>
<li><span id="cross-image" class="crosslink">image</span></li>
<li><a href="#cross-isomorphism">isomorphism</a>. <span id="cross-bijection" class="crosslink">bijection</span></li>
<li><a href="#cross-monomorphism">monomorphism</a>. <span id="cross-injection" class="crosslink">injection</span></li>
<li><a href="#cross-epimorphism">epimorphism</a>. <span id="cross-surjection" class="crosslink">surjection</span></li>
</ul></li>
<li><span><span id="cross-loc"></span><span id="cross-law-of-composition" class="crosslink">law of composition </span></span>. we define here. because usually they are used in classical sense, it is just map <span class="math">\(S_1\times S_2\to S_3\)</span>
<ul>
<li><span id="cross-associative" class="crosslink">associative</span> <span class="math">\(abc = a(bc)\)</span>
<ul>
<li>you can insert any parentheses</li>
</ul></li>
<li><span id="cross-commutative" class="crosslink">commutative</span> <span class="math">\(ab = ba\)</span> it seems then we must have <span class="math">\(S_1 = S_2 = S_3\)</span>?</li>
<li>example of non-associative loc: <span class="math">\(-\)</span> for integer</li>
</ul></li>
<li><a href="#cross-product">product</a>. <span id="cross-Cartesian-product" class="crosslink">Cartesian product</span></li>
<li><a href="#cross-coproduct">coproduct</a>. <span id="cross-disjoint-union" class="crosslink">disjoint union</span></li>
<li><span><span id="cross-inclusion"></span><span id="cross-inclusion-function"></span><span id="cross-subset" class="crosslink">subset </span></span></li>
<li><span id="cross-set-limit" class="crosslink">set limit</span>
<ul>
<li><span class="math">\(\lim\inf A_i = \bigcup_i \bigcap_{j &gt;=i} A_j\)</span>, in all but finite</li>
<li><span class="math">\(\lim\sup A_i = \bigcap_i \bigcup_{j &gt;=i} A_j\)</span>, in infinite sets</li>
<li><span class="math">\(\lim A_i\)</span></li>
</ul></li>
<li><span id="cross-cover" class="crosslink">cover</span></li>
</ul></li>
<li><span id="cross-pointed-set" class="crosslink">pointed set</span> <span class="math">\(\mathcal{Set}_*\)</span></li>
</ul>
<h3 id="ordering">ordering</h3>
<ul>
<li><span><span id="cross-partial-ordering"></span><span id="cross-pos"></span><span id="cross-partially-ordered-set" class="crosslink">partially ordered set </span></span>
<ul>
<li><a href="#cross-object">object</a>.
<ul>
<li><span class="math">\(p \nless p\)</span></li>
<li><span class="math">\(p &lt; q \land q &lt; r \Rightarrow p &lt; r\)</span></li>
</ul></li>
<li><a href="#cross-morphism">morphism</a>. <span id="cross-order-preserving" class="crosslink">order-preserving</span> . <a href="#cross-function">function</a>s
<ul>
<li><a href="#cross-isomorphism">isomorphism</a></li>
<li><a href="#cross-automorphism">automorphism</a></li>
</ul></li>
<li><span class="math">\((P, &lt;)\)</span> is a pos, <span class="math">\(X\)</span> a subset
<ul>
<li><span id="cross-maximal" class="crosslink">maximal</span>. <span class="math">\(a\in X\land \forall x :a  \nless x\)</span></li>
<li><span id="cross-minimal" class="crosslink">minimal</span>. <span class="math">\(a\in X\land\forall x: x \nless a\)</span></li>
<li><span id="cross-greatest-element" class="crosslink">greatest element</span>. <span class="math">\(a\in X\land\forall x: x\leq a\)</span>, is <a href="#cross-maximal">maximal</a></li>
<li><span id="cross-least-element" class="crosslink">least element</span>. <span class="math">\(a\in X \land \forall x a\leq x\)</span>, is <a href="#cross-minimal">minimal</a></li>
<li><span id="cross-upper-bound" class="crosslink">upper bound</span>. <span class="math">\(\forall x: x \leq a\)</span></li>
<li><span id="cross-lower-bound" class="crosslink">lower bound</span>. <span class="math">\(\forall x: a \leq x\)</span></li>
<li><span><span id="cross-least-upper-bound"></span><span id="cross-sup" class="crosslink">sup </span></span></li>
<li><span><span id="cross-greatest-lower-bound"></span><span id="cross-inf" class="crosslink">inf </span></span></li>
</ul></li>
</ul></li>
<li><span id="cross-linear-ordering" class="crosslink">linear ordering</span> is subcategory of <a href="#cross-pos">pos</a>
<ul>
<li><a href="#cross-object">object</a>
<ul>
<li><span class="math">\(\forall p,q: p &lt; q \lor p = q \lor q &lt; p\)</span></li>
</ul></li>
<li><a href="#cross-morphism">morphism</a>
<ul>
<li><span id="cross-increasing-function" class="crosslink">increasing function</span> which is just <a href="#cross-order-preserving">order-preserving</a> function</li>
<li><span id="cross-decreasing-function" class="crosslink">decreasing function</span></li>
<li><span id="cross-strict-increasing-function" class="crosslink">strict increasing function</span></li>
<li><span id="cross-strict-decreasing-function" class="crosslink">strict decreasing function</span></li>
</ul></li>
</ul></li>
<li><span><span id="cross-well-ordered"></span><span id="cross-well-ordering" class="crosslink">well ordering </span></span> is subcategory of <a href="#cross-linear-ordering">linear ordering</a>
<ul>
<li><a href="#cross-object">object</a>. linear ordering that every non-empty subset has least</li>
<li><a href="#cross-morphism">morphism</a>
<ul>
<li>increasing function of well-ordering <span class="math">\(f(x) \ge x\)</span></li>
<li><a href="#cross-isomorphism">isomorphism</a>. <span class="math">\(W_1\)</span> and <span class="math">\(W_2\)</span> only has unique isomorphism
<ul>
<li>no well ordered set is isomorphic to it’s <a href="#cross-initial-segment">initial segment</a></li>
</ul></li>
<li><a href="#cross-automorphism">automorphism</a>. the only automorphism is <span class="math">\(id\)</span></li>
<li>for <span class="math">\(W_1\)</span> and <span class="math">\(W_2\)</span> or they are <a href="#cross-isomorphic">isomorphic</a>, or one is <a href="#cross-isomorphic">isomorphic</a> to other’s <a href="#cross-initial-segment">initial segment</a></li>
</ul></li>
<li><span id="cross-initial-segment" class="crosslink">initial segment</span></li>
</ul></li>
</ul>
<h3 id="ordinal">ordinal</h3>
<ul>
<li><span><span id="cross-ordinal"></span><span id="cross-ordinal-number" class="crosslink">ordinal number </span></span> <span class="math">\(\mathcal{Ord}\)</span>
<ul>
<li><span id="cross-transitive-set" class="crosslink">transitive set</span>. <span class="math">\(T\)</span> such that <span class="math">\(x\in T\Rightarrow x\subset T\)</span></li>
<li><a href="#cross-ordinal-number">ordinal number</a>. <a href="#cross-transitive-set">transitive set</a> and <a href="#cross-well-ordered">well ordered</a> by <span class="math">\(\in\)</span></li>
<li><span class="math">\(\emptyset\)</span> is ordinal</li>
<li>if <span class="math">\(\alpha\)</span> is ordinal, <span class="math">\(\beta\in \alpha\)</span> then <span class="math">\(\beta\)</span> is ordinal
<ul>
<li>proof by chaining…</li>
</ul></li>
<li><span class="math">\(\alpha \subset \beta\Rightarrow\alpha\in\beta\)</span></li>
<li>either <span class="math">\(\alpha \subset \beta\)</span> or <span class="math">\(\beta\subset\alpha\)</span></li>
<li>define the order by <span class="math">\(\lt\)</span> is <span class="math">\(\in\)</span>
<ul>
<li>is <a href="#cross-linear-ordering">linear ordering</a></li>
</ul></li>
<li>… a lot thing</li>
<li><span id="cross-successor-ordinal" class="crosslink">successor ordinal</span> and <span id="cross-limit-ordinal" class="crosslink">limit ordinal</span></li>
<li><span id="cross-natural-numbers" class="crosslink">natural numbers</span> <span class="math">\(\omega\)</span> or <span class="math">\(\mathbb{N}\)</span>
<ul>
<li><span id="cross-finite" class="crosslink">finite</span> and <span id="cross-infinite" class="crosslink">infinite</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="cardinal">cardinal</h3>
<ul>
<li><span><span id="cross-cardinality"></span><span id="cross-cardinal" class="crosslink">cardinal </span></span>
<ul>
<li>what it means by: <span class="math">\(|X| = |Y|\)</span> and <span class="math">\(|X| &lt; |Y|\)</span></li>
<li><span class="math">\(|X| &lt; |P(X)|\)</span></li>
<li><span class="math">\(|A| \leq |B| \land |B| \leq |A| \Rightarrow |A| = |B|\)</span></li>
<li>cardinal arith
<ul>
<li><span class="math">\(a + b = |A\cup B|\)</span> disjoint</li>
<li><span class="math">\(a \cdot b = |A\times B|\)</span></li>
<li><span class="math">\(a^b = |A^B|\)</span>
<ul>
<li><span class="math">\(|P(A)| = 2^{|A|}\)</span></li>
</ul></li>
</ul></li>
<li><a href="#cross-cardinal-number">cardinal number</a>. an <a href="#cross-ordinal">ordinal</a> such that <span class="math">\(\forall b &lt; a: |a| \neq |b|\)</span>
<ul>
<li><span id="cross-finite-cardinal" class="crosslink">finite cardinal</span></li>
<li>all <span><span id="cross-infinite-cardinal"></span><span id="cross-aleph" class="crosslink">aleph </span></span> is <a href="#cross-limit-ordinal">limit ordinal</a></li>
</ul></li>
</ul></li>
</ul>
<h3 id="real-numbers">real numbers</h3>
<ul>
<li><span class="math">\(|\mathbb{R}| = 2^{\aleph_0}\)</span>
<ul>
<li><span id="cross-continuum-hypothesis" class="crosslink">continuum hypothesis</span>. <span class="math">\(2^{\aleph_0} = \aleph_1\)</span></li>
</ul></li>
<li><span id="cross-axiom-of-choice" class="crosslink">axiom of choice</span>. for a family of set, exists choice function
<ul>
<li>every set can be well-ordered</li>
<li><span id="cross-Zorn's-lemma" class="crosslink">Zorn's lemma</span>. every linear subset has upper bound then has maximal element</li>
</ul></li>
</ul>
<h2 id="reference">reference</h2>
<ul>
<li><span id="cross-ref-set-jech" class="crosslink">ref-set-jech</span> <em>Set Theory</em>, Thomas Jech</li>
</ul>
<h1 id="algebra">algebra</h1>
<h2 id="basic-objects-of-algebra">basic objects of algebra</h2>
<h3 id="monoid">monoid</h3>
<ul>
<li><span id="cross-monoid" class="crosslink">monoid</span> <span class="math">\({\mathcal{Mon}}\)</span>
<ul>
<li><a href="#cross-object">object</a> <span class="math">\((S\in{\mathcal{Set}}, *:S\times S\to S, e\in S)\)</span>
<ul>
<li><span><span id="cross-unit"></span><span id="cross-unit-element" class="crosslink">unit element </span></span> <span class="math">\(\forall a\in S: ae = ea\)</span>
<ul>
<li>unique. actually, unique in any <a href="#cross-law-of-composition">law of composition</a> with unit</li>
</ul></li>
<li><a href="#cross-law-of-composition">law of composition</a>. <span class="math">\(abc = a(bc)\)</span>, <a href="#cross-associative">associative</a>
<ul>
<li>product of zero element</li>
<li>product of infinite but almost all zero set</li>
<li>show that all these products is well defined</li>
</ul></li>
<li>power <span class="math">\(a^n\)</span></li>
</ul></li>
<li><a href="#cross-morphism">morphism</a>. <span id="cross-monoid-homomorphism" class="crosslink">monoid homomorphism</span>
<ul>
<li><span class="math">\(f(e) = e\)</span></li>
<li><span class="math">\(f(ab) = f(a) f(b)\)</span></li>
</ul></li>
<li><span id="cross-submonoid" class="crosslink">submonoid</span></li>
</ul></li>
</ul>
<h3 id="group">group</h3>
<ul>
<li><span id="cross-groupoid" class="crosslink">groupoid</span>
<ul>
<li><span id="cross-groupoid-connected" class="crosslink">groupoid connected</span>
<ul>
<li>can be viewed as <a href="#cross-connected-category">connected category</a>, then the groupoid viewed as a <a href="#cross-category">category</a> will have <a href="#cross-skeleton-category">skeleton category</a> one element with full <a href="#cross-isomorphism">isomorphism</a></li>
</ul></li>
</ul></li>
<li><span id="cross-group" class="crosslink">group</span> <span class="math">\({\mathcal{Grp}}\)</span> subcategory of <span class="math">\({\mathcal{Mon}}\)</span>
<ul>
<li><a href="#cross-object">object</a>
<ul>
<li><span id="cross-inverse" class="crosslink">inverse</span>. <span class="math">\(xy = yx = e\)</span>
<ul>
<li>unique</li>
</ul></li>
<li><span class="math">\(n,m \in \mathbb{Z}\)</span>, <span class="math">\(a^n a^m = a^{n+m}\)</span>
<ul>
<li>power arithmetic is well defined</li>
</ul></li>
<li>actually left unit and left inverse is sufficient</li>
</ul></li>
<li><a href="#cross-morphism">morphism</a>. <span id="cross-group-homomorphism" class="crosslink">group homomorphism</span> inheritance <a href="#cross-monoid-homomorphism">monoid homomorphism</a>, and only <span class="math">\(f(ab) = f(a)f(b)\)</span> is sufficient
<ul>
<li><span id="cross-kernel" class="crosslink">kernel</span> <span class="math">\({\text{Ker }}f\)</span> is a subgroup
<ul>
<li>kernel is normal. and <a href="#cross-normal">normal</a> is kernel. first is trivial by definition. second is by proofing that there is a group structure on the cosets, this is trivial by <span class="math">\(xHyH = xyH\)</span></li>
</ul></li>
<li><a href="#cross-image">image</a> <span class="math">\({\text{Im }}f\)</span> is a subgroup
<ul>
<li>because we know that it contains the unit</li>
<li>and just from <span class="math">\(f(ab) = f(a)f(b)\)</span> we know that it is closed by multiplication and inverse</li>
</ul></li>
<li>group morphism structure is determined by values on generator. <em>there is two kind of things: group morphism is not defined by values on generator, because it might not be well defined, but it is determined by values on generator, when using this word, we know prior it is a group morphism</em></li>
<li><a href="#cross-monomorphism">monomorphism</a>
<ul>
<li><span class="math">\(\Leftrightarrow\)</span> <a href="#cross-kernel">kernel</a> is trivial</li>
<li>as a set function is <a href="#cross-injective">injective</a></li>
<li><a href="#cross-injective">injective</a> <span class="math">\(\Rightarrow\)</span> <a href="#cross-kernel">kernel</a> and <a href="#cross-monomorphism">monomorphism</a> is trivial, <a href="#cross-kernel">kernel</a> to <a href="#cross-injective">injective</a> by unique inverse, <a href="#cross-monomorphism">monomorphism</a> to <a href="#cross-kernel">kernel</a> is by considering two map <span class="math">\({\mathbb{Z}}\to C_a\)</span></li>
</ul></li>
<li><a href="#cross-epimorphism">epimorphism</a>
<ul>
<li><span class="math">\(\Leftrightarrow\)</span> <a href="#cross-surjective">surjective</a>
<ul>
<li><a href="#cross-surjective">surjective</a> is certainly <a href="#cross-epimorphism">epimorphism</a>, and if we have an <a href="#cross-epimorphism">epimorphism</a>, <code>fix me</code></li>
</ul></li>
<li>the cokernel is not well defined here, but is well defined for abelian groups</li>
</ul></li>
<li><a href="#cross-isomorphism">isomorphism</a>. is <a href="#cross-bijective">bijective</a> . <a href="#cross-morphism">morphism</a>
<ul>
<li><a href="#cross-isomorphism">isomorphism</a> is <a href="#cross-monomorphism">monomorphism</a> + <a href="#cross-epimorphism">epimorphism</a></li>
<li>proof. <a href="#cross-isomorphism">isomorphism</a> is <a href="#cross-monomorphism">monomorphism</a> and <a href="#cross-epimorphism">epimorphism</a> so it is bijective. if it is bijective, we can define the inverse map by just function inverse</li>
</ul></li>
<li><span class="math">\(H\cap K = \{e\}\land HK = G\land hk = kh\)</span> then <span class="math">\(G \cong K\times H\)</span>
<ul>
<li>example: <span class="math">\(C_6 = C_2 \times C_3\)</span>, with <span class="math">\(C_2 = \{0, 3\}\)</span>, <span class="math">\(C_3 = \{0, 2, 4\}\)</span>, actually it is not obvious that <span class="math">\(HK = G\)</span>, but because it is abelian, <span class="math">\(hk = kh\)</span> is obvious</li>
</ul></li>
<li>morphism and <a href="#cross-order-of-group-element">order of group element</a></li>
</ul></li>
<li><span id="cross-order-of-group-element" class="crosslink">order of group element</span>
<ul>
<li>this is kind of like group in algebraic topology, they have something to do with morphisms</li>
<li>formula for <span class="math">\(|g^m|\)</span></li>
<li>the group order divides each other, this is trivial by the index theorem</li>
<li>in <a href="#cross-abelian-group">abelian group</a> the max order divide each other <code>fix me</code>
<ul>
<li>proof see exercise in <a href="#cross-ref-algebra-0">ref-algebra-0</a></li>
</ul></li>
<li>see also <a href="#cross-cyclic-group">cyclic group</a></li>
</ul></li>
<li><span id="cross-subgroup" class="crosslink">subgroup</span>. <a href="#cross-inclusion">inclusion</a> is <a href="#cross-homomorphism">homomorphism</a>
<ul>
<li>or closed</li>
</ul></li>
<li>group multiplication always give an <a href="#cross-isomorphism">isomorphism</a> as set, multiple by inverse is the inverse map</li>
<li><span id="cross-coset" class="crosslink">coset</span>, <span id="cross-left-coset" class="crosslink">left coset</span>, <span id="cross-right-coset" class="crosslink">right coset</span>
<ul>
<li>proof that it is <a href="#cross-equivalence-relation">equivalence relation</a></li>
<li><a href="#cross-coset">coset</a>s have same cardinality, no matter left or right</li>
<li><span class="math">\((G:H)\)</span> <span id="cross-index-of-subgroup" class="crosslink">index of subgroup</span> the <a href="#cross-cardinal">cardinal</a> of <a href="#cross-coset">coset</a>s
<ul>
<li>number of left cosets and right cosets is same, by make a bijection <span class="math">\(aH \to Ha^{-1}\)</span></li>
</ul></li>
<li><span class="math">\((G:H)(H:K) = (G:K)\)</span>
<ul>
<li>example: group of prime order is cyclic. we should always see what subgroup a group have to determine their structure</li>
</ul></li>
</ul></li>
<li><span id="cross-normal-subgroup" class="crosslink">normal subgroup</span> <span class="math">\(gN = Ng\)</span>
<ul>
<li>closed under <a href="#cross-intersection">intersection</a></li>
<li>closed by inverse map, but not morphism!</li>
<li><span id="cross-normalizer" class="crosslink">normalizer</span> <span class="math">\(N_H\)</span> is a group
<ul>
<li>if <span class="math">\(K\subset N_H\)</span> then <span class="math">\(KH\)</span> is a subgroup</li>
</ul></li>
<li><span id="cross-Weyl-group" class="crosslink">Weyl group</span> <span class="math">\(W_H = N_H / H\)</span></li>
<li>smallest index subgroup in finite group is normal</li>
<li>how to consider this? if you consider what things can be a morphism in group, then you will notice that only when we make the group structure fuzz… kind of. then you want to make certain subgroup into a point, because subgroups has the good property of having boundary of coset. but <span class="math">\(aHbH = abH\)</span> will require that <span class="math">\(aH = Ha\)</span> for it</li>
<li>index 2 subgroup is normal, i think this can be shown quickly by cosets</li>
</ul></li>
<li><span id="cross-centralizer" class="crosslink">centralizer</span> of <span class="math">\(S\)</span> <span class="math">\(Z_S\)</span>. <span class="math">\(zsz^{-1} = s\)</span>
<ul>
<li>of <span class="math">\(G\)</span>, <span id="cross-center-of-group" class="crosslink">center of group</span> is a <a href="#cross-normal-subgroup">normal subgroup</a></li>
</ul></li>
<li><span id="cross-quotient-group" class="crosslink">quotient group</span> <span class="math">\(G/H\)</span>. and if <span class="math">\(H\)</span> is normal, the result is also a group</li>
<li><span id="cross-exact-sequence-of-group" class="crosslink">exact sequence of group</span> shape like this: <span class="math">\(&gt;&gt;&gt;&gt;&gt;&gt;\)</span></li>
<li><span><span id="cross-generator"></span><span id="cross-generate" class="crosslink">generate </span></span> <span class="math">\(G = \langle S \rangle\)</span> seems to be the inner structure of a group
<ul>
<li><span id="cross-finitely-generated" class="crosslink">finitely generated</span></li>
<li><span id="cross-transposition" class="crosslink">transposition</span> generate <a href="#cross-symmetric-group">symmetric group</a> <span class="math">\(S_n\)</span></li>
</ul></li>
<li><span id="cross-free-group" class="crosslink">free group</span> <span class="math">\(F(A)\)</span>. the words thing. on set <span class="math">\(A\)</span>. the <a href="#cross-universal-arrow">universal arrow</a>!</li>
<li><a href="#cross-product">product</a> exists. we show that the product is a group by defining pointwize multiplication, then we define the universal arrow. we show that it is a morphism and it is a product, then we show that it is unique
<ul>
<li>canonical embedding into the product</li>
</ul></li>
<li><a href="#cross-coproduct">coproduct</a>. the <span id="cross-free-product" class="crosslink">free product</span> <span class="math">\(G*H\)</span>
<ul>
<li>consider the category of <span class="math">\((f, G)\)</span> such that <span class="math">\(f: S\to G\)</span> with morphisms group homomorphisms <span class="math">\(\lambda\)</span> such that <span class="math">\(\lambda \circ f_1 = f_2\)</span>, a <span id="cross-free-group" class="crosslink">free group</span> is an <a href="#cross-initial">initial</a> in this category</li>
<li><a href="#cross-free-group">free group</a> exists and generated by <span class="math">\(S\)</span>, the <span class="math">\(f\)</span> is injective</li>
<li><span class="math">\(F(|G|)\to G\)</span>, then we see that every group is a factor group of some <a href="#cross-free-group">free group</a></li>
<li>coproduct exists</li>
</ul></li>
<li><a href="#cross-initial">initial</a> and <a href="#cross-finial">finial</a>. the <span id="cross-trivial-group" class="crosslink">trivial group</span></li>
<li><span id="cross-order-of-group" class="crosslink">order of group</span>. the definition is somewhat… it is the number of elements</li>
<li><span id="cross-commutator" class="crosslink">commutator</span> <span class="math">\(xyx^{-1}y^{-1}\)</span>, <span class="math">\(G^c\)</span>
<ul>
<li>normal, proof by blablabla</li>
<li><span class="math">\(G/G^c\)</span> is commutative, proof by cosets</li>
<li>all homomorphism into commutative group factor through it, proof by showing that if it maps into an abelian group, then the kernel is contained in it. then using <a href="#cross-decomposition-1">decomposition 1</a></li>
</ul></li>
<li><span id="cross-simple-group" class="crosslink">simple group</span>. nor-trivial and no normal groups other than <span class="math">\({e}\)</span> and itself</li>
<li><span id="cross-presentation-of-group" class="crosslink">presentation of group</span>
<ul>
<li><span id="cross-finitely-presented" class="crosslink">finitely presented</span>
<ul>
<li>world problem is undecidable…</li>
</ul></li>
</ul></li>
<li><span id="cross-inverse-limit" class="crosslink">inverse limit</span> given <span class="math">\(\{(G_n, f_n)\}\)</span>, the sequences <span class="math">\(x = (x_0, x_1, \dots)\)</span> that satisfy <span class="math">\(x_0 = f_1(x_1)\)</span> etc, form a group <code>fix me: i think this part is non-essential, though interesting, i should read it in a more strong background</code></li>
<li>examples
<ul>
<li><span id="cross-symmetric-group" class="crosslink">symmetric group</span> <span class="math">\(S_n\)</span>
<ul>
<li><span class="math">\((S_n:1) = n!\)</span></li>
<li><code>fix me? the section in Lang is not read</code></li>
</ul></li>
<li><span id="cross-cyclic-group" class="crosslink">cyclic group</span> <span class="math">\(C_n\)</span>. <a href="#cross-isomorphism">isomorphism</a> to <span class="math">\({\mathbb{Z}}\)</span> or <span class="math">\({\mathbb{Z}}/n{\mathbb{Z}}\)</span>, the <strong>additive group</strong>!!!
<ul>
<li>infinite cyclic group has exactly 2 generator</li>
<li>finite cyclic group has generators the relative prime ones
<ul>
<li>let <span class="math">\(p\)</span> relative prime, and <span class="math">\(k\)</span> smallest such that <span class="math">\((a^p)^k = e \Rightarrow (a^k)^p = e\)</span> we show that k must be order of the group, because we do not have such kind of subgroup. if it is not relative prime, we show that it cannot generate</li>
</ul></li>
<li>the automorphisms is fully described by map on generator
<ul>
<li>trivial</li>
</ul></li>
<li>if <span class="math">\(p\)</span> is prime, then <span class="math">\(({\mathbb{Z}}/p{\mathbb{Z}}, \cdot)\)</span> is cyclic <code>fix me</code></li>
<li>also <span class="math">\(({\mathbb{Z}}/p{\mathbb{Z}})^*\)</span> is cyclic <code>fix me</code></li>
<li>and if <span class="math">\(\text{gcd}(m, n) = 1\)</span> <span class="math">\(C_{mn} = C_m \times C_n\)</span>
<ul>
<li>to show right is cyclic, we define <span class="math">\(C_{mn}\to C_m\times C_n\)</span>, we show that only that… and we show that it is surjective. we are done??</li>
</ul></li>
<li>a non cyclic finite abelian group must contain some <span class="math">\(C_p\times C_p\)</span> <code>fix me</code></li>
</ul></li>
<li><span id="cross-dihedral-group" class="crosslink">dihedral group</span> of <span class="math">\(n\)</span> side polygon <span class="math">\(D_{2n}\)</span>
<ul>
<li><span class="math">\(D_6 = S_3\)</span>, but normality it is not, because geometry restrictions</li>
</ul></li>
<li><span class="math">\(D_8 = {\langle \sigma, \alpha| \sigma^4 = \alpha^2 = e, \sigma\alpha\sigma^{-1} = \sigma^3 \rangle}\)</span></li>
<li><span id="cross-quaternion-group" class="crosslink">quaternion group</span> <code>fix me</code></li>
</ul></li>
<li>remark
<ul>
<li>when dealing with finite group, it is just ok to think of what multi table it have</li>
</ul></li>
</ul></li>
<li><span id="cross-decomposition-of-group-morphism" class="crosslink">decomposition of group morphism</span>
<ul>
<li><img src="images/group-d1.png" style="width:400px" />
<ul>
<li>we define the map by <span class="math">\(aH\to f(a)\)</span> because for all <span class="math">\(y\in H\)</span>, <span class="math">\(f(xy) = f(x)\)</span> we see it is a well defined map, then we see that it is a morphism, and it is unique</li>
</ul></li>
<li><span id="cross-decomposition-1" class="crosslink">decomposition 1</span> <span class="math">\(\frac{G_1\times G_2}{H_1\times H_2}\cong\frac{G_1}{H_1}\times\frac{G_2}{H_2}\)</span>
<ul>
<li>first we proof that <span class="math">\(H_1\times H_2\)</span> is normal, this is trivial, then we show that if <span class="math">\(g_i H_1\)</span> and <span class="math">\(g_j H_2\)</span> then <span class="math">\((g_i, g_j) H_1\times H_2\)</span>, we define the map and show it is a morphism, then we show the kernel is trivial and it is surjective, so it is an isomorphism</li>
</ul></li>
<li><span id="cross-decomposition-2" class="crosslink">decomposition 2</span> <span class="math">\(\frac{G/H}{N/H}\cong\frac{G}{N}\)</span>, <span class="math">\(H\subset N\)</span> normal
<ul>
<li>first all <span class="math">\(A/B\)</span> is well defined, then we see that left is well defined. for <span class="math">\(G/H\)</span> and <span class="math">\(G/N\)</span> we define a map <span class="math">\(gH\to gN\)</span>, we see that it is a morphism, then we show that the kernel is <span class="math">\(N/H\)</span></li>
</ul></li>
<li><span class="math">\(\frac{H}{H\cap K}\cong \frac{HK}{K}\)</span>, <span class="math">\(H\subset N_K\)</span>, so <span class="math">\(HK = KH\)</span> is subgroup, and <span class="math">\(H\cap K\)</span> is normal in <span class="math">\(H\)</span>
<ul>
<li>proof that <span class="math">\(H\cap K\)</span> is normal in <span class="math">\(H\)</span>, <span class="math">\(hk = k_2 h\)</span> and <span class="math">\(k \in H\)</span> so <span class="math">\(k_2 \in H\)</span> so normal. we define the map <span class="math">\(h\to hK\)</span>, then we show that it is morphism and it’s kernel is <span class="math">\(H\cap K\)</span></li>
<li>this means you have normalizer, you can add/subtract the irrelevant dims to the problem. notice that <span class="math">\(K\)</span> is not always subgroup of <span class="math">\(H\)</span></li>
</ul></li>
<li><span id="cross-butterfly-lemma" class="crosslink">butterfly lemma</span>
<ul>
<li><span class="math">\(U\)</span>, <span class="math">\(V\)</span> subgroup of <span class="math">\(G\)</span></li>
<li><span class="math">\(u\)</span>, <span class="math">\(v\)</span> normal subgroup of <span class="math">\(U\)</span>, <span class="math">\(V\)</span></li>
<li><span class="math">\(\frac{u(U\cap V)}{u(U\cap v)}\cong\frac{(U\cap V)v}{(u\cap V)v}\cong\frac{U\cap V}{(u\cap V)(U\cap v)}\)</span></li>
<li><code>fix me</code></li>
</ul></li>
</ul></li>
<li><span id="cross-group-towers" class="crosslink">group towers</span>
<ul>
<li><span id="cross-normal-tower" class="crosslink">normal tower</span>, <span id="cross-abelian-tower" class="crosslink">abelian tower</span>, <span id="cross-cyclic-tower" class="crosslink">cyclic tower</span></li>
<li><span id="cross-solvable-tower" class="crosslink">solvable tower</span>. has an abelian tower</li>
<li>finite + solvable = has an cyclic refinement
<ul>
<li>by induction and using <a href="#cross-decomposition-2">decomposition 2</a></li>
</ul></li>
<li><span class="math">\(H\)</span> normal (<span class="math">\(G\)</span> solvable <span class="math">\(\Leftrightarrow\)</span> <span class="math">\(G/H\)</span> and <span class="math">\(H\)</span> is solvable)
<ul>
<li>right to left is trivial. <span class="math">\(H\)</span> solvable: construct <span class="math">\(H_i\)</span> like in textbook, we show a normal tower, then we show a morphism, then we show injective then we show abelian. and then we show that <span class="math">\(G/H\)</span> is solvable. we show that <span class="math">\(G_{i+1}H\)</span> normal in <span class="math">\(G_i H\)</span>, by <span class="math">\(hg_iG_{i+1}H g_i^{-1}h^{-1}  = hG_{i+1} H h^{-1} = hG_{i+1}H = h H G_{i+1} = G_{i+1} H\)</span>, then we show that <span class="math">\(G_i H/ G_{i+1}H\to G_i/G_{i+1}\)</span> is injective, 1. show that cosets in left is just <span class="math">\(g_ihHG_{i+1} = g_iG_{i+1}H\)</span> represented by <span class="math">\(g_i\)</span>, 2. define the map be <span class="math">\(g_i G_{i+1} H \to g_i G_{i+1}\)</span>, then it is morphism, and it is injective, 3. using <a href="#cross-decomposition-1">decomposition 1</a>, we show that it isomorphism to a tower of <span class="math">\(G_i H/ H\)</span> with <span class="math">\(G_0H/H = G/H\)</span> and <span class="math">\(G_rH/H = H/H\)</span>, so proofed</li>
<li>lemma: <span class="math">\(h(H\cap G) = H\cap hG\)</span>. it is used to show above injective</li>
</ul></li>
<li><span id="cross-Schreier-theorem" class="crosslink">Schreier theorem</span> two normal tower ending with trivial group have equivalent refinements <code>fix me</code></li>
<li><span id="cross-Jordan-H\246lder" class="crosslink">Jordan-H\246lder</span> <code>fix me</code></li>
</ul></li>
<li><span id="cross-finite-group" class="crosslink">finite group</span> methods <code>fix me</code> prove them!
<ul>
<li><span class="math">\(p\)</span>-group. finite group of order <span class="math">\(p^n\)</span> where <span class="math">\(p\)</span> prime</li>
<li><span class="math">\(p\)</span>-<span id="cross-Sylow-subgroup" class="crosslink">Sylow subgroup</span></li>
<li>finite abelian group <span class="math">\(G\)</span> has subgroup order <span class="math">\(p\)</span> dividing <span class="math">\(|G|\)</span> <code>fix me: i should come up with a better proof</code></li>
<li><span class="math">\(p\)</span>-Sylow group exists</li>
<li><span class="math">\(H\)</span> a <span class="math">\(p\)</span> group actioning on finite set <span class="math">\(S\)</span>, then number of fix points is <span class="math">\(|S|\)</span> mod <span class="math">\(p\)</span></li>
<li><span class="math">\(p\)</span> group is contained in some <span class="math">\(p\)</span>-Sylow group</li>
<li>all <span class="math">\(p\)</span>-Sylow group is <a href="#cross-conjugate">conjugate</a></li>
<li>number of <span class="math">\(p\)</span>-Sylow group is 1 mod <span class="math">\(p\)</span></li>
<li><span class="math">\(p\)</span>-group is solvable and has non-trivial center
<ul>
<li>it has cyclic tower</li>
</ul></li>
<li>smallest prime group is normal</li>
<li>order <span class="math">\(pq\)</span>, <span class="math">\(p\neq q\)</span> and primes, then solvable</li>
</ul></li>
</ul>
<ul>
<li><span id="cross-abelian-group" class="crosslink">abelian group</span> <span class="math">\({\mathcal{Ab}}\)</span>
<ul>
<li><a href="#cross-object">object</a>. <a href="#cross-commutative">commutative</a> . <a href="#cross-group">group</a></li>
<li><a href="#cross-morphism">morphism</a>
<ul>
<li>example: <span class="math">\(n\)</span> power map exists, because <a href="#cross-commutative">commutative</a>, the deeper result is that abelian group is essentially an module over <span class="math">\({\mathbb{Z}}\)</span></li>
<li><a href="#cross-homomorphism">homomorphism</a> in <span class="math">\({\mathcal{Ab}}\)</span> is again a <a href="#cross-abelian-group">abelian group</a></li>
</ul></li>
<li><a href="#cross-product">product</a>. finite case is <a href="#cross-direct-sum">direct sum</a></li>
<li><a href="#cross-coproduct">coproduct</a>. <span id="cross-direct-sum" class="crosslink">direct sum</span> <span class="math">\(G\oplus H\)</span>, only finite non zero
<ul>
<li>proof that is is coproduct. we should be using a infinite sum now, and etc.</li>
</ul></li>
<li><a href="#cross-pullback">pullback</a>. is the subgroup of <span class="math">\(A\times B\)</span> such that <span class="math">\(f(a) = g(b)\)</span></li>
<li>structure of <span id="cross-free-abelian-group" class="crosslink">free abelian group</span> <span class="math">\(F^{ab}(A)\)</span>. <span class="math">\(\bigoplus_{i\in A} {\mathbb{Z}}_i\)</span>
<ul>
<li><span id="cross-base" class="crosslink">base</span> non-empty and <span class="math">\(A\)</span> is unique expressed <span class="math">\(x =\sum x_i e_i\)</span> for <span class="math">\(x_i\in {\mathbb{Z}}\)</span> almost all zero</li>
<li>the <a href="#cross-adjunction">adjunction</a></li>
<li><span class="math">\(f:A\to B\)</span> surjective and <span class="math">\(B\)</span> is free, then we can find <span class="math">\(C\)</span> free such that <span class="math">\(A = {\text{Ker }}f \oplus C\)</span>
<ul>
<li>proof using base</li>
</ul></li>
<li>subgroup is also <a href="#cross-free-abelian-group">free abelian group</a>, and has smaller <a href="#cross-cardinal">cardinal</a> base
<ul>
<li>when the space is finitely generated, <code>fix me</code></li>
</ul></li>
</ul></li>
<li>structure of <span id="cross-torsion-element" class="crosslink">torsion element</span> forms a <span id="cross-torsion-group" class="crosslink">torsion group</span>. <span class="math">\(A = \bigoplus _p A(p)\)</span> where <span class="math">\(A(p)\)</span> is the subgroup of elements of order <span class="math">\(p^n\)</span>. not necessary finite
<ul>
<li>we proof by showing the map in surjective, injective by showing the kernel is trivial. surjective using the relative prime decomposition</li>
<li>abelian <span class="math">\(p\)</span>-group.isomorphism to product of cyclic <span class="math">\(p\)</span>-groups
<ul>
<li><code>fix me</code></li>
</ul></li>
</ul></li>
<li><span id="cross-finitely-generated-abelian-group" class="crosslink">finitely generated abelian group</span> <span class="math">\(A = A_{\text{tor}}\oplus B\)</span> where <span class="math">\(B\)</span> is free
<ul>
<li>freely generated torsion abelian group is finite
<ul>
<li>proof is trivial</li>
</ul></li>
<li>freely generated torsion-free abelian group is free
<ul>
<li><code>fix me</code></li>
</ul></li>
<li><code>fix me</code></li>
<li><span id="cross-rank" class="crosslink">rank</span> of <span class="math">\(A\)</span></li>
</ul></li>
<li><span id="cross-dual-group" class="crosslink">dual group</span>. for <span class="math">\(A\)</span> of exponent <span class="math">\(m\)</span>, <span class="math">\(A^*\)</span>
<ul>
<li>for <span class="math">\(A\)</span>, <span class="math">\(B\)</span> of same exponent <span class="math">\(m\)</span>, <span class="math">\(f: A\to B\)</span>, we define <span class="math">\(f^*:B^*\to A^*\)</span> by <span class="math">\(f^*(\chi) = \chi \circ f\)</span></li>
<li><span class="math">\({\text{id}}^* = {\text{id}}\)</span></li>
<li><span class="math">\((f\circ g)^* = g^*\circ f^*\)</span></li>
<li><span class="math">\((A\times B)^* \cong A^*\times B^*\)</span></li>
<li><code>fix me: is dual group only in finite case? is this part essential? should i finish this part?</code></li>
</ul></li>
</ul></li>
</ul>
<h3 id="group-action">group action</h3>
<ul>
<li>a left <span id="cross-action" class="crosslink">action</span> of <a href="#cross-group">group</a> <span class="math">\(G\)</span> on <span class="math">\(A\)</span> in category <span class="math">\({\mathcal{C}}\)</span>, is a <strong>morphism</strong> <span class="math">\(\sigma:G \to {\text{Aut}}_{\mathcal{C}}(A)\)</span>
<ul>
<li>alternative on <span class="math">\(S\in {\mathcal{Set}}\)</span>
<ul>
<li><span class="math">\(es = s\)</span></li>
<li><span class="math">\(gfs = (gf) s\)</span></li>
<li>this is auto <a href="#cross-automorphism">automorphism</a>! group has <a href="#cross-inverse">inverse</a>!</li>
</ul></li>
<li><span><span id="cross-effective-action"></span><span id="cross-faithful-action" class="crosslink">faithful action </span></span> when we view group as an single element <a href="#cross-category">category</a>, it is just <a href="#cross-faithful">faithful</a></li>
<li><span id="cross-conjugate" class="crosslink">conjugate</span> subgroup <span class="math">\(B = xAx^{-1}\)</span>
<ul>
<li>the kernel this map is <a href="#cross-center">center</a></li>
<li>there are a lot of automorphism that is not working by conjugation!!</li>
</ul></li>
<li><span><span id="cross-stabilizer"></span><span id="cross-isotropy" class="crosslink">isotropy </span></span> of point <span class="math">\(s\)</span>, <span class="math">\(G_s\)</span>. <span class="math">\(\{g|gs = s\}\)</span>
<ul>
<li>isotropy groups is <a href="#cross-conjugate">conjugate</a> if <span class="math">\(\exists gs = s'\)</span></li>
<li>so <a href="#cross-faithful-action">faithful action</a>’s <a href="#cross-isotropy">isotropy</a> is always <span class="math">\(\{e\}\)</span></li>
</ul></li>
<li><span id="cross-orbit" class="crosslink">orbit</span> of <span class="math">\(s\)</span>, <span class="math">\(Gs\)</span></li>
<li><span><span id="cross-transitive"></span><span id="cross-transitively"></span><span id="cross-transitive-action" class="crosslink">transitive action </span></span>, <span class="math">\(\forall s, s', \exists g: gs = s'\)</span> or group is single <a href="#cross-orbit">orbit</a>
<ul>
<li>if <span class="math">\(H\)</span> is subgroup, then <span class="math">\(G/H\)</span> is <a href="#cross-transitive">transitive</a> <span class="math">\(G\)</span>-set (by <span class="math">\(G\)</span>-set we means an action)</li>
</ul></li>
</ul></li>
<li><span class="math">\(|Gs| = (G:G_s)\)</span>
<ul>
<li>number of <a href="#cross-conjugate">conjugate</a> group of <span class="math">\(H\)</span> is equal to <span class="math">\(G:N_H\)</span></li>
<li><span id="cross-orbit-decomposition-formula" class="crosslink">orbit decomposition formula</span> <span class="math">\(S = \bigcup Gs_i\)</span> then <span class="math">\(|S| = \sum_{i\in I} (G:G_{s_i})\)</span>, <span class="math">\(s_i\)</span> is representative of different orbit</li>
<li><span id="cross-class-formula" class="crosslink">class formula</span> <span class="math">\((G:1) = \sum (G:G_x)\)</span>, taken from different conjugate classes. consider <span class="math">\(G\)</span> action by <a href="#cross-conjugate">conjugate</a> on <span class="math">\(G\)</span> viewing as an set, then… for example, when <span class="math">\(z\)</span> is in center, <span class="math">\(G_x = G\)</span> because all <span class="math">\(xzx^{-1} = z\)</span>, and it’s orbit is just <span class="math">\(z\)</span></li>
</ul></li>
<li><a href="#cross-category">category</a> of <span class="math">\(G\)</span> sets
<ul>
<li><a href="#cross-object">object</a>. <span class="math">\(S\)</span></li>
<li><a href="#cross-morphism">morphism</a>. <a href="#cross-function">function</a> <span class="math">\(f\)</span> such that <span class="math">\(f(gx) = g(f(x))\)</span>
<ul>
<li><a href="#cross-automorphism">automorphism</a> of <span class="math">\(G\)</span>-set. <span class="math">\(G\)</span> act <a href="#cross-transitively">transitively</a> on <span class="math">\(S\)</span>, <span class="math">\(s\in S\)</span>, <span class="math">\(W_{G_s}\)</span> is <a href="#cross-isomorphic">isomorphic</a> to <span class="math">\({\text{Aut}}_G(S)\)</span> of <a href="#cross-automorphism">automorphism</a> of <span class="math">\(G\)</span>-set <span class="math">\(S\)</span></li>
</ul></li>
</ul></li>
<li><a href="#cross-category">category</a> <span class="math">\(\mathcal{O}(G)\)</span> of canonical orbits <code>fix me: reread this para in May</code>
<ul>
<li><a href="#cross-object">object</a>. <span class="math">\(G/H\)</span></li>
<li><a href="#cross-morphism">morphism</a>. <span class="math">\(G\)</span>-maps of them
<ul>
<li><span class="math">\(\alpha: G/H\to G/K\)</span> has form <span class="math">\(\alpha(gH) = g\gamma K\)</span> where <span class="math">\(\gamma\in G\)</span> satisfies <span class="math">\(\gamma^{-1}h\gamma \in K\)</span> for all <span class="math">\(h\in H\)</span></li>
<li>the category <span class="math">\(\mathcal{O}(G)\)</span> is isomorphism to <span class="math">\(\mathcal{G}\)</span> with objects subgroups of <span class="math">\(G\)</span> and morphisms distinct subconjugacy relations <span class="math">\(\gamma^{-1}H\gamma\subset G\)</span> for <span class="math">\(\gamma\in G\)</span></li>
</ul></li>
</ul></li>
<li><span id="cross-groupoid-action" class="crosslink">groupoid action</span> <span class="math">\(T:\mathcal{B} \to \mathcal{Set}\)</span>. it is kind of taking the results of path in base space into results of end point in covering space
<ul>
<li>for each <span class="math">\(b\)</span> in <span class="math">\(\mathcal{B}\)</span>, <span class="math">\(T\)</span> restricts to an <a href="#cross-group-action">group action</a> on <span class="math">\(T(b)\)</span></li>
<li><span id="cross-transitive-groupoid-action" class="crosslink">transitive groupoid action</span>. if for each <span class="math">\(b\)</span>, it is an <a href="#cross-transitive-action">transitive action</a>
<ul>
<li>for <a href="#cross-groupoid-connected">groupoid connected</a> groupoid, if this is true for one, then true for all. because groupoid is an category with only <a href="#cross-isomorphism">isomorphism</a></li>
</ul></li>
</ul></li>
</ul>
<h2 id="chapter-01-exercises">chapter 01 EXERCISES</h2>
<ol style="list-style-type: decimal">
<li><p>show that every grouop of order &lt;= 5 is abelian</p>
<p>p-group is solvable and has non-trival center</p></li>
<li><p>trivial</p></li>
<li><p>trivial</p></li>
<li><p>trivial</p></li>
<li><p>proof a iso?</p></li>
<li><p>trivial</p></li>
<li><p>turn <code>a</code> into <code>b</code> in <code>aba^-1=b</code></p></li>
<li><p><strong>fix me</strong></p></li>
<li><p>if group has finite index subgroup, then there is finite index normal subgroup &amp;&amp; finite index intersection is finite index</p>
<p><strong>fix me</strong></p></li>
<li><p>right coset number is equal to left coset</p>
<p>inverse!!!</p></li>
<li><p><strong>fix me</strong></p></li>
</ol>
<p><strong>fix me</strong></p>
<h3 id="ring">ring</h3>
<ul>
<li><span id="cross-ring" class="crosslink">ring</span> <span class="math">\({\mathcal{Ring}}\)</span>
<ul>
<li><a href="#cross-object">object</a>
<ul>
<li><a href="#cross-abelian-group">abelian group</a> on <span class="math">\(+\)</span></li>
<li><a href="#cross-monoid">monoid</a> <span class="math">\(\cdot\)</span></li>
<li><span id="cross-distributive" class="crosslink">distributive</span> <span class="math">\((r+s)t = rt + st\)</span></li>
</ul></li>
<li>properties
<ul>
<li><span class="math">\(0r = r0 = 0\)</span></li>
<li>there are many things without <span class="math">\(1\)</span>, for example <span class="math">\(2{\mathbb{Z}}\)</span></li>
<li>zero ring</li>
<li><a href="#cross-commutative">commutative</a> ring</li>
<li><span id="cross-left-unit-of-ring" class="crosslink">left unit of ring</span>, <span id="cross-right-unit-of-ring" class="crosslink">right unit of ring</span>, <span id="cross-unit-of-ring" class="crosslink">unit of ring</span> <span class="math">\(A^*\)</span>, invertible elements of <span class="math">\(A\)</span>
<ul>
<li><a href="#cross-left-unit-of-ring">left unit of ring</a> is not <a href="#cross-right-zero-divisor">right zero divisor</a></li>
<li><a href="#cross-left-unit-of-ring">left unit of ring</a> is not always unique, but <a href="#cross-unit-of-ring">unit of ring</a> is unique</li>
<li><span id="cross-shift-operator" class="crosslink">shift operator</span>. bad example~!</li>
</ul></li>
<li><span id="cross-division-ring" class="crosslink">division ring</span> <span class="math">\(1\neq 0\)</span> and ever element invertible</li>
<li><span id="cross-field" class="crosslink">field</span>. <a href="#cross-commutative">commutative</a> . <a href="#cross-division-ring">division ring</a></li>
<li><span><span id="cross-zero-divisor"></span><span id="cross-left-zero-divisor" class="crosslink">left zero divisor </span></span> <span class="math">\(a\)</span> such <span class="math">\(ab = 0\)</span>, <span id="cross-right-zero-divisor" class="crosslink">right zero divisor</span>
<ul>
<li><span class="math">\([2][3] = [0]\)</span></li>
<li><span class="math">\(\Leftrightarrow\)</span> multiplication is <a href="#cross-injective">injective</a></li>
</ul></li>
<li><span><span id="cross-entire-ring"></span><span id="cross-integral-domain" class="crosslink">integral domain </span></span> nonzero <a href="#cross-commutative">commutative</a> ring without <a href="#cross-zero-divisor">zero divisor</a></li>
<li>finite <a href="#cross-commutative">commutative</a> ring <a href="#cross-integral-domain">integral domain</a> = <a href="#cross-field">field</a>. i.e. finite <a href="#cross-integral-domain">integral domain</a> every element is an <a href="#cross-unit-of-ring">unit of ring</a></li>
<li><span id="cross-nilpotent" class="crosslink">nilpotent</span> <span class="math">\(a^n = 0\)</span></li>
</ul></li>
<li><a href="#cross-morphism">morphism</a>. <span class="math">\(f(a + b) = f(a) + f(b)\)</span>, <span class="math">\(f(ab) = f(a)f(b)\)</span>, <span class="math">\(f(1) = 1\)</span>
<ul>
<li><a href="#cross-monomorphism">monomorphism</a>
<ul>
<li><span class="math">\(\Leftrightarrow\)</span> <span class="math">\({\text{Ker }}f = \{0\}\)</span></li>
<li><a href="#cross-injective">injective</a></li>
</ul></li>
<li><a href="#cross-epimorphism">epimorphism</a> is not necessary <a href="#cross-surjective">surjective</a>
<ul>
<li>so <a href="#cross-monomorphism">monomorphism</a> and <a href="#cross-epimorphism">epimorphism</a> is not necessary <a href="#cross-isomorphism">isomorphism</a></li>
</ul></li>
<li><span class="math">\(\lambda: R\to {\text{End}}_{{\mathcal{Ab}}}(R)\)</span>, is injective ring homomorphism</li>
</ul></li>
<li><a href="#cross-initial">initial</a>. <span class="math">\({\mathbb{Z}}\)</span>
<ul>
<li><span id="cross-characteristic-of-ring" class="crosslink">characteristic of ring</span></li>
</ul></li>
<li><a href="#cross-subring">subring</a></li>
<li><a href="#cross-product">product</a></li>
<li><a href="#cross-coproduct">coproduct</a></li>
<li><span id="cross-left-ideal" class="crosslink">left ideal</span>, <span id="cross-right-ideal" class="crosslink">right ideal</span>, <span id="cross-ideal" class="crosslink">ideal</span>
<ul>
<li><em>ideal is submodule of the ring</em></li>
<li><span id="cross-principal-ideal" class="crosslink">principal ideal</span></li>
<li><span id="cross-generators-for-ideal" class="crosslink">generators for ideal</span>
<ul>
<li><span class="math">\(IJ\)</span> generated by products of them!!!</li>
<li><span class="math">\((4)\cap (3) = (12) = (4)\cdot (3)\)</span></li>
<li><span class="math">\((4)\cap (6) = (12) \neq (24) = (4) \cdot (6)\)</span></li>
</ul></li>
<li><a href="#cross-intersection">intersection</a> closed</li>
</ul></li>
<li><span id="cross-quotient-ring" class="crosslink">quotient ring</span></li>
<li><img src="images/ring-decom.png" style="width:400px" /></li>
<li><span class="math">\(\frac{R/I}{J/I} = \frac{R}{J}\)</span></li>
<li><a href="#cross-commutative">commutative</a> ring is <span id="cross-Noetherian" class="crosslink">Noetherian</span> if every ideal is finitely generated</li>
<li><span><span id="cross-pid"></span><span id="cross-principal-integral-domain" class="crosslink">principal integral domain </span></span>. <a href="#cross-integral-domain">integral domain</a> and every ideal is <a href="#cross-principal-ideal">principal ideal</a>
<ul>
<li>is <a href="#cross-Noetherian">Noetherian</a></li>
<li><span class="math">\({\mathbb{Z}}\)</span> is <a href="#cross-pid">pid</a></li>
</ul></li>
<li>for <a href="#cross-commutative">commutative</a> ring
<ul>
<li><span id="cross-prime-ideal" class="crosslink">prime ideal</span> <span class="math">\(R/I\)</span> is <a href="#cross-integral-domain">integral domain</a></li>
<li><span id="cross-maximal-ideal" class="crosslink">maximal ideal</span> <span class="math">\(I \neq R\)</span> and not contained in any ideal
<ul>
<li><span class="math">\(R/I\)</span> is a <a href="#cross-field">field</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="module">module</h3>
<ul>
<li><span id="cross-module" class="crosslink">module</span> <span class="math">\(R-\mathcal{Mod}\)</span>
<ul>
<li>remark
<ul>
<li>module makes <span class="math">\(R\)</span>, <span class="math">\(I\)</span>, <span class="math">\(R\I\)</span> all modules</li>
<li>it is an example of good category</li>
<li>abelian group is a special case</li>
</ul></li>
<li><a href="#cross-object">object</a>
<ul>
<li><a href="#cross-abelian-group">abelian group</a> and <a href="#cross-ring">ring</a></li>
<li><span class="math">\(r(m + n) = rm + rn\)</span></li>
<li><span class="math">\((r + s) m = rm + sm\)</span></li>
<li>(rs)m = r(sm)$</li>
<li><span class="math">\(1m = m\)</span></li>
</ul></li>
<li><a href="#cross-morphism">morphism</a>
<ul>
<li><span class="math">\(f(m + n) = f(m) + f(n)\)</span></li>
<li><span class="math">\(f(rm) = rf(m)\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="vector-space">vector space</h3>
<ul>
<li><span id="cross-vector-space" class="crosslink">vector space</span>. <a href="#cross-module">module</a> over a <a href="#cross-field">field</a> ### p034 - 36</li>
</ul>
<h2 id="chapter-02">chapter 02</h2>
<h3 id="p083---92">p083 - 92</h3>
<p>ring - abelian group of plus and monoid multiplication and <code>(x + y)z = xz + yz</code></p>
<ul>
<li>think distributivity kind of weeken linearization*</li>
</ul>
<p><code>U</code> the set of elements who has right and left inverse is a group, group of units in <code>A</code></p>
<p>division ring</p>
<ul>
<li>it must be two sided, think them as functions, and think of shift operator</li>
</ul>
<p>commutative ring</p>
<p>commutative &amp;&amp; division ring = field</p>
<p>subring = subgroup of additive group &amp;&amp; submonid of multi</p>
<ul>
<li>it seems that finding subring is harder than finding sub group, one should use distributive law to find them</li>
<li>center is subring</li>
<li>example</li>
<li><code>Z</code></li>
<li>addtive group endormors is a ring of add and compo</li>
<li><code>Map(S,A)</code> into ring <code>A</code></li>
<li>matrix</li>
<li>polynomials</li>
<li>convolution product of a group ring</li>
<li><code>(f*g)(z) = Sum(f(x)g(y) | xy = z)</code></li>
</ul>
<p>left ideal: subgroup of additive group &amp;&amp; <code>Aa = a</code></p>
<p>right ideal</p>
<p>ideal</p>
<ul>
<li><code>Aa</code> is left ideal. called principal</li>
<li>also <code>A(a, b, c)</code> etc. generator of the left ideal</li>
</ul>
<p>intersection of ideal is ideal. also for left ideal</p>
<ul>
<li>commutative ring left ideal = ideal</li>
</ul>
<p>principal ring = commutative &amp;&amp; every ideal is principal</p>
<ul>
<li>the ring that every ideal is single generated?</li>
</ul>
<p>ideals</p>
<ul>
<li>is a multiplicative monoid, the unit is <code>A</code> is unit ideal, <code>(1)</code>, also for left ideals</li>
<li>is addtive monoid</li>
<li>but is not a ring!</li>
<li>left ideal <code>a</code> =&gt; <code>aA</code> is ideal</li>
<li>for two ideal, <code>ab &lt; a^b</code></li>
</ul>
<p>ring-homormor, kernel = additive kernel</p>
<ul>
<li>the kernel is ideal - it is maped to zero the repeller!!</li>
</ul>
<p>and we have factor ring and canonical map, and it is universal</p>
<p>prime ideal</p>
<ul>
<li><code>ab</code> in <code>P</code> then <code>a</code> or <code>b</code> in <code>P</code></li>
<li><code>P != R</code></li>
</ul>
<p>a useful sport: map from <code>Z</code> to <code>A</code> by <code>ne</code></p>
<ul>
<li>the kernel is an ideal of <code>Z</code>: <code>(n)</code></li>
<li>we have a injective homomor <code>Z/nZ -&gt; A</code></li>
<li>if <code>n</code> prime, <code>n</code> match</li>
<li>case <code>0</code>: <code>A</code> characteristic <code>0</code>, it has subring <code>Z</code></li>
<li>case <code>n</code> prime: <code>A</code> characteristic <code>p</code>, contains substring <code>Z/pZ = F_p</code></li>
<li>if in field <code>K</code>, it contains <code>Q</code> or <code>F_p</code>. they are called prime field in <code>K</code></li>
<li>by prime ring in <code>K</code> we means <code>Z</code> or <code>F_p</code></li>
</ul>
<p>let <code>A</code> a subring of <code>B</code> and <code>S</code> a subset of <code>B</code> that commuting with <code>A</code> then we have <code>A[S] = {a s s s s}</code>. if <code>B = A[S]</code> we say that <code>B</code> is generated by <code>S</code> over <code>A</code>. if <code>S</code> is finite, then finite generated.</p>
<ul>
<li>one might say that <code>A[S]</code> consists all not-necessory commutative polynomials in elements of <code>S</code> with coeffients in <code>A</code></li>
<li>elements of <code>S</code> may not commute!!</li>
<li>example: matrices, when <code>A</code> is <code>nI</code></li>
<li>homomorphism is determined by its effect on generators</li>
</ul>
<p>residue class ring, residue class modulo <code>a</code>, <code>x === y (mod a)</code></p>
<p>induced homomor by ideal in <code>A'</code>, product exists in <code>Ring</code></p>
<p>zero divisors: <code>x != 0 &amp;&amp; y != 0 &amp;&amp; xy == 0</code></p>
<p>entire: <code>1 != 0</code> &amp;&amp; commutative &amp;&amp; no zero divisors</p>
<p>theorem: for entire ring, <code>a</code>, <code>b</code> generate same ideal if there is a unit such that <code>b = au</code></p>
<ul>
<li>the bijective proof is injective for normal ring</li>
</ul>
<h3 id="p093-97">p093 － 97</h3>
<p><em>only discuss commutative ring!!!</em></p>
<ul>
<li>prime = <code>p</code> &amp;&amp; <code>A/p</code> entire =~= <code>xy in p =&gt; x in p || y in p</code></li>
<li>maximal ideal: no bigger</li>
<li>maximal =&gt; prime</li>
<li>every ideal is contained in some maximal</li>
<li>field has only 2 ideal</li>
<li><code>m</code> maximal &lt;=&gt; <code>A/m</code> field</li>
<li>homomor <code>f</code>, prime, maximal</li>
<li>example</li>
<li><code>Z</code>: <code>x^(p-1) == 1(mod p)</code> － using</li>
<li>Chinese remainder theorem: <code>a_n</code> be ideals <code>a_i + a_j = A</code>, then for <code>x_n</code> exists <code>x</code>: <code>x == x_i (mod a_i)</code></li>
<li>read the proof</li>
<li><code>a_1^(v_1) + ... = A</code> problem <strong>fix me</strong></li>
<li><code>A/^(a_i) ~=~ *(A/a_i)</code></li>
<li><strong>fix me</strong></li>
</ul>
<h3 id="p098---107">p098 - 107</h3>
<ul>
<li>polynomial over a ring <code>A</code></li>
<li>polynomial function ring homomor <code>ev_b: A[X] -&gt; B</code></li>
<li><code>x</code> is transcendental over <code>A</code></li>
<li><code>f -&gt; gf</code> the reduction map</li>
<li>reduction of <code>f</code> modulo <code>p</code></li>
<li>degree, linear, leading coefficient, constant</li>
<li>assume <code>A</code> commutative</li>
<li><code>deg(fg) = deg f + deg g</code> if <code>a_n</code> and <code>b_m</code> is not zero
<ul>
<li><code>A</code> entire =&gt; <code>A[X]</code> entire</li>
</ul></li>
<li>polynomials in n variables
<ul>
<li>algebraically independent</li>
<li>degree</li>
<li>homogeneous</li>
<li><code>deg(fg) = deg(f) + deg(g)</code></li>
</ul></li>
<li><code>A</code> a commutative ring, <code>G</code> a monoid. group ring or moniod ring - polynomials is special case!</li>
<li>get all <code>G -&gt; A</code> which is almost zero</li>
<li>we get a ring</li>
<li>and eval reduce in the ring <strong>fix me?</strong></li>
</ul>
<h3 id="p108---110">p108 - 110</h3>
<ul>
<li>multiplicative subset: has 1 and closed by *</li>
<li>quotient ring, ring of fraction of <code>A</code> by <code>S</code></li>
<li><code>(a, s) ~ (a', s')  := exists s_1 (s'a-sa') = 0</code></li>
<li>is equiv</li>
<li><code>a/s</code> and <code>S^-1/A</code></li>
<li><code>a/s * a'/s' = aa'/ss'</code></li>
<li><code>a/s + a'/s' = (s'a + sa') / ss'</code></li>
<li>it is a ring</li>
<li><code>A -&gt; S^-1A</code>
<ul>
<li>f(s) is invertable</li>
<li>and the homomor is universal</li>
</ul></li>
<li>if <code>A</code> is entire =&gt; it is injective</li>
<li>examples</li>
<li>quotient field</li>
<li>rational function</li>
<li>defined at b</li>
<li>local ring: commutative and unique maximal ideal</li>
<li><strong>fix me</strong></li>
</ul>
<h3 id="p111---114">p111 - 114</h3>
<ul>
<li>factorial (unique factorization ring)</li>
<li>divides</li>
<li>gcd</li>
<li>order</li>
<li>prime</li>
<li>lcm</li>
<li><strong>fix me</strong></li>
</ul>
<h2 id="chapter-02-exercises">chapter 02 EXERCISES</h2>
<p><strong>fix me</strong></p>
<h2 id="chapter-03">chapter 03</h2>
<h3 id="p117">p117</h3>
<p><em>thinking in vs!</em></p>
<p><em>and by module, it is itself a abelian group first!</em></p>
<ul>
<li><code>M</code> is left module over <code>A</code></li>
<li>abelian group</li>
<li>ops of <code>A</code> on <code>M</code></li>
<li>distributive</li>
<li>examples</li>
<li><code>A</code> is module over itself</li>
<li>commutative group is Z-module</li>
<li>left ideal of <code>A</code> is module over <code>A</code></li>
<li>submodule <code>N</code>: <code>AN &lt; N</code></li>
<li>module over field = vector space</li>
<li>the ring is the field, scalar</li>
<li>linear map over vs is a module</li>
<li>because linear, the <code>a(x+y) = ax + ay</code> is possible</li>
<li><code>A</code> entire, torsion submodule <code>M_tor</code>: <code>ax = 0 &amp;&amp; a != 0</code></li>
<li>factor module</li>
<li>hodule-homomor <code>f: M -&gt; M'</code></li>
<li>over the same ring <code>A</code></li>
<li>additive group homomorphism</li>
<li><code>f(ax) = af(x)</code></li>
<li>also <code>A</code>-homomor or <code>A</code>-linear map</li>
<li>zero homomor</li>
<li>kernel and image is submodule</li>
<li>cokernel <code>M'/Im f</code></li>
<li>the group canonical homos applies equally in module</li>
<li>exact <code>Im f = Ker g</code>: <code>M' -f-&gt; M -g-&gt; M''</code></li>
<li>monomorphism, embedding: <code>0 -&gt; N -u-&gt; M</code></li>
<li>epimorphism: <code>N -u-&gt; M -&gt; 0</code></li>
<li>there are algebras…</li>
<li>no unit</li>
<li>no assco but distributive</li>
<li>bilinear map</li>
<li>A-algebra, module + bilinear map <code>g: E * E -&gt; E</code></li>
<li><strong>fix me</strong></li>
</ul>
<h3 id="p122--">p122 -</h3>
<ul>
<li><code>A</code> a ring, and <code>X</code>, <code>X'</code> be <code>A</code>-modules, <code>Hom_A(X', X)</code> is abelian group</li>
<li>if <code>A</code> is commutative, then <code>Hom_A</code> is <code>A</code>-module, the group action is <code>a(f) -&gt; af</code></li>
<li><code>Hom_A</code> is also a functor, contravariant in first variable. covariant in second</li>
</ul>
<p><strong>fix me!!!</strong> I fear the category things!</p>
<h2 id="chapter-04-polynomials">chapter 04 polynomials</h2>
<h3 id="p174--">p174 -</h3>
<ul>
<li>Euclidean algorithm: <code>f = gq + r</code> if leading coefficient of <code>g</code> is unit</li>
<li>zero of a polynomial</li>
<li><code>k</code> be a field =&gt; <code>k[X]</code> is principal &amp;&amp; factorial</li>
<li>irrducible <code>f in k[X]</code>: degree &gt;= 1 and not a product <code>f = gh &amp;&amp; g, h !in k</code></li>
<li>monic</li>
<li>at most n roots, and <code>X - a</code> divides <code>f</code></li>
</ul>
<p><strong>fix me!!!</strong></p>
<h2 id="chapter-05-algebraic-extensions">chapter 05 algebraic extensions</h2>
<h2 id="references-2">references</h2>
<ul>
<li><span id="cross-ref-algebra-lang" class="crosslink">ref-algebra-lang</span> <em>Algebra</em>, Serge Lang</li>
<li><span id="cross-ref-algebra-0" class="crosslink">ref-algebra-0</span> <em>Abstract Algebra: Chapter 0</em>, Paolo Aluffi
<ul>
<li>it use more category</li>
</ul></li>
</ul>
<h1 id="topological-space">topological space</h1>
<h2 id="idea-3">idea</h2>
<p>it describe what we means by a space, which has a notation of <strong>nearness</strong> of points, which means the point have some <strong>extension</strong>, so infinite extension will destroy it</p>
<h2 id="topological-space-1">topological space</h2>
<ul>
<li><span><span id="cross-space"></span><span id="cross-topological-space" class="crosslink">topological space</span></span> <span class="math">\(\mathcal{U}\)</span>
<ul>
<li><a href="#cross-object">object</a>. topological space
<ul>
<li><a href="#cross-set">set</a>, <span class="math">\(A\)</span></li>
<li><span><span id="cross-topology"></span><span id="cross-open-set" class="crosslink">open set</span></span>s <span class="math">\(\mathcal{T}\)</span>
<ul>
<li><span id="cross-closed-set" class="crosslink">closed set</span></li>
</ul></li>
<li><span class="math">\(\{A, \emptyset\} \subset \mathcal{T}\)</span></li>
<li><span class="math">\(\mathcal{T}\)</span> closed under finite <a href="#cross-intersection">intersection</a> and any <a href="#cross-union">union</a></li>
</ul></li>
<li><a href="#cross-morphism">morphism</a>. <span><span id="cross-continuous"></span><span id="cross-continuous-function" class="crosslink">continuous function</span></span>
<ul>
<li><span id="cross-path" class="crosslink">path</span>. from <a href="#cross-interval">interval</a>
<ul>
<li><span id="cross-loop" class="crosslink">loop</span>
<ul>
<li><span class="math">\(c_x\)</span> constant loop</li>
</ul></li>
<li><span class="math">\(f\cdot g\)</span> the path that…</li>
<li><span class="math">\(f^{-1}\)</span> the path that…</li>
<li>it is not <a href="#cross-groupid">groupid</a>, because the inverse is not <a href="#cross-groupid-inverse">groupid inverse</a>, but that’s true in <a href="#cross-homotopy-space">homotopy space</a></li>
</ul></li>
<li><a href="#cross-monomorphism">monomorphism</a> and <a href="#cross-epimorphism">epimorphism</a> is reduced from <a href="#cross-set">set</a></li>
<li><a href="#cross-isomorphism">isomorphism</a>. <span><span id="cross-homeomorphically"></span><span id="cross-homeomorphism" class="crosslink">homeomorphism </span></span> is not reduced from set!</li>
</ul></li>
<li>related function
<ul>
<li><span id="cross-open-map" class="crosslink">open map</span></li>
<li><span id="cross-closed-map" class="crosslink">closed map</span></li>
</ul></li>
<li><span id="cross-neighborhood" class="crosslink">neighborhood</span></li>
<li><span id="cross-continuous-at-point" class="crosslink">continuous at point</span></li>
<li><span id="cross-subspcae" class="crosslink">subspcae</span>, <span id="cross-relative-topology" class="crosslink">relative topology</span></li>
<li><span id="cross-interior-point" class="crosslink">interior point</span>, <span id="cross-exterior-point" class="crosslink">exterior point</span>, <span id="cross-boundary-point" class="crosslink">boundary point</span>, <span id="cross-adherent-point" class="crosslink">adherent point</span>, <span id="cross-limit-point" class="crosslink">limit point</span>, every neighbor meets <span class="math">\(A -\{b\}\)</span>, <span id="cross-isolated-point" class="crosslink">isolated point</span></li>
<li><span id="cross-interior" class="crosslink">interior</span>, <span id="cross-exterior" class="crosslink">exterior</span>, <span id="cross-boundary" class="crosslink">boundary</span> , <span id="cross-closure" class="crosslink">closure</span>
<ul>
<li><span class="math">\({\text{Cl }}S \cup {\text{Cl }}T = {\text{Cl }}(S \cup T)\)</span></li>
<li><span class="math">\({\text{Cl }}(S\cap T)\subset {\text{Cl }}S\cap {\text{Cl }}T\)</span></li>
<li>there are two kind of method to gain something, and they are commutative, but when talking about lose and gain, they are not!</li>
</ul></li>
<li><span id="cross-dense" class="crosslink">dense</span> <span class="math">\({\text{Cl }}S = X\)</span></li>
<li><span id="cross-base" class="crosslink">base</span>, <span id="cross-subbase" class="crosslink">subbase</span></li>
<li><span id="cross-refinement" class="crosslink">refinement</span>, <span id="cross-finer-topology" class="crosslink">finer topology</span>, <span id="cross-coarser-topology" class="crosslink">coarser topology</span></li>
<li><span id="cross-weak-topology" class="crosslink">weak topology</span> by <span class="math">\(f\)</span></li>
<li><a href="#cross-product">product</a>. <a href="#cross-set-product">set product</a> with <a href="#cross-weak-topology">weak topology</a> for projection</li>
<li><a href="#cross-coproduct">coproduct</a>.</li>
</ul></li>
<li><span id="cross-pointed-space" class="crosslink">pointed space</span> <span class="math">\(\mathcal{T}\)</span>
<ul>
<li><a href="#cross-object">object</a>. <a href="#cross-topological-space">topological space</a> like <a href="#cross-pointed-set">pointed set</a></li>
<li><a href="#cross-morphism">morphism</a>. <a href="#cross-continuous">continuous</a> map closed by <a href="#cross-basepoint">basepoint</a></li>
</ul></li>
</ul>
<h2 id="connectedness">connectedness</h2>
<ul>
<li><span><span id="cross-connectedness"></span><span id="cross-connected-space" class="crosslink">connected space </span></span>
<ul>
<li>preserved by morphism</li>
<li>has common point… prop 2.3</li>
<li><span class="math">\(S\)</span> connected <span class="math">\(\Rightarrow\)</span> <span class="math">\(S\subset T\subset {\text{Cl }}S\)</span> connected</li>
<li><a href="#cross-product">product</a> preserve <a href="#cross-connectedness">connectedness</a>
<ul>
<li>actually I can proof by using the product base, and for infinite space, it is easier…</li>
</ul></li>
</ul></li>
<li><span id="cross-path-connected-space" class="crosslink">path connected space</span>. all points connected by path
<ul>
<li>a space is <a href="#cross-connected-space">connected space</a> but not path connected: comb</li>
</ul></li>
<li><span id="cross-arc-connected-space" class="crosslink">arc connected space</span>. all points connected by <a href="#cross-homeomorphism">homeomorphism</a>
<ul>
<li>example of path but not arc. <span class="math">\(0\)</span> and <span class="math">\(0'\)</span> in <span class="math">\({\mathbb{R}}^+\)</span>, from Wikipedia</li>
<li>Hausdorff space they are equal</li>
</ul></li>
<li><span id="cross-locally-path-connected" class="crosslink">locally path connected</span>
<ul>
<li>locally path connected + <a href="#cross-connected">connected</a> <span class="math">\(\Rightarrow\)</span> <a href="#cross-path-connected">path connected</a></li>
<li>a <a href="http://math.stackexchange.com/questions/135463/path-connectedness-and-locally-path-connected">example</a> of path connected but not locally path connected</li>
</ul></li>
</ul>
<h2 id="separation-axioms">separation axioms</h2>
<ul>
<li><span id="cross-$T_1$-space" class="crosslink">$T_1$ space</span> two point separated by open set</li>
<li><span id="cross-Hausdorff-space" class="crosslink">Hausdorff space</span> two different point has disjoint open neighborhoods
<ul>
<li>any seq has at most one limit</li>
<li>subspace of Hausdorff space is Hausdorff</li>
</ul></li>
<li><span id="cross-regular-space" class="crosslink">regular space</span>
<ul>
<li><a href="#cross-second-countable-space">second countable space</a> . <a href="#cross-regular-space">regular space</a> is <a href="#cross-metrizable">metrizable</a></li>
</ul></li>
<li><span id="cross-normal-space" class="crosslink">normal space</span> …
<ul>
<li>subspace of normal space not necessary normal</li>
<li>compact Hausdorff space is normal</li>
<li>compact disjoint subset of Hausdorff space has disjoint neighborhood <span class="math">\(\Rightarrow\)</span> (compact Hausdorff <span class="math">\(\Rightarrow\)</span> normal)</li>
</ul></li>
</ul>
<h2 id="countability-axioms">countability axioms</h2>
<ul>
<li><span id="cross-second-countable-space" class="crosslink">second countable space</span> has countable base</li>
<li><span id="cross-separable" class="crosslink">separable</span> has countable dense set</li>
</ul>
<h2 id="compactness">compactness</h2>
<ul>
<li><span id="cross-compact-space" class="crosslink">compact space</span> any open covering has finite subcovering <span class="math">\(\Leftrightarrow\)</span> any family of closed set have finite intersection property <span class="math">\(\Rightarrow\)</span> infinite intersection is also non-empty
<ul>
<li><em>what means? travel by open cover?</em></li>
<li>morphism compactness</li>
<li><span id="cross-relatively-compact" class="crosslink">relatively compact</span> closure is compact</li>
<li><strong>closed subspace of compact is compact</strong></li>
<li><strong>compact subspace of Hausdorff space is closed</strong></li>
<li><span id="cross-Tychonoff's" class="crosslink">Tychonoff's</span> product preserve compact</li>
</ul></li>
<li><span id="cross-sequentially-compact" class="crosslink">sequentially compact</span> every sequence has a point of accumulation
<ul>
<li><em>you are not going too far away!!!</em></li>
<li><em>so actually compact is a stronger condition!</em></li>
<li><em>this def is not same as the Wikipedia one!!!</em></li>
<li>compact <span class="math">\(\Rightarrow\)</span> seq compact</li>
<li>in <a href="#cross-second-countable-space">second countable space</a> compact = seq compact
<ul>
<li>proof: open cover =&gt; countable cover =&gt; unique point cover =&gt; must finite =&gt; if not =&gt; acc point!</li>
</ul></li>
</ul></li>
<li><span id="cross-locally-compact-space" class="crosslink">locally compact space</span> every point has an compact <a href="#cross-neighborhood">neighborhood</a></li>
</ul>
<h2 id="separation-by-continuous-functions">separation by continuous functions</h2>
<ul>
<li><span class="math">\(X\)</span> normal space
<ul>
<li><span class="math">\(A\)</span> closed, <span class="math">\(U\)</span> open then <span class="math">\(A &lt; U_1 &lt; {\text{Cl }}U_1 &lt; U\)</span></li>
<li><span id="cross-Urysohn's-lemma" class="crosslink">Urysohn's lemma</span> <span class="math">\(A\)</span>, <span class="math">\(B\)</span> be closed disjoint subset, then separable by continuous functions in <span class="math">\([0, 1]\)</span> with, <span class="math">\(f(A) = 0\)</span> and <span class="math">\(f(B) = 1\)</span>
<ul>
<li>the locally compact Hausdorff case</li>
</ul></li>
<li><span id="cross-Tietze-extension" class="crosslink">Tietze extension</span></li>
</ul></li>
</ul>
<h2 id="metric-space">metric space</h2>
<ul>
<li><span><span id="cross-metrizable"></span><span id="cross-metric-space" class="crosslink">metric space </span></span>
<ul>
<li><span class="math">\(d(a, b): T\to {\mathbb{R}}\)</span>
<ul>
<li>positive and <span class="math">\(d(a, b) = 0 \Leftrightarrow a = b\)</span></li>
<li><span class="math">\(d(a, b) = d(b, a)\)</span></li>
<li><span class="math">\(d(x, y) \leq d(x, z) + d(z, y)\)</span></li>
</ul></li>
<li><span id="cross-open-ball" class="crosslink">open ball</span>, <span id="cross-closed-ball" class="crosslink">closed ball</span>, <span id="cross-sphere" class="crosslink">sphere</span></li>
<li><span id="cross-Cauchy-seq" class="crosslink">Cauchy seq</span></li>
<li><span id="cross-seq-converge" class="crosslink">seq converge</span></li>
<li><span id="cross-Cauchy-complete" class="crosslink">Cauchy complete</span>. Cauchy seq converge</li>
<li><a href="#cross-continuous-at-point">continuous at point</a> is <span class="math">\(\delta\)</span> <span class="math">\(\epsilon\)</span></li>
<li>is <a href="#cross-normal-space">normal space</a></li>
<li><span id="cross-metric-equivalence" class="crosslink">metric equivalence</span> give same topology
<ul>
<li><span class="math">\(C_1|x|_1 \leq |x|_2 \leq C_2|x|_1\)</span></li>
</ul></li>
<li>metric space can always embedded into nvs
<ul>
<li>how about a discrete matric??</li>
</ul></li>
<li><span id="cross-totally-bounded" class="crosslink">totally bounded</span> exists finite open ball of <span class="math">\(r\)</span> cover for all <span class="math">\(r\)</span></li>
<li>compact <span class="math">\(\Leftrightarrow\)</span> seq compact <span class="math">\(\Leftrightarrow\)</span> complete and totally bounded
<ul>
<li>proof: metric =&gt; seq compact == compact =&gt; complete &amp;&amp; totally bounded || <strong>the proof is intricate!, it should really be a memorized technical lemma!!</strong></li>
<li>subset of complete metric space (totally bounded <span class="math">\(\Leftrightarrow\)</span> relatively compact)</li>
<li><span class="math">\(f\)</span> <strong>continuous</strong> on compact set has max</li>
<li><span class="math">\(f: A \to F\)</span> compact subset of metric space to metric space
<ul>
<li>continuous = uniform continuous. proof using <span class="math">\(r\)</span> has min, because it is compact</li>
</ul></li>
</ul></li>
<li>compact metric space is <a href="#cross-separable">separable</a></li>
</ul></li>
</ul>
<h2 id="normed-vector-space">normed vector space</h2>
<ul>
<li><span id="cross-normed-vector-space" class="crosslink">normed vector space</span> over <span class="math">\({\mathbb{R}}\)</span> or <span class="math">\({\mathbb{C}}\)</span>
<ul>
<li>define a function to <span class="math">\({\mathbb{R}}\)</span></li>
<li><span class="math">\(|x| \ge 0\)</span> and only <span class="math">\(= 0\)</span> if <span class="math">\(x = 0\)</span></li>
<li><span class="math">\(|cx| = |c||x|\)</span></li>
<li><span class="math">\(|x+y| &lt;|x| + |y|\)</span></li>
<li>all norm is equivalent</li>
<li>examples
<ul>
<li><span id="cross-sup-norm" class="crosslink">sup norm</span>
<ul>
<li><span id="cross-uniformly-cauchy" class="crosslink">uniformly cauchy</span>, <span id="cross-uniformly-convergent" class="crosslink">uniformly convergent</span></li>
</ul></li>
<li><span class="math">\(L^1\)</span>-norm</li>
<li><span id="cross-Euclidean-norm" class="crosslink">Euclidean norm</span> on <span class="math">\({\mathbb{R}}^n\)</span> and <span class="math">\({\mathbb{C}}^n\)</span></li>
<li><span class="math">\(l^p\)</span>-norm</li>
<li><span class="math">\(L^p\)</span>-norm <span id="cross-Lebesgue-space" class="crosslink">Lebesgue space</span>s</li>
<li><a href="http://en.wikipedia.org/wiki/Norm_(mathematics)">http://en.wikipedia.org/wiki/Norm_(mathematics)</a></li>
</ul></li>
<li>normed vector space locally compact <span class="math">\(\Leftrightarrow\)</span> finite dimensional
<ul>
<li>in <span class="math">\({\mathbb{R}}^n\)</span> compact <span class="math">\(\Leftrightarrow\)</span> closed and bounded</li>
</ul></li>
<li>example of incomplete normed vector space <a href="http://math.stackexchange.com/questions/209665/series-in-incomplete-normed-space">http://math.stackexchange.com/questions/209665/series-in-incomplete-normed-space</a></li>
<li>one point compactification</li>
<li><span class="math">\(B(S, F)\)</span> <span id="cross-space-of-bounded-maps-to-nvs" class="crosslink">space of bounded maps to nvs</span></li>
<li><span class="math">\(C(S, F)\)</span> <span id="cross-space-of-continuous-maps-to-nvs" class="crosslink">space of continuous maps to nvs</span></li>
<li><span class="math">\(BC(S, F)\)</span> <span id="cross-space-of-bounded-continuous-maps-to-nvs" class="crosslink">space of bounded continuous maps to nvs</span></li>
</ul></li>
</ul>
<h2 id="exercise-from-ref-topology-lang">exercise from <a href="#cross-ref-topology-lang">ref-topology-lang</a></h2>
<h2 id="references-3">references</h2>
<ul>
<li><span id="cross-ref-topology-exercise" class="crosslink">ref-topology-exercise</span> <em>General Topology Exercise Textbook</em></li>
<li><span id="cross-ref-topology-lang" class="crosslink">ref-topology-lang</span> <em>Real and Functional Analysis</em>, Chapter 2</li>
</ul>
<h1 id="homotopy-space">homotopy space</h1>
<h2 id="idea-4">idea</h2>
<ul>
<li>the subject of algebraic topology is to give <a href="#cross-algebra">algebra</a> structure on a <a href="#cross-space">space</a></li>
</ul>
<h2 id="homotopy-space-1">homotopy space</h2>
<p><em>it is only about maps between them now, i think eventually we will have space = groupoid or soemthing</em> <code>fix me: when you understand</code></p>
<ul>
<li><span id="cross-homotopy" class="crosslink">homotopy</span>. <span class="math">\(h: X\times I\to Y\)</span> such that <span class="math">\(h(x, 0) = f(x)\)</span>, <span class="math">\(h(x, 1) = g(x)\)</span>
<ul>
<li>why there is the <a href="#cross-interval">interval</a>? because deformation of space must in time?? what is time???</li>
<li>then it means that homotopy in discrete space is always uninteresting</li>
</ul></li>
<li>there is a <a href="#cross-functor">functor</a> from <a href="#cross-space">space</a> to the <span id="cross-homotopy-space" class="crosslink">homotopy space</span> <span class="math">\(h\mathcal{U}\)</span>
<ul>
<li><a href="#cross-object">object</a>. same</li>
<li><a href="#cross-morphism">morphism</a>. <a href="#cross-continuous-function">continuous function</a> to the <span id="cross-homotopy" class="crosslink">homotopy</span> class</li>
<li><a href="#cross-isomorphism">isomorphism</a>s is <span class="math">\(f \cdot g \simeq {\text{id}}\)</span> things, which is called <a href="#cross-homotopy-equivalence">homotopy equivalence</a> in <span class="math">\(\mathcal{U}\)</span>
<ul>
<li><span id="cross-contractible" class="crosslink">contractible</span>. isomorphism to 0</li>
</ul></li>
<li><em>makes the functions between them a lot more simple, and introduced so many <a href="#cross-isomorphism">isomorphism</a>s</em></li>
</ul></li>
<li>a functor from <a href="#cross-pointed-space">pointed space</a> to <span id="cross-pointed-homotopy-space" class="crosslink">pointed homotopy space</span>, <span class="math">\(h\mathcal{T}\)</span>
<ul>
<li><a href="#cross-object">object</a>. same</li>
<li><a href="#cross-morphism">morphism</a>. it is just like viewed as a <a href="#cross-product-space">product space</a> in <a href="#cross-homotopy-space">homotopy space</a>, which keeps <a href="#cross-basepoint">basepoint</a> always fixed</li>
<li>the <a href="#cross-fundamental-group">fundamental group</a> . <a href="#cross-functor">functor</a> factor though pointed homotopy space
<ul>
<li>an based homotopy equivalence induce an isomorphism in fundamental group, which is just trivial</li>
</ul></li>
<li>is there exist two continuous function that can only be homotopy in <span class="math">\(h\mathcal{U}\)</span> but not <span class="math">\(h\mathcal{T}\)</span>, i.e. only exist homotopy that moves basepoint in the middle of the transform <code>fix me</code></li>
</ul></li>
</ul>
<h2 id="fundamental-groupoid">fundamental groupoid</h2>
<ul>
<li><span id="cross-fundamental-groupoid" class="crosslink">fundamental groupoid</span>. <a href="#cross-functor">functor</a> from space <span class="math">\(\mathcal{U}\)</span> to <a href="#cross-groupoid">groupoid</a> <span class="math">\(\mathcal{GP}\)</span>
<ul>
<li><a href="#cross-object">object</a>. <a href="#cross-groupoid">groupoid</a> by taking <span class="math">\([f]\)</span> the <a href="#cross-homotopy">homotopy</a> class of <a href="#cross-path">path</a> <span class="math">\(f\)</span> in the <strong>paths</strong> from <span class="math">\(x\)</span> to <span class="math">\(y\)</span>, it is not just <a href="#cross-homotopy">homotopy</a> of the path considered as <span class="math">\(I \to X\)</span>, in a type theory view, this might be easy, for we can consider it be the type <code>Path(X, x, y)</code>
<ul>
<li><span class="math">\(f: x \to y\)</span>, <span class="math">\(g: y\to z\)</span></li>
<li><span class="math">\([g][f] = [g\cdot f]\)</span>, notice the order</li>
<li><span class="math">\([f]^{-1} = [f^{-1}]\)</span></li>
<li>it is a <a href="#cross-groupiod">groupiod</a>
<ul>
<li><span class="math">\([f]^{-1}[f] = [f^{-1}f] = [c_x]\)</span></li>
</ul></li>
</ul></li>
<li><a href="#cross-morphism">morphism</a>. induced?</li>
<li>structure
<ul>
<li>a path in it makes two local <a href="#cross-group">group</a> . <a href="#cross-conjugate">conjugate</a>
<ul>
<li><span class="math">\(S^1\)</span>, by two path, <a href="#cross-morphism">morphism</a> <span class="math">\({\text{id}}\)</span></li>
<li><span class="math">\(S^1\vee S^1\)</span>, by two path, <a href="#cross-morphism">morphism</a> is <code>a =&gt; a &amp;&amp; b =&gt; a^-1ba</code></li>
<li>if the group is <a href="#cross-abelian">abelian</a> then we have an <a href="#cross-unique">unique</a> . <a href="#cross-isomorphism">isomorphism</a> between the two local group, this do not means there are only one element in the <a href="#cross-groupoid">groupoid</a></li>
<li>this is restatement in <a href="#cross-fundamental-group">fundamental group</a></li>
</ul></li>
<li>for a <a href="#cross-path-connected-space">path connected space</a>, the fundamental groupoid is <span id="cross-groupoid-connected" class="crosslink">groupoid connected</span>, which is a special case of <a href="#cross-connected-category">connected category</a>, so it is <a href="#cross-category-equivalence">category equivalence</a> to the <a href="#cross-skeleton-category">skeleton category</a> of fundamental groupoid, which is <a href="#cross-fundamental-group">fundamental group</a></li>
</ul></li>
<li><p><span id="cross-van-Kampen-for-groupoid" class="crosslink">van Kampen for groupoid</span>, fundamental groupoid <a href="#cross-preserve-colimit">preserve colimit</a> certain</p>
<ul>
<li><span class="math">\(\mathcal{O}\)</span> be a <a href="#cross-cover">cover</a> of <a href="#cross-space">space</a> <span class="math">\(X\)</span> by <a href="#cross-path-connected">path connected</a> . <a href="#cross-open-set">open set</a>s, closed under finite <a href="#cross-intersection">intersection</a></li>
<li>as a category morphism are <a href="#cross-inclusion">inclusion</a>s of subsets, gives a <a href="#cross-diagram">diagram</a> <span class="math">\[\Pi | \mathcal{O}: \mathcal{O}\to\mathcal{GP}\]</span></li>
<li>the <a href="#cross-groupoid">groupoid</a> <span class="math">\(\Pi(X)\)</span> is the <a href="#cross-colimit">colimit</a> of the diagram <span class="math">\[\Pi(X)\cong colim_{U\in \mathcal{O}}\Pi(U)\]</span></li>
<li>the proof is very natural</li>
</ul></li>
<li>it do not factor though <a href="#cross-homotopy-space">homotopy space</a>, this is simple, think <a href="#cross-contractible">contractible</a> space. so <a href="#cross-fundamental-groupoid">fundamental groupoid</a> is redundant with internal structures, and <a href="#cross-fundamental-group">fundamental group</a> is redundant with external <a href="#cross-isomorphism">isomorphism</a>s. they are kind of two viewport</li>
<li><p>an example of two different <a href="#cross-space">space</a> maps two same groupoid: two point space with discrete <a href="#cross-topology">topology</a> and one-point-only <a href="#cross-topology">topology</a></p></li>
</ul></li>
</ul>
<h2 id="fundamental-group">fundamental group</h2>
<ul>
<li><a href="#cross-functor">functor</a> from <a href="#cross-pointed-space">pointed space</a> <span class="math">\(\mathcal{T}\)</span> to <a href="#cross-group">group</a> <span class="math">\(\mathcal{G}\)</span>
<ul>
<li><a href="#cross-object">object</a>. contstruct as <a href="#cross-fundamental-groupoid">fundamental groupoid</a>, but only keep <a href="#cross-loop">loop</a>s</li>
<li><a href="#cross-morphism">morphism</a>. <span class="math">\(p: X\to Y\)</span> to group <a href="#cross-homomorphism">homomorphism</a>, <span class="math">\(p_*: \pi_1(X, x)\to \pi_1(Y, y)\)</span> by <span class="math">\(p_*[f] = [p\circ f]\)</span>, it is well defined for the <a href="#cross-law-of-composition">law of composition</a></li>
<li><span><span id="cross-van-Kampen"></span><span id="cross-van-Kampen-for-fundamental-group" class="crosslink">van Kampen for fundamental group</span></span>
<ul>
<li>first by <a href="#cross-skeleton-category">skeleton category</a>, we proof for finite case, it is because we need a base to inductively define the reverse <span class="math">\(J\)</span> for skeleton category</li>
<li>then it is proofed for infinite version <code>fix me</code></li>
</ul></li>
<li><a href="#cross-product">product</a> is preserved, it is proofed by <strong>universal property</strong> but <code>fix me</code></li>
<li>i think there are many homotopy class on <span class="math">\(S^1 \times S^1\to S^1\times S^1\)</span>, examples are projection, id, and swap, but some are not path induced</li>
<li>the <a href="#cross-isomorphism">isomorphism</a>s for different <a href="#cross-basepoint">basepoint</a> . <a href="#cross-space">space</a>s. in summary, <a href="#cross-basepoint">basepoint</a> changing results in <a href="#cross-isomorphism">isomorphism</a>, some of them will have unique isomorphism, and when the <a href="#cross-group">group</a> is <a href="#cross-abelian">abelian</a>, it is unique. but this is not isomorphism in <a href="#cross-pointed-space">pointed space</a>, it is reduced to <a href="#cross-morphism">morphism</a> in <a href="#cross-space">space</a>, then project to <a href="#cross-group">group</a>
<ul>
<li><span class="math">\(a\)</span> a path, <span class="math">\(\gamma[a]\)</span> the <a href="#cross-homomorphism">homomorphism</a> to move point</li>
<li><span class="math">\(\gamma[a][f] = [a\cdot f \cdot a^{-1}]\)</span></li>
<li>it only depends on the <a href="#cross-homotopy">homotopy</a> class of <span class="math">\(a\)</span></li>
<li>it is <a href="#cross-isomorphism">isomorphism</a> with inverse <span class="math">\(\gamma[a^{-1}]\)</span></li>
<li>if the group is <a href="#cross-abelian">abelian</a> we have <span class="math">\(\gamma[b][f] = \gamma[a][f]\)</span>, you should view the structure in the groupoid, and switch basepoint</li>
<li>so there are <span class="math">\(n\)</span> kinds of path induced isomorphism between <span class="math">\(\pi_1(X,x)\)</span> and <span class="math">\(\pi_1(X, y)\)</span> where <span class="math">\(n\)</span> is the number of homotopy class of the path between the two point, so one homotopy class means one isomorphism is path induced, and then we can use this way to identity two group</li>
</ul></li>
<li><a href="#cross-isomorphism">isomorphism</a> by <a href="#cross-morphism">morphism</a> in <a href="#cross-homotopy-space">homotopy space</a>. an <a href="#cross-isomorphism">isomorphism</a> in <a href="#cross-homotopy-space">homotopy space</a> is a class of <a href="#cross-morphism">morphism</a>s in <a href="#cross-pointed-space">pointed space</a>, and by this class of <a href="#cross-morphism">morphism</a>, you get <a href="#cross-isomorphism">isomorphism</a> in group</li>
<li><a href="#cross-isomorphism">isomorphism</a> by <a href="#cross-isomorphism">isomorphism</a> in <a href="#cross-homotopy-space">homotopy space</a>. again, they are not <a href="#cross-isomorphism">isomorphism</a> in <a href="#cross-pointed-space">pointed space</a>, but reduced. <a href="#cross-isomorphism">isomorphism</a> in <a href="#cross-homotopy-space">homotopy space</a> is class of (because of the homotopy) class of (because adding basepoint) <a href="#cross-morphism">morphism</a> in <a href="#cross-pointed-space">pointed space</a>, each of them is isomorphism. if <span class="math">\(f:X \to Y\)</span> is iso in <a href="#cross-homotopy-space">homotopy space</a> then <span class="math">\(f_*: \pi_1(X, x) \to \pi_1(Y, f(x))\)</span> is <span id="cross-isomorphism" class="crosslink">isomorphism</span> for all <span class="math">\(x\)</span></li>
<li><a href="#cross-simply-connected">simply connected</a> fundamental group is zero and <a href="#cross-path-connected">path connected</a>
<ul>
<li>it has little thing to do with <a href="#cross-contractible">contractible</a></li>
</ul></li>
</ul></li>
</ul>
<h3 id="examples-and-exercises">examples and exercises</h3>
<ul>
<li>for <a href="#cross-contractible">contractible</a> space, the fundamental group is 0</li>
<li><span class="math">\(\pi_1(\mathbb{R}) = 0\)</span></li>
<li><span class="math">\(\pi_1(S^1) = \mathbb{Z}\)</span></li>
<li>p20 proposition and exercises bellow, i do not know how to compute the push outs… <code>fix me: not understand the pushout now</code></li>
</ul>
<p>from <em><a href="#cross-ref-at-concise">ref-at-concise</a></em></p>
<ol style="list-style-type: decimal">
<li>The Brouwer fixed point theorem</li>
<li>The fundamental theorem of algebra</li>
<li>exercises <code>fix me</code>, i do not know what’s the <span class="math">\(deg\)</span> and what’s topological group</li>
<li>for <a href="#cross-real-projective-space">real projective space</a> <code>fix me</code></li>
</ol>
<h2 id="covering-space">covering space</h2>
<p>we assume all space considered is <a href="#cross-locally-path-connected">locally path connected</a> and <a href="#cross-connected">connected</a></p>
<ul>
<li><span><span id="cross-covering"></span><span id="cross-covering-space" class="crosslink">covering space </span></span> <span class="math">\(p: E\to B\)</span>
<ul>
<li><a href="#cross-surjective">surjective</a></li>
<li>each <span class="math">\(b\in B\)</span>, has <a href="#cross-open">open</a> . <a href="#cross-neighborhood">neighborhood</a> <span class="math">\(V\)</span>, such that each <a href="#cross-disjoint-component">disjoint component</a> of <span class="math">\(p^{-1}(V)\)</span> is open and mapped <a href="#cross-homeomorphically">homeomorphically</a> onto V by <span class="math">\(p\)</span>
<ul>
<li>so it should not “go back” in the middle?</li>
<li><span id="cross-fundamental-neighborhood" class="crosslink">fundamental neighborhood</span>. <a href="#cross-path-connected">path connected</a> . <a href="#cross-open">open</a></li>
</ul></li>
<li><span id="cross-totally-space" class="crosslink">totally space</span></li>
<li><span id="cross-base-space" class="crosslink">base space</span></li>
<li><span id="cross-fiber" class="crosslink">fiber</span> of covering <span class="math">\(p\)</span></li>
</ul></li>
</ul>
<h3 id="unique-path-lifting">unique path lifting</h3>
<ul>
<li><span class="math">\(p: E\to B\)</span> and <span class="math">\(b\in B\)</span>, <span class="math">\(e,e'\in F_b\)</span>
<ul>
<li>a path <span class="math">\(f: I\to B\)</span> lefts uniquely for every <span class="math">\(e\)</span> such that <span class="math">\(g(0) = e\)</span> and <span class="math">\(p\circ g = f\)</span>. the proof is actually easy</li>
<li>equivalent path lifts to equivalent path, and hence <span class="math">\(g(1)=g'(1)\)</span>. proof <span class="math">\(p\circ h: I\times I \to B\)</span>, compact, fundamental cover, finite cover, project back, base, finite cover, grid, grow the border (a old square only can all include the line or include nothing, so you can grow it!), inductively define the homotopy</li>
<li><span id="cross-regular-covering" class="crosslink">regular covering</span>. <span class="math">\(p_*\)</span> project to normal group</li>
<li><span id="cross-universal-covering" class="crosslink">universal covering</span>. <a href="#cross-simply-connected">simply connected</a> cover
<ul>
<li>for a universal cover, <span class="math">\(F_b\)</span> are in bijective with <span class="math">\(\pi_1(B, b)\)</span></li>
<li>for <span class="math">\(n \geq 3\)</span>, <span class="math">\(\mathbf{R}P^n\)</span> covered by <span class="math">\(S^n\)</span>, then we can see that <span class="math">\(\pi_1(\mathbf{R}P^n) =2\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="covering-groupoid">covering groupoid</h3>
<ul>
<li><a href="#cross-coslice-category">coslice category</a> of the <a href="#cross-groupoid">groupoid</a></li>
<li><span id="cross-star" class="crosslink">star</span> of <span class="math">\(x\)</span>, <span class="math">\(St(x)\)</span></li>
<li><span id="cross-covering-of-groupoid" class="crosslink">covering of groupoid</span>
<ul>
<li><a href="#cross-surjective">surjective</a></li>
<li>restricts to bijection <span class="math">\(p:St(e)\to St(p(e))\)</span> for each <span class="math">\(e\)</span></li>
<li>the def of covering groupoid is just the useful properties of covering space. above can be reformulated as induced functor <span class="math">\(\Pi(p):\Pi(E)\to \Pi(B)\)</span> of cover space <span class="math">\(p\)</span> induce a covering groupoid</li>
</ul></li>
<li><span class="math">\(p_*: \pi_1(E, e)\to \pi_1(B,b)\)</span> is <a href="#cross-monomorphism">monomorphism</a> and base changing group is <a href="#cross-conjugate">conjugate</a>, and as one runs though <span class="math">\(e'\)</span>, we runs through conjugate groups in <span class="math">\(\pi_1(B,b)\)</span>
<ul>
<li>examples: i suspect all finite cover will leave the fundamental group unchanged, but in the infinite circle case, we can see that it is really monomorphism, because <span class="math">\(e\)</span> back, then <span class="math">\(b\)</span> must back, but not reverse</li>
<li>i cannot found a example that is really non-trivial conjugate, they are all surjective or not moving, i can found an example it is non-trivial subgroup, just when you cannot come back by something. for a non-trivial conjudate, see <a href="#cross-ref-at-hatcher">ref-at-hatcher</a></li>
<li>run though conjugate, but still not the whole group sometimes</li>
<li><span id="cross-regular-covering-groupoid" class="crosslink">regular covering groupoid</span>. <span class="math">\(p(\pi(\mathcal{E}, e))\)</span> is normal subgroup of <span class="math">\(\pi(\mathcal{B}, b)\)</span></li>
<li><span id="cross-universal-covering-groupoid" class="crosslink">universal covering groupoid</span>. <span class="math">\(p(\pi(\mathcal{E}, e)) = \{e\}\)</span></li>
</ul></li>
<li>translation function <span class="math">\(T(b): \mathcal{B}\to \mathcal{Set}\)</span> (the set of fibers at a point), <span class="math">\(T(f)\)</span> is a morphism in <span class="math">\(\mathcal{Set}\)</span> which depends on <span class="math">\(f\)</span> will have different behaviour
<ul>
<li>fibers has same <a href="#cross-cardinality">cardinality</a></li>
</ul></li>
<li><a href="#cross-groupoid-action">groupoid action</a>in <a href="#cross-covering-groupoid">covering groupoid</a>s
<ul>
<li>the <a href="#cross-isotropy">isotropy</a> group of <span class="math">\(e\)</span> is <span class="math">\(p(\pi(\mathcal{E}, e))\)</span></li>
<li>it is <a href="#cross-transitive-groupoid-action">transitive groupoid action</a></li>
<li>so <span class="math">\(F_b \cong \pi(\mathcal{B}, b)/ p(\mathcal{E}, e)\)</span>. this means bijection? we do not know it is <a href="#cross-normal">normal</a> now</li>
<li>if the covering is <a href="#cross-universal-covering-groupoid">universal covering groupoid</a>, then <span class="math">\(F_b\cong \pi(\mathcal{B}, b)\)</span></li>
</ul></li>
</ul>
<h3 id="classification-of-covering-of-groupoids">classification of covering of groupoids</h3>
<ul>
<li><a href="#cross-category">category</a> of <a href="#cross-groupoid-covering">groupoid covering</a> of <span class="math">\(\mathcal{B}\)</span>, <span class="math">\({\text{Cov}}(\mathcal{B})\)</span>
<ul>
<li><a href="#cross-object">object</a>. <a href="#cross-groupoid-covering">groupoid covering</a>s</li>
<li><a href="#cross-morphism">morphism</a>. <span class="math">\(g:\mathcal{E}\to\mathcal{E'}\)</span> is a <span id="cross-map-of-covering" class="crosslink">map of covering</span> if only <span class="math">\(p = p'\circ g\)</span>
<ul>
<li>they are also covering! proof for <a href="#cross-surjection">surjection</a>, and <a href="#cross-bijection">bijection</a></li>
<li>when exist?
<ul>
<li>a functor <span class="math">\(f: \mathcal{X}\to \mathcal{B}\)</span> reduce functor <span class="math">\(g: \mathcal{X}\to\mathcal{E}\)</span> and compute only if <span class="math">\(f(\mathcal{X}, x_0)\subset p(\mathcal{E}, e_0)\)</span></li>
<li>when two covering same as above, then there exists an unique covering. and …</li>
</ul></li>
<li><a href="#cross-universal-covering-groupoid">universal covering groupoid</a> is unique up to isomorphism and covering all other covers</li>
<li>they are bijective to <span class="math">\(G\)</span>-maps <span class="math">\(F_b\to F_b'\)</span></li>
<li><span class="math">\({\text{Aut}}(\mathcal{E})\)</span> is isomorphic to group of isomorphism of <span class="math">\(F_b\)</span> and so <span class="math">\(W_{p(\pi(\mathcal{E}, e))}\)</span>. if <span class="math">\(p\)</span> is regular, then …, if universal. then <span class="math">\(G\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="construction-of-covering-groupoids">construction of covering groupoids</h3>
<p><code>fix me: i do not want to read!!! a covering theorem, such a long way!!</code></p>
<h3 id="classification-of-covering-of-space">classification of covering of space</h3>
<p><code>fix me: totally sick</code></p>
<h2 id="example">example</h2>
<ul>
<li><span id="cross-real-projective-space" class="crosslink">real projective space</span>
<ul>
<li>the real projective space <span class="math">\(\mathbb{R}P^n\)</span> is obtained by gluing antipodal points of <span class="math">\(S^n\)</span></li>
</ul></li>
</ul>
<h2 id="references-4">references</h2>
<ul>
<li><span id="cross-ref-at-concise" class="crosslink">ref-at-concise</span> <em>A Concise Course in Algebraic Topology</em></li>
<li><span id="cross-ref-at-hatcher" class="crosslink">ref-at-hatcher</span> <em>Algebraic Topology</em>, Hatcher</li>
</ul>
<h1 id="real-and-functional-analysis">real and functional analysis</h1>
<p>we use <span class="math">\({\mathbb{F}}\)</span> stands for <span class="math">\({\mathbb{R}}\)</span> or <span class="math">\({\mathbb{C}}\)</span></p>
<h2 id="continuous-functions-on-compact-spaces">continuous functions on compact spaces</h2>
<ul>
<li><em>i’d like to know the importance of these theorems, because they seems so arbitrary</em>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Continuous_functions_on_a_compact_Hausdorff_space">Wikipedia</a></li>
</ul></li>
<li>for <span class="math">\(B(S,F)\)</span> using sup-norm
<ul>
<li><span class="math">\(F\)</span> complete <span class="math">\(\Rightarrow\)</span> <span class="math">\(B(S,F)\)</span> complete</li>
<li><span class="math">\(BC(S, F)\)</span> is closed in <span class="math">\(B(S, F)\)</span></li>
</ul></li>
<li><span class="math">\({\mathbb{F}}\)</span> valued <span id="cross-algebra-of-functions" class="crosslink">algebra of functions</span> on <span class="math">\(X\)</span>
<ul>
<li><span class="math">\(fg\in A\)</span>, <span class="math">\(f+g\in A\)</span>, <span class="math">\(cf\in A\)</span></li>
<li>example of algebra: <span class="math">\(C(X)\)</span>, polynomials</li>
<li><span id="cross-separates-points" class="crosslink">separates points</span></li>
</ul></li>
<li><span id="cross-Stone-Weierstrass-theorem" class="crosslink">Stone-Weierstrass theorem</span> on compact set <span class="math">\(S\)</span> an algebra <span class="math">\(A\)</span> of <span class="math">\({\mathbb{R}}\)</span>
<ul>
<li>separate points <span class="math">\(\land\)</span> contains constant <span class="math">\(\Leftrightarrow\)</span> uniform closure is <span class="math">\(C(S)\)</span></li>
<li>complex version, <span class="math">\(A\)</span> additionally self conjugate, same result</li>
<li>proof: first under the max, min, we can approx using compact(for each point, construct an all lower function, then using them to get an all upper function), second, we can approx abs using polynomials. in complex version, we have conjugate to proof the real valued ones separate points, then we use real valued to approx complex valued</li>
</ul></li>
<li><span id="cross-ring-of-real-or-complex-valued-functions" class="crosslink">ring of real or complex valued functions</span>
<ul>
<li><span class="math">\(Z_f\)</span> zeros of a continuous function is closed</li>
<li><span class="math">\(Z(J) = \bigcap Z_f\)</span></li>
</ul></li>
<li><span class="math">\(X\)</span> an compact space, <span class="math">\(R\)</span> ring of <span class="math">\({\mathbb{F}}\)</span> valued continuous function on <span class="math">\(X\)</span>, with sup norm. <span class="math">\(J\)</span> a closed ideal. <span class="math">\(f \in R \land f(x) = 0 \forall x \in Z(J)\Rightarrow f \in J\)</span>
<ul>
<li>it created a semi-constant in <span class="math">\(J\)</span></li>
<li><em>understand what the theorem says, if you have a ideal, then almost all function that has the zeros of the ideal will in the ideal!!!</em></li>
<li>i think i should verify carefully for <code>fix me: complex version</code></li>
</ul></li>
<li><span id="cross-equicontinuous" class="crosslink">equicontinuous</span> of <span class="math">\(O\subset C(X, F)\)</span> at <span class="math">\(x_0\)</span>, <span class="math">\(X\)</span> is subset of <a href="#cross-metric-space">metric space</a> and <span class="math">\(F\)</span> is <a href="#cross-Banach-space">Banach space</a>. <span class="math">\(\forall e, \exists t (d(x, x_0) &lt; t \Rightarrow \forall f \in O: |f(x)-f(x_0)| &lt; e)\)</span></li>
<li><span id="cross-Ascoli's-theorem" class="crosslink">Ascoli's theorem</span> <span class="math">\(X\)</span> compact subset of metric space, <span class="math">\(F\)</span> a Banach space, <span class="math">\(O\)</span> subset of <span class="math">\(C(X,F)\)</span> with sup-norm (<span class="math">\(O\)</span> is relatively compact in <span class="math">\(C(X,F)\)</span> <span class="math">\(\Leftrightarrow\)</span> <span class="math">\(O\)</span> is <a href="#cross-equicontinuous">equicontinuous</a> <span class="math">\(\land\)</span> <span class="math">\(\forall x \in X, O(x)={f(x)}\)</span> is relatively compact)
<ul>
<li><em>it is that you can use open ball if they are about as one function: same rate and not too far away in values</em></li>
</ul></li>
</ul>
<h3 id="exercises">exercises</h3>
<ol start="0" style="list-style-type: decimal">
<li>proof that <span class="math">\(B(S, F)\)</span> complete, where <span class="math">\(S\)</span> is metric space, and <span class="math">\(F\)</span> is Banach space. <span class="math">\(BC(S,F)\)</span> is closed in <span class="math">\(B(S, F)\)</span>
<ul>
<li>construct by pointwize limit, then proof continuous (replace <span class="math">\(f\)</span> by a very close continuous function, that’s why you have sup norm), then proof that it converge</li>
<li>bounded by <span class="math">\(\sup f = \sup \lim f_n(a)\)</span></li>
<li>you should convince yourself that using limit is ok because no matter how complex the function space is, it is a complete normed vector space</li>
</ul></li>
<li>trivial</li>
<li>what’s the point of Hausdorff? if we are using conditions in 1, then it is that we can use extension to get a representation in <span class="math">\(R\)</span>, i think it is just that?</li>
<li>trivial</li>
<li>trivial</li>
<li><code>fix me</code></li>
<li><code>fix me</code></li>
<li><code>fix me</code></li>
<li>omitted</li>
<li><code>fix me</code></li>
<li>compact metric space <span class="math">\(X\)</span>, then <span class="math">\(C(X, {\mathbb{F}})\)</span> is separable. follow the hint, use SW on a countable algebra</li>
<li>tensor products are dense</li>
<li><code>fix me: finish after this</code></li>
</ol>
<h2 id="banach-spaces">Banach spaces</h2>
<ul>
<li><code>fix me: the image of continuous linear map is not necessary closed</code></li>
</ul>
<p>we assume <span class="math">\(E\)</span> and <span class="math">\(F\)</span> is <a href="#cross-normed-vector-space">normed vector space</a></p>
<ul>
<li><span id="cross-Banach-space" class="crosslink">Banach space</span>. complete normed vector space
<ul>
<li><span class="math">\({a_n} \ge 0\)</span> such that <span class="math">\(\sum a_n\)</span> converges (in <strong>Banach</strong> space <span class="math">\(\forall n, |x_n| \leq a_n\)</span> then <span class="math">\(\sum x_n\)</span> converges)</li>
<li><span id="cross-continuous-linear-map" class="crosslink">continuous linear map</span> <span class="math">\(L(E, F)\)</span>, where <span class="math">\(E\)</span>, <span class="math">\(F\)</span> is normed vector space
<ul>
<li><span id="cross-linear-map" class="crosslink">linear map</span> on vector space <span class="math">\(T(ax_1+bx_2) = aT(x_1) + bT(x_2)\)</span></li>
<li><span class="math">\(l: E \to F\)</span> continuous <span class="math">\(\Leftrightarrow\)</span> <span class="math">\(\exists C &gt; 0 \forall x \in E: |l(x)| \leq C|x| \)</span>
<ul>
<li>example of non-continuous linear map: <a href="http://en.wikipedia.org/wiki/Linear_map#Continuity">http://en.wikipedia.org/wiki/Linear_map#Continuity</a> <a href="http://en.wikipedia.org/wiki/Discontinuous_linear_map">http://en.wikipedia.org/wiki/Discontinuous_linear_map</a></li>
<li><span class="math">\(C\)</span> is bound of <span class="math">\(l\)</span>, <span class="math">\(l\)</span> is bounded</li>
<li>finite dimensional to normed vector space is always continuous, they are trivially bounded</li>
</ul></li>
<li><a href="#cross-norm">norm</a> of linear map. lub of all <span class="math">\(|l(x)|\)</span> on <span class="math">\(S_1\)</span>
<ul>
<li><span class="math">\(|u\circ v| \leq |u||v|\)</span> for <span class="math">\(L\)</span> map composition</li>
</ul></li>
<li>so it is an normed vector space</li>
<li><span class="math">\(F\)</span> complete <span class="math">\(\Rightarrow\)</span> <span class="math">\(L(E, F)\)</span> complete <code>fix me</code></li>
<li><span id="cross-operator" class="crosslink">operator</span> <span class="math">\(E \to E\)</span> continuous linear map</li>
<li><span id="cross-toplinear-isomorphisms" class="crosslink">toplinear isomorphisms</span> <span class="math">\({\text{Lis}}(E, F)\)</span></li>
<li><a href="#cross-automorphism">automorphism</a> <span class="math">\({\text{Laut}}(E)\)</span></li>
<li><span id="cross-isometry" class="crosslink">isometry</span> toplinear and <span class="math">\(|u(x)| = |x|\)</span></li>
</ul></li>
<li><span id="cross-bilinear" class="crosslink">bilinear</span> for normed vector space <span class="math">\(E\)</span>, <span class="math">\(F\)</span>, <span class="math">\(G\)</span>, <span class="math">\(l: E \times F \to G\)</span> is linear for two components
<ul>
<li>bilinear continuous <span class="math">\(\Leftrightarrow\)</span> <span class="math">\(|l(x, y)|\leq C|x||y|\)</span> <code>fix me</code></li>
<li>norm of bilinear, <span class="math">\(L(E, F; G)\)</span></li>
<li>and <span class="math">\(G\)</span> complete <span class="math">\(\Rightarrow\)</span> <span class="math">\(L(E, F; G)\)</span> complete</li>
<li>examples: matrix mul, dot product, cross product</li>
<li><a href="#cross-isometry">isometry</a> between <span class="math">\(L(E, L(F, G))\)</span> and <span class="math">\(L(E, F; G)\)</span></li>
</ul></li>
<li><span id="cross-multilinear-map" class="crosslink">multilinear map</span></li>
<li><span id="cross-dual-space" class="crosslink">dual space</span> <span class="math">\(L(E, {\mathbb{F}}) = E'\)</span>, functionals on <span class="math">\(E\)</span>
<ul>
<li>complete, because <span class="math">\(F\)</span> is complete</li>
<li><span id="cross-Hahn-Banach-theorem" class="crosslink">Hahn-Banach theorem</span> subspace <span class="math">\(F\)</span> of real nvs <span class="math">\(E\)</span>, <span class="math">\(l: F\to {\mathbb{R}}\)</span> a functional, then has same bound extension on <span class="math">\(E\)</span>
<ul>
<li><em>extension of continuous linear functionals</em></li>
<li>in nvs <span class="math">\(E\)</span>, <span class="math">\(v \neq 0\)</span> <span class="math">\(\Rightarrow\)</span> <span class="math">\(l(v) \neq 0\)</span> exists</li>
<li>in <span class="math">\({\mathbb{C}}\)</span> case</li>
</ul></li>
</ul></li>
<li><span id="cross-dual-dual-space" class="crosslink">dual dual space</span> <span class="math">\(E''\)</span>
<ul>
<li><span class="math">\(f_x: E' \to {\mathbb{F}}\)</span> such that <span class="math">\(f_x(l) = l(x)\)</span>, then <span class="math">\(x\to f_x\)</span> is <a href="#cross-linear-map">linear map</a> and <a href="#cross-injective">injective</a> and <a href="#cross-norm">norm</a> preserve. it is not necessary surjective
<ul>
<li><span class="math">\(|f_x| \leq |x|\)</span>, left is bounded by right, expand by definition!</li>
<li><span class="math">\(|f_x| \ge |x|\)</span>, the bound is bigger than <span class="math">\(|x|\)</span>, find one at least <span class="math">\(x\)</span>!, <span class="math">\(x = f_x({\text{id}}) \leq |f|\)</span></li>
</ul></li>
<li>this is, you evaluate at bigger value of a linear map, you get bigger!</li>
<li><span id="cross-weak$^*$-topology" class="crosslink">weak$^*$ topology</span> on <span class="math">\(E'\)</span> is determined by <span class="math">\(\{f_x\}\)</span></li>
<li><span id="cross-Alaoglu's-theorem" class="crosslink">Alaoglu's theorem</span> <span class="math">\(E\)</span> a Banach space, then <span class="math">\(E'_1\)</span> is compact for the weak<span class="math">\(^*\)</span> topology
<ul>
<li>the proof is by mapping it to the graph, but it is rather wired <code>fix me</code></li>
<li>notice that <span class="math">\(E'\)</span> has standard topology by norm, the relation <code>fix me</code></li>
</ul></li>
</ul></li>
<li>algebra. vs <span class="math">\(A\)</span> and multiplication: bilinear
<ul>
<li>cross product in <span class="math">\({\mathbb{R}}^3\)</span> not associative normed algebra</li>
</ul></li>
<li><span id="cross-normed-algebra" class="crosslink">normed algebra</span>. associative algebra on normed space <span class="math">\(\land\)</span> <span class="math">\(|uv| \leq |u||v|\)</span></li>
<li><span id="cross-Banach-algebra" class="crosslink">Banach algebra</span>. <a href="#cross-normed-algebra">normed algebra</a> and complete
<ul>
<li>bounded functions by multiplication of function</li>
<li><span class="math">\(A\)</span> Banach algebra with unit <span class="math">\(e\)</span>, invertible elements is open in <span class="math">\(A\)</span>, and if <span class="math">\(|v| &lt; 1\)</span> then <span class="math">\(e+v\)</span> is invertible
<ul>
<li>the proof is rather wired</li>
</ul></li>
<li><span class="math">\(u \to u^{-1}\)</span> is continuous</li>
<li><span class="math">\(E\)</span> and <span class="math">\(F\)</span> Banach space, then <span class="math">\({\text{Lis}}(E, F)\)</span> is open in <span class="math">\(L(E, F)\)</span></li>
<li><span class="math">\(L(Z, Z)\)</span> is Banach algebra by composition <code>fix me</code></li>
</ul></li>
<li><span class="math">\(E\)</span> nvs, <span class="math">\(F\)</span> subspace of <span class="math">\(E\)</span>, <span class="math">\(G\)</span> Banach space, continuous linear map <span class="math">\(l: F \to G\)</span> has unique linear extension <span class="math">\(\bar{l}: \bar{F} \to G\)</span> on the closure of <span class="math">\(F\)</span> that has same norm
<ul>
<li>example of open subspace? think functional</li>
<li>this is kind of like <a href="#cross-Hahn-Banach-theorem">Hahn-Banach theorem</a>, but the codomian is wider…? <code>fix me: finish the proof</code></li>
</ul></li>
<li>completion of normed vs <span class="math">\(E\)</span> unique exists
<ul>
<li><code>fix me</code></li>
</ul></li>
<li>operators
<ul>
<li><span class="math">\(S\)</span>-invariant subspace</li>
<li><span class="math">\(B\)</span> commute with <span class="math">\(S\)</span> <span class="math">\(\Rightarrow\)</span> kernel and image is <span class="math">\(S\)</span>-invariant</li>
<li>direct sum</li>
<li>if <span class="math">\(A\)</span> is an operator on <span class="math">\(E\)</span>, we are interested to express <span class="math">\(E\)</span> as direct sum of <span class="math">\(A\)</span>-invariant subspaces!</li>
</ul></li>
</ul></li>
</ul>
<h3 id="exercises-1">exercises</h3>
<ol style="list-style-type: decimal">
<li><span class="math">\(F\)</span> complete then <span class="math">\(L(E,F)\)</span> complete. the 0 of former chapter deals with continuous functions under sup norm, this one deals with linear function under the specific norm, which is certainly not the sup norm
<ul>
<li>pointwize convergence to <span class="math">\(l\)</span>, linear by <span class="math">\(\lim l_n(ax + by) = a\lim l_n (x) + b \lim l_n(y)\)</span> <code>fix me</code>, and bounded the same…?</li>
</ul></li>
<li><code>fix me: finish after this</code></li>
</ol>
<h2 id="hilbert-space">Hilbert space</h2>
<p>we use vs over <span class="math">\(C\)</span>, and assume our product is positive</p>
<ul>
<li>forms
<ul>
<li><span><span id="cross-semi-lienar"></span><span id="cross-antilinear" class="crosslink">antilinear </span></span> <span class="math">\(l(ax)=\bar{a}l(x)\)</span></li>
<li><span><span id="cross-scalar-product"></span><span id="cross-sesquilinear-form" class="crosslink">sesquilinear form </span></span> <span class="math">\(E\times E \to C:  {\langle x, y \rangle}\)</span> linear in <span class="math">\(x\)</span> and <a href="#cross-antilinear">antilinear</a> in <span class="math">\(y\)</span></li>
<li><span id="cross-hermitian" class="crosslink">hermitian</span> . <a href="#cross-scalar-product">scalar product</a> <span class="math">\(\land\)</span> <span class="math">\({\langle x,y \rangle} = \bar{{\langle y,x \rangle}}\)</span></li>
<li><span id="cross-positive-form" class="crosslink">positive form</span> hermitian <span class="math">\(\land\)</span> <span class="math">\({\langle x,x \rangle} \geq 0\)</span></li>
<li><span id="cross-positive-definite-form" class="crosslink">positive definite form</span> positive <span class="math">\(\land\)</span> <span class="math">\({\langle x,x \rangle} = 0 \Leftrightarrow x = 0\)</span></li>
<li><span id="cross-orthogonal" class="crosslink">orthogonal</span> <span class="math">\({\langle u,w \rangle} = 0\)</span></li>
<li><span id="cross-null-space" class="crosslink">null space</span> <span class="math">\(E_0\)</span> for <a href="#cross-hermitian">hermitian</a>
<ul>
<li><span class="math">\({\langle w,w \rangle} = 0 \Rightarrow w \in E_0\)</span></li>
</ul></li>
</ul></li>
<li><span id="cross-seminorm" class="crosslink">seminorm</span></li>
<li><span class="math">\(L^2\)</span>-norm is a seminorm</li>
<li><span id="cross-Schwarz-inquality" class="crosslink">Schwarz inquality</span> <span class="math">\(|{\langle u, w \rangle}| \leq |v||w|\)</span></li>
<li><span id="cross-unit-vector" class="crosslink">unit vector</span></li>
<li><span id="cross-Fourier-coefficient" class="crosslink">Fourier coefficient</span> of <span class="math">\(v\)</span> with respect <span class="math">\(w\)</span>. unique <span class="math">\(c\)</span>: <span class="math">\(&lt;v - cw, w&gt; = 0\)</span> if <span class="math">\(|w| \neq 0\)</span>
<ul>
<li><span class="math">\(v - c_1 v_1 - c_2 v_2  - \cdots - c_n v_n\)</span> perpendicular to <span class="math">\(v_i\)</span> when they are mutually perpendicular</li>
<li><span class="math">\(|w + u|^2 = |u|^2 + |w|^2\)</span> when prependicular</li>
<li><span class="math">\(|w + u|^2 + |w - u|^2 = 2|w|^2 + 2|u|^2\)</span></li>
</ul></li>
<li><span id="cross-total-family" class="crosslink">total family</span> union of finite generated space is dense in <span class="math">\(E\)</span></li>
<li><span id="cross-orthogonal" class="crosslink">orthogonal</span></li>
<li><span id="cross-orthonormal" class="crosslink">orthonormal</span></li>
<li><span id="cross-Hilbert-basis" class="crosslink">Hilbert basis</span> total and orthonormal family</li>
<li><span class="math">\(v_i\)</span> orthogonal, then <span class="math">\(|x - \sum (c_k v_k)| \leq |x - \sum(a_k v_k)|\)</span></li>
<li><span id="cross-pre-Hilbert-space" class="crosslink">pre-Hilbert space</span> vs <span class="math">\(\land\)</span> positive definite hermitian form</li>
<li><span id="cross-Hilbert-space" class="crosslink">Hilbert space</span> per-Hilbert and complete under <span class="math">\(L^2\)</span>-norm
<ul>
<li>closed subspace of Hilbert space, a point out’s min dis correspond point in it</li>
<li>theorem 1.6 closed subspace has perpendicular point!</li>
<li>exists Hilbert basis</li>
<li><span class="math">\(E = F + F^\perp\)</span></li>
<li><span id="cross-orthogonal-projection" class="crosslink">orthogonal projection</span></li>
<li>you get a point in generated space of countable closed perpendicular subspaces <span class="math">\(F_i\)</span> by projections…
<ul>
<li><span id="cross-orthogonal-decomposition" class="crosslink">orthogonal decomposition</span></li>
<li><span id="cross-Bessel-inqeulity" class="crosslink">Bessel inqeulity</span></li>
</ul></li>
</ul></li>
<li><span class="math">\(l_y = {\langle x,y \rangle}\)</span> is functional, <span class="math">\(y \to l_y\)</span> is norm-preserving, antilinear isomorphism
<ul>
<li><span class="math">\({\text{End}}(E)\)</span> operators = continuous linear map</li>
<li><span class="math">\(\text{Sesqu}(E)\)</span> continuous sesqu form
<ul>
<li><span class="math">\(\text{Herm}(E)\)</span> all continuous hermitian forms</li>
</ul></li>
<li><span class="math">\(A \to \pi_A\)</span> is norm preserving isomorphism between <span class="math">\(End(E)\)</span> and <span class="math">\(\text{Sesqu}(E)\)</span></li>
<li><span id="cross-adjoint-on-Hilbert-space" class="crosslink">adjoint on Hilbert space</span>, <span id="cross-transpose-on-Hilbert-space" class="crosslink">transpose on Hilbert space</span> <span class="math">\(&lt;Ax, y&gt; = &lt;x, A^* y&gt;\)</span>
<ul>
<li><span class="math">\((A+B)^* = A^* + B^*\)</span>, <span class="math">\(A^{**} = A\)</span>, <span class="math">\((aA)^* = \bar{a}A^*\)</span>, <span class="math">\((AB)^* = B^*A^*\)</span></li>
</ul></li>
<li>sesquilinear form <span class="math">\(\pi\)</span> then <span class="math">\(q(x) = \pi(x, x)\)</span> is quadratic form</li>
<li>complex Hilbert space, <span class="math">\({\langle Ax, x \rangle} = 0 \Rightarrow A = O\)</span>
<ul>
<li>fails in real: rotation</li>
</ul></li>
<li><span class="math">\(A = A^*\)</span> hermitian, self-adjoint</li>
</ul></li>
</ul>
<h3 id="exercises-2">exercises</h3>
<p><code>fix me</code></p>
<h2 id="the-general-integral">the general integral</h2>
<ul>
<li><span id="cross-measurable-space" class="crosslink">measurable space</span>
<ul>
<li><a href="#cross-object">object</a>. <span id="cross-measurable-set" class="crosslink">measurable set</span>s defined by <span id="cross-$\\sigma$-algebra" class="crosslink">$\\sigma$-algebra</span>
<ul>
<li>countable union and complement</li>
<li>generated <span class="math">\(\sigma\)</span> algebra
<ul>
<li><span id="cross-Borel-measurable" class="crosslink">Borel measurable</span> generated by open sets</li>
</ul></li>
</ul></li>
<li><a href="#cross-morphism">morphism</a>. <span id="cross-measurable-maps" class="crosslink">measurable maps</span> inverse of <a href="#cross-measurable-set">measurable set</a> is <a href="#cross-measurable-set">measurable set</a>
<ul>
<li>closed by composite, which means is an category</li>
<li>for <a href="#cross-Borel-measurable">Borel measurable</a>, only check for open sets is sufficient</li>
<li><em>we assume Borel measurable from now on</em></li>
<li><span class="math">\(f = (g, h)\)</span>, f <span class="math">\(\Rightarrow\)</span> <span class="math">\(g\)</span>, <span class="math">\(h\)</span>. <span class="math">\(g\)</span>, <span class="math">\(h\)</span> and every open set in <span class="math">\(Y\times W\)</span> is countable union of the product base <span class="math">\(\Rightarrow\)</span> <span class="math">\(f\)</span>
<ul>
<li>complex function <span class="math">\(\Leftrightarrow\)</span> parts</li>
<li><span class="math">\(f\)</span> is measurable to nvs, then <span class="math">\(|f|\)</span>, composite with <code>fix me</code> absolute value function</li>
</ul></li>
<li><span class="math">\(af+bg\)</span>, <span class="math">\(fg\)</span> into complex is measurable, similar for finite dimensional space</li>
<li><span class="math">\(f\)</span> is <span class="math">\(X\)</span> into <strong>metric</strong> space, and <span class="math">\(f_n\)</span> pointwize convergence to <span class="math">\(f\)</span> is measurable, then <span class="math">\(f\)</span> is</li>
<li><span id="cross-simple-map" class="crosslink">simple map</span> disjoint finite union of constant function on measurable sets
<ul>
<li><strong>finite dimensional</strong> <span class="math">\(\Leftrightarrow\)</span> pointwize limit of simple maps</li>
<li><span class="math">\(f: X\to{\mathbb{R}}^+\)</span> positive real valued map, then <span class="math">\(f\)</span> is pointwise limit of some increasing sequence of simple maps</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<ul>
<li><span id="cross-measure-space" class="crosslink">measure space</span> <span class="math">\((X, \mathcal{M}, \mu)\)</span>
<ul>
<li><a href="#cross-object">object</a> . <span id="cross-positive-measure" class="crosslink">positive measure</span>, <span class="math">\(u: \mathcal{M} \to [0, \infty]\)</span>, countably additive
<ul>
<li><span id="cross-Dirac-measure" class="crosslink">Dirac measure</span></li>
<li><span id="cross-counting-measure" class="crosslink">counting measure</span></li>
<li>closed by <span class="math">\(A_n \subset A_{n+1}\)</span>, <span class="math">\(\bigcup A_n\)</span> limit</li>
<li>closed by <span class="math">\(A_{n+1} \subset A_n\)</span>, <span class="math">\(\mu(A_i) \lt \infty\)</span>, <span class="math">\(\bigcap A_n\)</span> limit</li>
</ul></li>
<li><span id="cross-almost-everywhere" class="crosslink">almost everywhere</span></li>
<li><span id="cross-step-map" class="crosslink">step map</span> <span class="math">\({\text{St}}(\mu, E)\)</span> finite valued and finite measured
<ul>
<li>is a vector space, also closed for <span class="math">\(|f|\)</span></li>
</ul></li>
<li><span class="math">\(\sigma\)</span>-finite: countable union of finite measure sets</li>
<li><span class="math">\(\mu\)</span>-measurable: pointwise limit of step maps almost everywhere
<ul>
<li>vanish outside <span class="math">\(\sigma\)</span>-finite set</li>
<li>is a vector space. closed by continuous bilinear map product, <span class="math">\(|f|\)</span> closed, <span class="math">\(1/f\)</span> closed for <span class="math">\(f \neq 0\)</span></li>
<li><span class="math">\(\Leftrightarrow\)</span> exists <span class="math">\(\mu(Z) = 0\)</span> that <span class="math">\(f|(X-Z)\)</span> measurable, <span class="math">\(f\)</span> vanishs outside a <span class="math">\(\sigma\)</span>-finite set, and <span class="math">\(f(X-Z)\)</span> contains a countable dense set
<ul>
<li>if <span class="math">\(u\)</span> is <span class="math">\(\sigma\)</span>-finite and <span class="math">\(f\)</span> into <span class="math">\({\mathbb{C}}\)</span> then only requires <span class="math">\(f|(X-Z)\)</span> measurable!</li>
</ul></li>
<li>limit of <span class="math">\(\sigma\)</span>-measurable is <span class="math">\(\sigma\)</span>-measurable</li>
<li><em>so <span class="math">\(\sigma\)</span>-measurable is preserved under standard ops, without composition</em></li>
</ul></li>
</ul></li>
</ul>
<p>we assume that <span class="math">\((X, \mathcal{M}, \mu)\)</span> is an measured space, and <span class="math">\(E\)</span> an Banach space</p>
<ul>
<li>integral of step functions <span class="math">\(\int_X f {\text{ d}}\mu = \sum \mu(A_i)f(A_i)\)</span>
<ul>
<li><span class="math">\(\int_A f {\text{ d}}\mu = \int_X f_A {\text{ d}}\mu\)</span></li>
<li><span class="math">\(\left|\int_X f {\text{ d}}\mu\right| \leq \|f\|_1 \leq \|f\| \mu(A)\)</span>
<ul>
<li><span class="math">\(L^1\)</span>-siminorm</li>
</ul></li>
</ul></li>
<li><span class="math">\(L^1\)</span>-completion <span class="math">\({\text{St}}(\mu) \to L^1(\mu)\)</span>
<ul>
<li>this is the equivalence class of Cauchy seq of step functions that convergence under <span class="math">\(L^1\)</span> norm</li>
<li>there is <span class="math">\(L^1\)</span>-Cauchy sequence that are not pointwise convergence</li>
<li>there are pointwise convergence sequence that are not <span class="math">\(L^1\)</span>-Cauchy??</li>
<li>why we cannot use this definition using null-seq to proof? i think for me, it just means… forget this shit…</li>
</ul></li>
<li><span class="math">\(\mathcal{L}^1(\mu)\)</span> spaces has <a href="#cross-almost-everywhere">almost everywhere</a> convergence <span class="math">\(L^1\)</span>-Cauchy sequence
<ul>
<li>is a vs</li>
<li><span id="cross-fundamental-lemma-of-integration" class="crosslink">fundamental lemma of integration</span> a Cauchy seq of step maps <span class="math">\(\{f_n\}\)</span> has a <strong>subseq</strong> convergence pointwise almost everywhere, and convergence absolutely and uniformly outside any <span class="math">\(\mu(Z) &lt; \epsilon\)</span></li>
<li><span class="math">\(g_n\)</span> and <span class="math">\(h_n\)</span> Cauchy seq of step maps, convergence almost everywhere to same map
<ul>
<li><span class="math">\(\lim \int_X g_n = \lim \int_X h_n\)</span></li>
<li><span class="math">\({g_n - h_n}\)</span> is null seq</li>
</ul></li>
<li><span id="cross-integrable-map" class="crosslink">integrable map</span>s of <span class="math">\(\mathcal{L}^1(\mu)\)</span>, <span class="math">\(\int_X f {\text{ d}}\mu = \lim\int_X f_n{\text{ d}}\mu\)</span>
<ul>
<li><span class="math">\(|f|\in \mathcal{L}^1(\mu)\)</span></li>
<li><span class="math">\(|f_n|\)</span> approximate <span class="math">\(|f|\)</span></li>
<li><span class="math">\(\|f\|_1 = \lim \|f_n\|_1\)</span></li>
<li><span class="math">\(\mathcal{L}^1\)</span> is complete</li>
</ul></li>
<li>relation of <span class="math">\(\mathcal{L}^1(\mu)\)</span> and <span class="math">\(L^1(\mu)\)</span>
<ul>
<li><span class="math">\(\gamma: \mathcal{L}^1\to L^1\)</span></li>
<li>it is well defined, it is not injective</li>
<li><span class="math">\(\|f\|_1 = \|\gamma(f)\|_1\)</span></li>
<li><span class="math">\(\int_x f = \int_x \gamma(f)\)</span></li>
<li>integral on <span class="math">\(\mathcal{L}^1\)</span> is continuous linear map</li>
<li><code>fix me: show that there are integrals etc defined on $L^1$</code></li>
</ul></li>
<li>for <span class="math">\(E = {\mathbb{R}}\)</span>
<ul>
<li><span class="math">\(\sup(f, g) = \frac{1}{2}(f + g + |f-g|)\)</span> is integrable</li>
<li><span class="math">\(f = f^+ + f^-\)</span> then <span class="math">\(f\)</span> <span class="math">\(\Leftrightarrow\)</span> <span class="math">\(f^+\)</span> and <span class="math">\(f^-\)</span></li>
<li>is increasing function</li>
</ul></li>
<li>for <span class="math">\(A\in \mathcal{M}\)</span>, <span class="math">\(f_A\)</span></li>
<li><span class="math">\(\left|\int_X f {\text{ d}}\mu\right| \leq \|f\|_1 \leq \|f\| \mu(A)\)</span></li>
<li>theorem 4.1, 4.2 <code>fix me</code></li>
</ul></li>
</ul>
<p><code>fix me</code></p>
<h3 id="exercises-3">exercises</h3>
<p><code>fix me</code></p>
<h2 id="duality-and-representation-theorems">duality and representation theorems</h2>
<h2 id="some-application-of-integration">some application of integration</h2>
<h2 id="integration-on-locally-compact-spaces">integration on locally compact spaces</h2>
<h2 id="riemann-stieltjes-integral-and-measure">Riemann-Stieltjes integral and measure</h2>
<h2 id="distributions">distributions</h2>
<h2 id="integration-on-locally-compact-groups">integration on locally compact groups</h2>
<h2 id="differential-calculus">differential calculus</h2>
<h2 id="inverse-mappings-and-differential-equations">inverse mappings and differential equations</h2>
<h2 id="reference-1">reference</h2>
<ul>
<li><span id="cross-ref-analysis-real-and-functional" class="crosslink">ref-analysis-real-and-functional</span> <em>Real and Functional Analysis</em>, Serge Lang
<ul>
<li><span id="cross-ref-rf-class" class="crosslink">ref-rf-class</span> solutions for above book <a href="http://www.math.wustl.edu/~victor/classes/ma5051/">http://www.math.wustl.edu/~victor/classes/ma5051/</a></li>
</ul></li>
<li><span id="cross-ref-analysis-tao" class="crosslink">ref-analysis-tao</span> <em>An Epsilon of Room</em>
<ul>
<li><strong>very intuitive</strong>!!!</li>
</ul></li>
</ul>
<h1 id="statistics">statistics</h1>
<h2 id="probability">probability</h2>
<h3 id="formal-definition-in-measure-theory">formal definition in measure theory</h3>
<p><em>i have not read any books about this, but you can get much insight from wikipedia articles</em></p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Random_variable#Measure-theoretic_definition">http://en.wikipedia.org/wiki/Random_variable#Measure-theoretic_definition</a></li>
<li>probability space - measured space with total measure 1</li>
<li>random variable - function from <strong>measured space</strong> to <strong>measurable space</strong>, thus the latter measurable space can get an measure from the preimage
<ul>
<li>so what is a cdf? it is the measure function, so actually <code>R</code> can have various measures</li>
<li>so pdf is not in favour, because it is not a good measure, it only coresponds to <strong>differentiable measure</strong></li>
</ul></li>
<li>conditional - induced normalized measure for subspace</li>
<li><strong>fix me</strong> the conditional and join random variables is not well understood in the perspective now…</li>
</ul>
<h3 id="probability-1">probability</h3>
<ul>
<li>sample space, point: outcome, event, subset: events</li>
<li>probability
<ul>
<li>sigma-algebra, measurable space</li>
<li>non-neg</li>
<li>unity</li>
<li>sigma-additivity</li>
</ul></li>
<li>what it means?
<ul>
<li>freq</li>
<li>Bayesian</li>
<li>in my opinion it do not matters… the model is there, it is just a matter of calculation</li>
<li>but it do lead to different methods</li>
</ul></li>
<li><code>A_n -&gt; A =&gt; P(A_n) -&gt; P(A)</code>: using def, and measure, and properties of limits
<ul>
<li>review: this is the proposition 1 in the positive measure section</li>
</ul></li>
<li><code>P(A|B) = P(AB) / P(B)</code>
<ul>
<li>is this kind of submeasure?</li>
</ul></li>
<li>event independent <code>P(AB) = P(A)P(B)</code>
<ul>
<li><code>P(A|B) = P(A)</code></li>
</ul></li>
<li>Bayes’ theorem <code>P(B) = Sum( P(B|A_i)P(A_i) )</code> is just set ops + simple probobility
<ul>
<li><code>P(A_i|B) = P(B|A_i)P(A_i) / P(B)</code></li>
<li><code>P(A_i)</code> the prior probability of <code>A</code></li>
<li><code>P(A_i|B)</code> the posterior probability of <code>A</code></li>
</ul></li>
</ul>
<h3 id="random-variables">random variables</h3>
<p><em>they are functions on a measure space to R, and you get a measure on R</em></p>
<p><em>the so called multivarance is just linear algebra + rv</em></p>
<p><em>if you do not consider the distribution, then what random <strong>variable</strong> means is that it is normal variables, but you can add them, try to picture youself <code>X-bar/n</code></em></p>
<p><em>join dis is defined by <strong>P</strong>, consider youself the join dis of <code>X</code> and <code>1-X</code>? you cannot picture this! but it do has a cpf! it start at the diag from 0 to 1, but is is not differentable! (what is 2 differentable?)</em></p>
<ul>
<li>random variable <code>X</code>: space to <code>R</code></li>
<li><code>P(X in A) = P(X^-1(A))</code></li>
<li><code>P(X = x) = P(X^-1(x))</code></li>
<li>cumulative distribution function <code>F_X(x): R -&gt; [0, 1] = P(X &lt;= x)</code>
<ul>
<li>theorem 2.7: CDF determines the probability structure
<ul>
<li>review: the induced measure is same! not the rv! for exmaple. <code>f_1 = x</code> and <code>f_2 = -x</code> for a normal</li>
<li>so we must remember that, the function that induced the random variable is always essential</li>
</ul></li>
<li>theorem 2.8: <code>R -&gt; [0,1]</code> is cdf &lt;=&gt;
<ul>
<li>non-decreasing</li>
<li><code>F(-inf) = 0</code> and <code>F(inf) = 1</code></li>
<li><code>F(x) = lim_{y -&gt; x, y &gt; x} F(y)</code>
<ul>
<li>review: this actually concerned with that cdf is defined <code>P(X &lt;= x)</code>, it is a asymetry</li>
</ul></li>
</ul></li>
<li><code>P(X = x) = F(x) - F(x-)</code></li>
<li><code>P(x &lt; X &lt;= y) = F(y) - F(x)</code></li>
</ul></li>
<li>inverse cdf <code>F^-1(q) = inf(x: F(x) &gt; q)</code>
<ul>
<li>if <code>F</code> is strictly increasing and continuous, then it is just function inverse</li>
<li>a simple example: try to picture the inverse of a normal</li>
</ul></li>
<li>probability function <code>f_X(x) = P(X = x)</code></li>
<li>probability density functiion: <code>F_X(x) = integral from -inf to x f_X(t) dt</code>
<ul>
<li>if such a function exists, <code>X</code> is called continuous</li>
<li><code>F</code> is differentiable</li>
<li><code>P(X = x) = 0</code>, this is necessory, because you can using integral!!!</li>
<li>pdf can be unbounded</li>
<li>review: a pdf exists relays on the underline measure space to is differentiable, so it concerns about linearity, so it concerns if it is <code>R</code> or something</li>
</ul></li>
<li>join pf and join cpf
<ul>
<li>consider multivarance normal, so two join has far more different shapes, it is what it means to have a sample space, but when it is independent, we can see it is uniquely defined</li>
<li>independent always means factorable</li>
</ul></li>
<li>pdf of <code>(X, Y)</code></li>
<li>marginal probability function <code>f_X(x)</code>, <code>f_Y(y)</code></li>
<li>marginal cdf <code>F_X</code>, <code>F_Y</code></li>
<li>marginal density <code>f_X(x) = integral f(x, y) dy</code></li>
<li><code>X</code>, <code>Y</code> independent: <code>forall A, B: P(X in A, Y in B) = P(X in A)P(Y in B)</code>
<ul>
<li>for differentialbe &lt;=&gt; <code>f_X,Y = f_X f_Y</code></li>
<li><em>independence of random variable means we can factor the sample space, and reguard the two variable only dependent on one subspace!</em></li>
</ul></li>
<li>conditional pf: <code>f_{X|Y}(x|y) = P(X = x| Y = y)</code> if <code>P(Y = y) &gt; 0</code></li>
<li>conditinal pdf: <code>f_{X|Y}(x|y) = f_{X|Y}(x|y) / f_Y(y)</code>
<ul>
<li><code>P(X in A| Y = y) = integral_A f</code></li>
</ul></li>
<li>tranform random variable, or variables =&gt; variable
<ul>
<li>actually it is always about calculation of a pdf or cdf</li>
</ul></li>
<li>iid sample</li>
</ul>
<h3 id="functional">functional</h3>
<p><em>functionals from the function space to <code>R</code></em></p>
<ul>
<li>median <code>F^-1(1/2)</code></li>
<li><code>E(X) = integral x dF(x) = EX = mu_X</code>
<ul>
<li><em>if you have two variable, you need two integral. thinking the num of rv as the dimension!!! picture youself a multivariance nomral</em></li>
<li>well defined: <code>integral |x| dF(x) &lt; inf</code></li>
<li><code>E(r(X)) = integral r(x) dF(x)</code></li>
<li><code>E(Sum(a_i X_i)) = Sum(a_i E(X_i))</code>
<ul>
<li>dirrectly proofed from lineary of integral, but I need better real analysis</li>
</ul></li>
<li><code>X_i</code> independent =&gt; <code>E(Prod(X_i)) = Prod(X_i)</code>
<ul>
<li>think of integral when id, the integral will be independent</li>
</ul></li>
<li><code>E(a'X) = a'mu</code>, <code>E(AX) = A mu</code></li>
</ul></li>
<li>k-th moment <code>E(X^k)</code>
<ul>
<li>well defined for k</li>
<li>k-th moment exists =&gt; j &lt; k exists</li>
</ul></li>
<li>variance <code>sigma^2 = E(X-mu)^2 = V(X)</code>
<ul>
<li><em>think of a dis, and the mu is a y = mu thing, it will be a lot easy!</em></li>
<li>standard deviation <code>sd(X) = sqrt(V(X)) = sigma</code></li>
<li><code>V(X) = E(X^2) - mu^2</code></li>
<li><code>V(aX+b) = a^2V(X)</code>, obvious when you thinking the line</li>
<li><code>X_i</code> independent =&gt; <code>V(Sum(a_i X_i)) = Sum(a_i^2     V(X_i))</code>, use the same method in expectation</li>
</ul></li>
<li>skewness <code>k = E(X - mu)^3/sigma^3</code></li>
<li>covariance <code>Cov(X, Y) = E((X - mu_X)(Y - mu_Y))</code>
<ul>
<li>corelation <code>rho = Cov(X, Y) / sigma_X sigma_Y</code></li>
<li><code>Cov(X, Y) = E(XY) - E(X)E(Y)</code>
<ul>
<li><em>use the two var thing!!!</em></li>
</ul></li>
<li><code>-1 &lt; rho &lt; 1</code>, expand the integral</li>
<li>when <code>X</code> and <code>Y</code> is linear or independent</li>
<li><code>V(X + Y) = V(X) + V(Y) + 2Cov(X, Y)</code>
<ul>
<li><code>V(Sum(a_i X_i)) = Sum(a_i^2 V(X_1)) + 2 SumSum a_i a_j Cov(X_i, X_j)</code></li>
</ul></li>
<li>variance-covariance matrix <code>Pi</code></li>
<li><code>V(a'X) = a' Pi a</code>, <code>V(AX) = A Pi A'</code></li>
</ul></li>
<li>conditional exception <code>E(X|Y = y) = integral x f dx</code>, <code>E(r(X,Y)| Y = y) = integral r(x, y) f dx</code> is a random variable of <code>y</code>
<ul>
<li>law of total exception: <code>E(E(r(X,Y)| X)) = E(r(X,Y))</code></li>
<li><em>this is a funcional that F(R^2) -&gt; F(R)</em></li>
</ul></li>
<li>conditional variance <code>V(Y|X = x) = integral (y - mu(x))^2 f(y|x) dy</code>
<ul>
<li>law of total: <code>V(Y) = EV(Y|X) + VE(Y|X)</code>
<ul>
<li><em>proof?</em></li>
</ul></li>
</ul></li>
<li>moment generating functions, Laplace transform <code>chi_X(t) : R -&gt; R = E(e^(tX))</code>
<ul>
<li><strong>fix me</strong></li>
</ul></li>
<li><code>X_i</code> idd
<ul>
<li>sample mean <code>X_n-bar = Sum(X_n) / n</code></li>
<li>sample variance <code>S_n^2 = Sum((X_i - X_n-bar)^2) / (n - 1)</code></li>
<li><code>E(X_n-bar) = mu</code></li>
<li><code>V(X_n-bar) = sigma^2 / n</code></li>
<li><code>E(S^2) = sigma^2</code>
<ul>
<li>it means it is unbiased</li>
<li><em>really cmompute this thing! it is easy!</em></li>
</ul></li>
</ul></li>
</ul>
<h3 id="useful-examples-of-rv">useful examples of rv</h3>
<ul>
<li>multivarance normal <strong>fix me</strong></li>
</ul>
<h3 id="inequalities">inequalities</h3>
<ul>
<li>Markov’s: <code>X</code>, <code>t</code> &gt; 0 =&gt; <code>P(X &gt; t) &lt;= E(X) / t</code></li>
<li>Chebyshev’s <code>P(|X-mu| &gt;= t) &lt;= sigma^2 / t^2</code> and <code>P(|(X-mu)/sigma| &gt;= k) &lt;= 1/k^2</code></li>
<li>Hoeffding’s <strong>fix me</strong></li>
<li>Mill’s</li>
<li>Cauchy-Schwartz <code>E|XY| &lt;= sqrt(E(X^2)E(Y^2))</code></li>
<li>Jensen’s <code>g</code> convex =&gt; <code>Eg(X) &gt;= g(EX)</code></li>
</ul>
<h3 id="convergence-of-rv">convergence of rv</h3>
<p><em>they are just normal convergence in functional analysis</em></p>
<p><a href="http://en.wikipedia.org/wiki/Convergence_of_random_variables">http://en.wikipedia.org/wiki/Convergence_of_random_variables</a></p>
<ul>
<li>p: converges in <strong>probability</strong> <code>forall e, P(|X_n - X| &gt; e) -&gt; 0 as n -&gt; 0</code>
<ul>
<li>add, mul, map</li>
</ul></li>
<li>d: converges in <strong>distribution</strong> <code>lim F_n(t) -&gt; F(t)</code>, pointwize
<ul>
<li>const add, const mul, map</li>
</ul></li>
<li>qm: converges in <strong>quadratic mean</strong> <code>E(X_n - X)^2 -&gt; 0</code>
<ul>
<li>add</li>
</ul></li>
<li>qm =&gt; p =&gt; d
<ul>
<li>special case: point mass d &lt;=&gt; p</li>
</ul></li>
<li>weak law of large numbers: <code>X_n-bar -P-&gt; mu</code></li>
<li>clt: <code>Z_n = (X_n-bar - mu)/sqrt(V(X_n-bar)) = sqrt(n)(X_n-bar - mu)/sigma -d-&gt; N(0, 1)</code>
<ul>
<li>variance -&gt; sample variance is ok</li>
<li>multivariate version <code>sqrt(n)(X-bar - mu) -d-&gt; N(0, Pi)</code></li>
<li>delta method: <code>sqrt(n)(Y_n - mu) / sigma -d-&gt; N(0, 1)</code> &amp;&amp; <code>g</code> differentiable and <code>g'(mu) != 0</code> =&gt; <code>g(Y_n) -d-&gt; N(g(mu)</code>, <code>g'(mu)^2 * sigma^2 / n)</code>
<ul>
<li>multivariate delta method <strong>fix me</strong></li>
</ul></li>
</ul></li>
</ul>
<h2 id="stochastic-process">stochastic process</h2>
<ul>
<li>stochastic process, state space, index set</li>
<li>Markov chain <code>f(x_1,...,x_n) = f(x_1)f(x_2|x_1)...</code>
<ul>
<li>qestions
<ul>
<li>when settle down</li>
<li>parameter estimate</li>
<li>how to construct to converge</li>
</ul></li>
</ul></li>
<li>homogeneous
<ul>
<li>transition probabilities, transition matrix</li>
<li><code>p_ij(n)</code> n-step transition probabilities
<ul>
<li><code>p_ij(m + n) = Sum( p_ik(m) + p_kj(n) )</code></li>
</ul></li>
<li>simulation, <code>mu_0</code> initial distribution
<ul>
<li><code>mu_n = m_0 P^n</code></li>
</ul></li>
<li>reaches, communicate (is a equvilent)</li>
<li>irreducible, closed states, absorbing state</li>
<li>recurrent = persistent, transient
<ul>
<li>recurrent &lt;=&gt; <code>Sum (p_ii (n)) = Inf</code></li>
<li>communicate preserve recurrent and transient</li>
<li>finite Markov chain must has one recurrent state, if it is irreducible, all state is recurrent (simple)</li>
</ul></li>
<li>decomposition theorem: state space <code>X = X_T \/ X_i</code>, <code>X_T</code> is trans, <code>X_i</code> is irreducible recurrent (just use partition)</li>
<li>recurrent time (a rv): <code>T_ij = min{n | X_n = j}</code>
<ul>
<li>mean recurrent time <code>m_i = E(T_ii) = Sum(n f_ii(n))</code></li>
</ul></li>
<li>null, positive recurrent state
<ul>
<li>null -&gt; <code>p_ii(n) -&gt; 0</code></li>
<li>finite state -&gt; all positive</li>
</ul></li>
<li>period <code>d = gcd{n|p_ii(n) &gt; 0}</code>
<ul>
<li>periodic: <code>d &gt; 1</code></li>
<li>aperiodic: <code>d = 1</code></li>
</ul></li>
<li>ergodic = recurrent &amp; positive &amp; aperiodic (state | chain)
<ul>
<li>e.g. <em>23.28 Example</em></li>
</ul></li>
<li>stationary = invariant
<ul>
<li>stationary not necessory to converge!!!</li>
</ul></li>
<li>limitint distribution <code>P^n -&gt; [pi; pi; pi; ...]</code>, here <code>pi</code> is a vector!!!</li>
<li>irreducible, ergogic Markov chain has unique stationary distribution <code>pi</code>, limiting distribution is also <code>pi</code>, <code>g</code> bounded =&gt; <code>lim_N Sum(g(X_n))/N -&gt; E_pi(g) = Sum(g(j) pi)</code></li>
<li>detailed balance <code>pi_i p_ij = p_ji pi_j</code>
<ul>
<li>detailed balance =&gt; stationary distribution</li>
</ul></li>
<li><strong>fix me</strong> 23.31</li>
</ul></li>
<li>Possion processes <strong>fix me</strong></li>
</ul>
<h2 id="statistical-inference">statistical inference</h2>
<p><em>statistical inference is not solving equtions, because you have noise, you cannot get exact input/output, and so nomrally your knowns is not the degree of freedom of the system!!! and you do not solve exactly!!! they are not same problem at all!!!</em></p>
<h3 id="statistical-inference-1">statistical inference</h3>
<p><em>theory of inference</em></p>
<ul>
<li>kinds of inference model: given <code>X_i</code> the sample rv
<ul>
<li>non-parametric model
<ul>
<li><code>F</code></li>
<li><code>E(X)</code> - this is of course simpler, because we applied a very concentrating function</li>
<li>…</li>
</ul></li>
<li>parametric model
<ul>
<li><code>paramemters</code> - same as <code>F</code>, because we have a smaller search space for <code>F</code> for we have <strong>constrains</strong>, so we have a function to map parameters to <code>F</code>s</li>
<li>sometimes we estimate functional of estimators…, mostly <code>E</code> and <code>V</code></li>
</ul></li>
</ul></li>
<li>statistical model, parametric model, parameter space, nuisance parameters</li>
<li>predictor = regressor = feature = independent variable, outcome = response = dependent v</li>
<li>parameter regression model, nonparametric regression model (infinite-dim regression), prediction, classification, regression = curve estimation</li>
<li>freq inference, Bayesian inference</li>
<li>point estimation <code>theta_n-head = g(X_1,...,X_n)</code> for some <code>g</code> is a random variable
<ul>
<li><code>bias(theta_n-head) = E_theta(theta_n-head) - theta</code>, unbiased
<ul>
<li>this is a scalar, it is a statistical functional applied to a rv, so a saclar!!!</li>
</ul></li>
<li>consistent <code>-p-&gt;</code></li>
<li>sample distribution</li>
<li>standard error <code>se = sqrt(V(theta_n-head))</code> is applied value! again a salar!</li>
<li>ese <code>se-head</code></li>
<li>6.8 - see a worked out example for Bernoulli!
<ul>
<li>when calculating <code>V(p^n)</code>, use <code>X^2</code> and independence expansion!</li>
</ul></li>
<li><code>MSE = E(theta^_n - theta)^2 = bias^2 + V_theta</code>
<ul>
<li>this is not the variance of <code>theta^_n</code>! this is only true when you are unbias!!!</li>
</ul></li>
<li>e.g
<ul>
<li>parameter</li>
<li>cdf</li>
<li>pdf</li>
</ul></li>
<li><code>bias -&gt; 0 &amp;&amp; se -&gt; 0 =&gt; MSE -&gt; 0 =&gt; -pm-&gt; =&gt; -p-&gt;</code></li>
<li>asymptotically normal <code>(theta_n-head - theta) / se -&gt; N(0, 1)</code></li>
</ul></li>
<li><code>1-a</code> confidence interval <code>P(theta in C_n) &gt;= 1-a</code>, <code>C_n</code> is<code>(a(X_1,...,X_n), b(...))</code> is a <strong>random variable</strong>!!
<ul>
<li>confidence set: when multivariance</li>
<li>normal-based confidence interval <em>p94</em>
<ul>
<li>comparing 6.17 and 6.15, notice that normal-based only has large approximately correct coverage</li>
</ul></li>
</ul></li>
<li>hypothesis testing</li>
</ul>
<h3 id="nonparameter-mentods-for-cdf-and-functionals">nonparameter mentods for cdf and functionals</h3>
<p><em>I think we have enough error terms to do this! namely the convergence and bias!</em></p>
<ul>
<li>empirical distribution function <code>F_n-head(x)</code> it is <code>R -&gt; F(R)</code>, given a <code>x</code> it has a estimation of the value at this <code>x</code>
<ul>
<li>at <code>x</code>
<ul>
<li><code>E(F-head) = F(x)</code>, is unbiased</li>
<li><code>MSE = V(F-head) = F(x)(1-F(x)) / n</code></li>
<li><code>F_n-head(x) -P-&gt; F(x)</code>, it is consistant</li>
</ul></li>
<li><code>sup_x |F_n-head(x) - F(x)| -P-&gt; 0</code>
<ul>
<li><code>F^_n</code> give the function space a measure, and sup translate this measure again into scalar, and it is porobility limit to 0
<ul>
<li>DKW inequality <strong>fix me</strong></li>
</ul></li>
<li>confidence interval based on DKW</li>
</ul></li>
</ul></li>
<li>plug-in estimator of statistical functional <code>T(F)</code>: <code>theta_n-head = T(F_n-head)</code>, a functional is takes a rv to value, then you plugin to get a rv again!!!
<ul>
<li>lienar functional <code>T(F) = integral r(x) d F(x)</code>, <code>T</code> is linear in arguments!</li>
<li>plug-in estimator for linear funtional <code>T(F_n-head) = Sum(r(X_i)) / n</code> is a rv!</li>
<li>and we want <code>se</code> for this rv…</li>
<li>in many cases… <code>T(F_n-head) ~ N(T(F), se-head^2)</code>, means that we have a good enough estimator! and how to understand right??? you should divide to the left youself!!!</li>
<li>then <code>1-a</code> ci is <code>T(F_n-head) +- z_{a/2} se-head</code></li>
<li>e.g. it is just crazy… everything is rv!
<ul>
<li>mean - estimator, se-estimator, confidence interval</li>
<li>variance - plugin, sample variance <code>S^2_n</code></li>
<li>skewness</li>
<li>correlation - sample corelation</li>
<li><em>7.15</em></li>
</ul></li>
<li>in paramter model, we has formula for errors, but in nonparamter model, we mostly use bootstrap method</li>
</ul></li>
</ul>
<h3 id="bootstrap-method">bootstrap method</h3>
<p><em>in essence, bootstrap is just like plugin methods</em></p>
<ul>
<li>step
<ol style="list-style-type: decimal">
<li>estimate <code>V_F(T_n)</code> by <code>V_F^(T_n)</code>: if we can stop here, it is just plugin method</li>
<li>approximate <code>V_F^(T_n)</code> by simulation</li>
</ol></li>
<li>illu
<ul>
<li>real world <code>F</code> =&gt; <code>X_i</code> =&gt; <code>T_n</code></li>
<li>bootstrap world <code>F^_n</code> =&gt; <code>X*_i</code> =&gt; <code>T*_n</code></li>
</ul></li>
</ul>
<p><strong>fix me</strong></p>
<h3 id="parametric-inference">parametric inference</h3>
<p><em>if the world is a determined world, there is no noise at all, noise exists, is because our model is problamic or there is other things, but we think them as random</em></p>
<ul>
<li>the method of moments, assume <code>theta = (theta_1,..., theta_k)</code>
<ul>
<li>moment <code>a_j = a_j(theta) = integral x^j d F_theta(x)</code>, note that it is an function of theta, because we are having unknown theta</li>
<li>sample moment <code>a_j-head = Sum(X_i^j) / n</code></li>
<li>method: <code>forall j in 1 -&gt; k: a_(theta_n-head) = a_j-head</code>, it has <code>k</code> unknown of rvs, and we can solve for to get the estimator</li>
<li>properties
<ul>
<li>exits with probability tending 1</li>
<li>consistent</li>
<li>asympototically normal</li>
</ul></li>
<li><strong>fix me</strong> not well understood</li>
</ul></li>
<li>maximum likelihood method
<ul>
<li><em>most of the things bellow is from information theory!!!! so read them when have time!!!</em></li>
<li>likelihood function <code>L_n(theta) = Prod(f(X_i; theta))</code>, log-likelihood funtion <code>l_n(theta) = log(L_n(theta))</code>. give a param, get a rv</li>
<li>method: the thet a maximaze it! using derivative! you get an estimator!</li>
<li>multivar: we need global maxima, can use partial to find</li>
<li>properties (under certain regularity conditions of the model, rf <a href="http://en.wikipedia.org/wiki/Maximum_likelihood">http://en.wikipedia.org/wiki/Maximum_likelihood</a>)
<ul>
<li>consistent
<ul>
<li>Kullback-Leibler distance, information gain</li>
<li>first proof <code>M_n</code> converge to <code>-D(theta*, theta)</code>, if convergence is uniform over <code>theta</code>, then we can proof <code>theta^_n -p-&gt; theta*</code></li>
</ul></li>
<li>equivariant <code>g(theta)</code></li>
<li>asymptotically normal
<ul>
<li>score function <code>s(X;theta) = &amp; log f(X; theta) / &amp; theta</code></li>
<li>Fisher information <code>I_n(theta) = Sum( V_theta(s(X_i; theta)) )</code></li>
<li><code>I_n(theata) = nI(theta)</code></li>
<li><code>I(theta) = E_theta(-s')</code></li>
<li><code>se = sqrt(1/I_n(theta))</code></li>
<li><code>se^</code></li>
<li><code>(theta^_n - theta) /  se^ -d-&gt; N(0, 1)</code></li>
<li>asymptotic confidence interval</li>
</ul></li>
<li>asymptotically optimal: for large example, has smallest variance
<ul>
<li>see exercise 2</li>
</ul></li>
<li>delta method
<ul>
<li>the distribution is also equivariant, so interval</li>
</ul></li>
<li>approximately the Bayes estimator</li>
</ul></li>
<li>multiparameter method <strong>fix me</strong></li>
<li>parametric bootstrap method</li>
<li>numerical methods
<ul>
<li>Newton-Raphson</li>
<li>EM algorithm
<ul>
<li>hidden variable</li>
<li>maxiture of two normals</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="hypothesis-testing">hypothesis testing</h3>
<ul>
<li>we patition the parameter space into <code>Theata_0</code> and <code>Theata_1</code></li>
<li><code>H_0: theta in Theta_0</code> null hypothesis, and alternative hypothesis</li>
<li>rejection region <code>R</code>, <code>X</code> be a rv and <code>R &lt; Dom(X)</code>, we calculate a rv, and see if we reject the null hypothesis
<ul>
<li>it is normally form <code>R = {x: T(x) &gt; c}</code></li>
<li>test statistic, critical value</li>
</ul></li>
<li>type 1, 2 error</li>
<li>power function, size, level</li>
<li>simple hypothesis, composite hypothesis, two-sided test, one-sided test</li>
<li>Wald test <strong>see book</strong></li>
<li>p-value = <code>inf {a: T(X^n) in R_a}</code>, smallest level we can reject <code>H_0</code>
<ul>
<li>large p-value can occur in two reason: true or test has low power!</li>
</ul></li>
<li><strong>fix me</strong></li>
</ul>
<h3 id="bayesian-inference">Bayesian inference</h3>
<ul>
<li>Bayes theorem <code>f(theta|x) =   f(x|theta)f(theta) / integral f(x|theta) f(theta) d theta</code></li>
<li><code>f(theta|x^n) = L_n(theta)f(theta) / c_n</code></li>
<li>conjugate with model</li>
<li><strong>fix me</strong></li>
<li>what prior to use?
<ul>
<li>..</li>
</ul></li>
<li><strong>fix me</strong></li>
</ul>
<h3 id="dicision-theory">dicision theory</h3>
<p><em>how to? is it not just calculate the estimated error?</em></p>
<ul>
<li>how to choose estimator: decision theory</li>
<li>decision rule = estimator, action = values of estimator</li>
<li>loss function</li>
<li>risk <code>R(theta, theta-head)</code>
<ul>
<li>e.g. when you are using squared error… the risk is just mse!!!</li>
<li>maximum risk <code>R-bar(theta-head)</code></li>
<li>Bayes risk <code>r(f, theta-head)</code></li>
</ul></li>
<li>Bayes rule, minimax ruleok</li>
<li><strong>fix me</strong></li>
</ul>
<h2 id="models-and-methods">models and methods</h2>
<h3 id="linear-and-logistic-regression">linear and logistic regression</h3>
<ul>
<li>regression fuction <code>r(x) = b_0 + b_1 x</code></li>
<li>assuming <code>V(e_i|X = x) = sigma^2</code> do not depend on <code>x</code></li>
<li><code>Y_i = b_0 + b_1 X_i + e_i</code>, <code>E(e_i|X_i) = 0</code>
<ul>
<li><code>sigma</code> is also a paramter of the model!</li>
<li>fitted line <code>r-head(x) = b_0-head + b_1-head x</code></li>
<li>fitted values <code>Y_i-head = r-head(X_i)</code></li>
<li>residuals <code>e_i-head = Y_i - Y_i-head</code></li>
<li>residual sums of squares <code>RSS = Sum ( e_i-head ^2 )</code></li>
<li>least square estimates: minimize rss, calculate them using dervi!
<ul>
<li><code>b_1-head = Sum( (X_i - X_n-bar)(Y_i - Y_n-bar) ) / Sum( (X_n - X_n-bar)^2 )</code></li>
<li><code>b_0-head = Y_n-head - b_1-head X_n-bar</code></li>
<li><code>sigma^2-head = RSS / (n - 2)</code></li>
<li><code>E(b-head|X^n) = (b_0; b_1)</code> this is a constant function of <code>X^n</code></li>
<li><code>V(b-head|X^n) =</code> see the book, this means if you pick <code>x</code>s too close, you will have a very bad estimate</li>
<li><code>se-head(b_0|X^n)</code> and <code>se-head(b_1|X^n)</code></li>
<li>consistant</li>
<li>asymptotic normality</li>
<li>approximate <code>1-a</code> interval is <strong>see book</strong></li>
<li>Wald test</li>
</ul></li>
<li>under normal assumption, lse is mle</li>
<li>prediction interval <strong>fix me</strong></li>
<li>multiple regression
<ul>
<li><em>the model assumed when we know we are sampling from independent <code>x</code>s!!!!</em></li>
</ul></li>
<li>model selection, overfitting, underfitting
<ul>
<li>prediction risk, training error</li>
<li><code>C_p</code> statistic</li>
<li><strong>fix me</strong></li>
</ul></li>
</ul></li>
<li>logistic regression</li>
</ul>
<h3 id="multivariate-models">multivariate models</h3>
<h3 id="inference-about-independence">inference about independence</h3>
<h3 id="causal-inference">causal inference</h3>
<h3 id="directed-graphs">directed graphs</h3>
<h3 id="undirected-graphs">undirected graphs</h3>
<h3 id="log-linear">log-linear</h3>
<h3 id="nonparametric-curve-estimation">nonparametric curve estimation</h3>
<h3 id="smoothing-using-orthogonal-functions">smoothing using orthogonal functions</h3>
<h3 id="classification">classification</h3>
<ul>
<li>classification = pattern recognition
<ul>
<li>the estimation process is learning!</li>
</ul></li>
<li>input <code>X_i = (X_i1,..., X_id) in R^d</code> is a n number of d-dim input, find <code>h(R^d) -&gt;</code></li>
<li>true error rate <code>L(h) = P(h(X) != Y)</code></li>
<li>eer <code>L_n-head(h) = Sum(I(h(X_i) != Y_i)) / n</code></li>
<li>regression function <code>r(x) = P(Y = 1| X = x)</code>
<ul>
<li><em>it is a probability, because there might be other DOF in the model!!!</em></li>
</ul></li>
<li>Bayes classification rule <code>h* = 1 if r(x) &gt; 1/2</code></li>
<li>multi version <code>h(x) = argmax_k P(Y = k|X = x)</code>
<ul>
<li><code>P(Y = k|X = x) = f_k(x)pi_k / Sum( f_i(x)pi_i )</code></li>
<li><code>pi_i = P(Y = i)</code>, <code>f_i(x) = f(x|Y = i)</code></li>
</ul></li>
<li>ways?
<ul>
<li>empirical risk mini</li>
<li>regression</li>
<li>density estimation</li>
</ul></li>
<li>Gaussian classifiers
<ul>
<li>assume both are multivariate Gaussian <strong>see book</strong></li>
<li><code>h*(x) = argmax_k( -1/2*log|Pi_k| - 1/2*(x-mu_k)'Pi_k^-1(x-mu_k) + log pi_k )</code></li>
<li>sample esimates</li>
<li>qda</li>
<li>simplification when <code>Pi_1 = Pi_0</code> <strong>fix me</strong>, lda</li>
<li>Fisher lienar discrimination</li>
</ul></li>
<li>linear regression: model the <code>r(x)</code> using a linear function!!!
<ul>
<li>relationship logi stic and lda
<ul>
<li>parameters estimation!
<ul>
<li>lr: discriminative learning</li>
<li>lda: generative learning</li>
</ul></li>
</ul></li>
</ul></li>
<li>density estimation and naive Bayes</li>
</ul>
<h3 id="simulation-methods">simulation methods</h3>
<ul>
<li>Monte Carlo integration</li>
<li>Metropolis-Hastings algorithm</li>
<li>Gibbs sampling</li>
</ul>
<h2 id="references-5">references</h2>
<ul>
<li><span id="cross-ref-stat-all" class="crosslink">ref-stat-all</span> <em>All of Statistics</em></li>
</ul>
<h1 id="information-theory">information theory</h1>
<p>from the book <em>Elements of Information Theory</em></p>
<h2 id="preview">preview</h2>
<ul>
<li>entropy of rv <code>H(X) = -Sum(p(x) lg p(x))</code></li>
<li>mutual information <code>I(X;Y) = H(X) - H(X|Y) = Sum(p(x, y) lg(p(x, y)/p(x)p(y)))</code></li>
<li>communication channel, probability transition matrix <code>p(y|x)</code>
<ul>
<li>capacity <code>C = max_{p(x)} I(X;Y)</code></li>
<li>e.g. noisy four-symbol channel</li>
</ul></li>
<li>relative entropy <code>D(p||q)  = Sum(p(x) lg (p(x)/q(x)))</code></li>
</ul>
<h2 id="basics">basics</h2>
<ul>
<li>conditional entropy</li>
<li>chain rule</li>
</ul>
<h1 id="mathematical-optimization">mathematical optimization</h1>
<p>from <em>Convex Optimization</em> slides by Stephen Boyd, Wikipedia, etc.</p>
<h2 id="refs">refs</h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Mathematical_optimization">http://en.wikipedia.org/wiki/Mathematical_optimization</a></li>
<li><a href="http://en.wikipedia.org/wiki/Hessian_matrix">http://en.wikipedia.org/wiki/Hessian_matrix</a></li>
<li>maximum likelihood for point esitimation… the <span class="math">\(f\)</span> in it is the pdf… so it is resonable to assume the maximum… but in nn, we do not have this shit… and in linear regression, we have <strong>conditional likelihood</strong></li>
</ul>
<h2 id="ideas">ideas</h2>
<ul>
<li>what about mix them?</li>
<li>what about start multi place, and discard on the way?</li>
</ul>
<h2 id="defs">defs</h2>
<ul>
<li>mathematical optimization problems: <span class="math">\(max\)</span>
<ul>
<li>maybe we should say that “computational” but not “symbolic”</li>
</ul></li>
<li>objective function = cost function = loss function</li>
<li>order of approximation: order of magnitude of the error is <span class="math">\(O\left(x^{n+1}\right)\)</span>
<ul>
<li>in suitable case, expand by Taylor is ok</li>
</ul></li>
</ul>
<h2 id="methods">methods</h2>
<h3 id="nonlinear-programming">nonlinear programming</h3>
<p><span class="math">\[y = f(x + \Delta x) \approx f(x) + J(x)\Delta x + \frac{1}{2} \Delta x ^T H(x) \Delta x\]</span></p>
<!--- should go to calculus one day --->

<p>differ by how to eval Hessian, gradients</p>
<ul>
<li>Newton’s method: eval the Hessian, ie, find zero in the driv</li>
<li>methods evaluate gradients or approximate gradients
<ul>
<li>quzsi-Newton
<ul>
<li>L-BFGS</li>
</ul></li>
<li>gradient descent</li>
<li>conjugate gradients</li>
<li>variable metric methods</li>
</ul></li>
</ul>
<h2 id="references-6">references</h2>
<h1 id="problem-solving">problem solving</h1>
<h2 id="pages">pages</h2>
<ul>
<li><a href="http://terrytao.wordpress.com/career-advice/solving-mathematical-problems/">http://terrytao.wordpress.com/career-advice/solving-mathematical-problems/</a></li>
<li><a href="http://terrytao.wordpress.com/career-advice/there%E2%80%99s-more-to-mathematics-than-grades-and-exams-and-methods/">http://terrytao.wordpress.com/career-advice/there%E2%80%99s-more-to-mathematics-than-grades-and-exams-and-methods/</a></li>
<li><a href="http://terrytao.wordpress.com/2010/10/21/245a-problem-solving-strategies/">http://terrytao.wordpress.com/2010/10/21/245a-problem-solving-strategies/</a></li>
<li><a href="https://plus.google.com/u/0/114134834346472219368/posts/Xdm8eiPLWZp">https://plus.google.com/u/0/114134834346472219368/posts/Xdm8eiPLWZp</a>
<ul>
<li><em>The point is that even if the technique is doomed to fail, the precise point in the argument at which it fails can be very instructive, as it can delineate what portion of the problem can be handled</em></li>
</ul></li>
<li><a href="http://terrytao.wordpress.com/career-advice/ask-yourself-dumb-questions-%E2%80%93-and-answer-them/">http://terrytao.wordpress.com/career-advice/ask-yourself-dumb-questions-%E2%80%93-and-answer-them/</a>
<ul>
<li><em>Don’t just read it; fight it! Ask your own questions, look for your own examples, discover your own proofs. Is the hypothesis necessary? Is the converse true? What happens in the classical special case? What about the degenerate cases? Where does the proof use the hypothesis?</em></li>
</ul></li>
</ul>
<h1 id="random-puzzles">random puzzles</h1>
<ul>
<li><a href="https://www.quantnet.com/threads/jane-street-interview-question-needing-help.7591/">the noodles probability</a>
<ul>
<li>consider the first pick</li>
</ul></li>
<li><a href="https://www.quantnet.com/threads/jane-street-interview-question-needing-help.7591/">100 dice problem!</a>
<ul>
<li>consider the position <span class="math">\((n, m)\)</span></li>
<li>from the above two, we can see that you should know where to start considering the problem</li>
</ul></li>
<li>the <span class="math">\(n\)</span> man remember card problem
<ul>
<li>it is not clear at all when considering this point, but you should consider the optimal solution when go on</li>
</ul></li>
<li>the gate program: can you make a circuit calculate the not of 3 variables using only 2 <code>not</code> gate and arbitrary <code>and</code> and <code>or</code> gates?
<ul>
<li>boolean function reduction! then you have a function that has no <code>not</code> in it!</li>
</ul></li>
<li>the two kid cake problem
<ul>
<li>it is a optimization problem! <code>minimize[ max(max(1-x,x), min(1-x,x)+1/2) ]</code></li>
<li>but in a more general form <code>min(1 - max( max(1-x1,x1) + min(1-x2, x2), min(1-x1,x1) + max(1-x2, x2) ) )</code></li>
<li>if 3 cake, the same problem!!! <code>minimize[ max_first, max_second, max_last ]</code></li>
<li>for the general case, we need
<ul>
<li>first, we need to know it has a <strong>eq point</strong></li>
<li>then we find it like above!</li>
</ul></li>
</ul></li>
<li>proof that you have <span class="math">\(n+1\)</span> integers bellow <span class="math">\(2n\)</span>, always two relatively prime
<ul>
<li>this takes Erdios 10 minutes</li>
</ul></li>
</ul>
    </div>
</div>
 
</div>
<script src="./js/jquery.toc.js"></script>
<script src="./js/toc.js"></script>


<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script>
MathJax.Hub.Queue(function () {
    $(document.body).scrollspy('refresh')
});
</script>

  </div>

    <div class="footer">
      <div class="container">
        <span></span>
      </div>
    </div>

      <script src="./js/bootstrap.min.js"></script>
    </body>
</html>
