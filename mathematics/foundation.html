<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>mathematics</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/solarized-dark.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h1 id="mathematics">mathematics</h1>

<p><script type="math/tex; mode=display" id="MathJax-Element-1">
\def\ZZ{\mathbb{Z}}
\def\RR{\mathbb{R}}
\def\Cat{\mathcal{Cat}}
\def \Set{\mathcal{Set}}
\def\AbCat{\mathbf{Ab}\text{-}\Cat}
\def\Mon\mathcal{Mon}
\def\Grp\mathcal{Grp}
\def\Gp\mathcal{Gp}
\def\Ab\mathcal{Ab}
\def\symdiff{\bigtriangleup}
\def\funrestri{\upharpoonright}
\def\dom{\operatorname{dom}}
\def\cod{\operatorname{cod}}
\def\img{\operatorname{img}}
\def\fimg{“}
\def\iimg{_{-1}}
\def\inv{^{-1}}
\def\ran{\operatorname{ran}}
\def\proj{\operatorname{proj}}
\def\id{\operatorname{id}}
\def\hom{\operatorname{hom}}
\def\endo{\operatorname{endo}}
\def\aut{\operatorname{aut}}
\def\inn{\operatorname{inn}}
\def\ker{\operatorname{ker}}
\def\coker{\operatorname{coker}}
\def\lcm{\operatorname{lcm}}
\def\gcd{\operatorname{gcd}}
\def\freegroup{\operatorname{F}}
\def\op{\text{op}}</script></p>

<p><div class="toc">
<ul>
<li><a href="#mathematics">mathematics</a><ul>
<li><a href="#preface">preface</a><ul>
<li><a href="#references">references</a></li>
<li><a href="#note-principle">note principle</a></li>
</ul>
</li>
<li><a href="#logic">logic</a><ul>
<li><a href="#a-comment-on-logic-and-model-theory">a comment on logic and model theory</a></li>
</ul>
</li>
<li><a href="#set-theory">set theory</a><ul>
<li><a href="#zfc">ZFC</a></li>
<li><a href="#other-definitions">other definitions</a></li>
<li><a href="#ordinal-numbers">ordinal numbers</a></li>
<li><a href="#cardinal-numbers">cardinal numbers</a></li>
<li><a href="#universe-axiom">universe axiom</a></li>
</ul>
</li>
<li><a href="#universal-algebra">universal algebra</a><ul>
<li><a href="#lattice-theory">lattice theory</a></li>
</ul>
</li>
<li><a href="#category-theory">category theory</a><ul>
<li><a href="#chapter-01-categories-functors-and-natural-transformations">chapter 01. categories, functors, and natural transformations</a></li>
<li><a href="#chapter-02-constructions-on-categories">chapter 02. constructions on categories</a></li>
<li><a href="#chapter-03-universals-and-limits">chapter 03. universals and limits</a></li>
<li><a href="#chapter-04-adjoints">chapter 04. adjoints</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</p>



<h2 id="preface">preface</h2>



<h3 id="roadmap">roadmap</h3>

<ul>
<li>Set Theory, <em>Thomas Jech</em></li>
<li><a href="http://arxiv.org/abs/0810.1279">Set Theory for Category Theory</a>, <em>Michael A. Shulman</em></li>
<li><code>CTWM</code> Category Theory for Working Mathematicians, <em>Saunders Mac Lane</em></li>
<li><code>MCHT</code> Modern Classical Homotopy Theory, <em>Jeffrey Strom</em></li>
</ul>

<h3 id="note-principle">note principle</h3>

<ul>
<li>no circular definition, but the order is not necessary linear</li>
</ul>



<h2 id="logic">logic</h2>



<h3 id="a-comment-on-logic-and-model-theory">a comment on logic and model theory</h3>

<ul>
<li>the reason why we can study things like set theory (as the entire of mathematics) outside it is that the tools used to study them is much more weaker</li>
</ul>



<h2 id="set-theory">set theory</h2>



<h3 id="zfc">ZFC</h3>

<ul>
<li><p><strong>ZFC</strong></p>

<ul><li><p>definition</p>

<ul><li>a <strong>first order logic</strong> with <strong>equality</strong></li>
<li>another predicate <script type="math/tex" id="MathJax-Element-2">\in</script></li>
<li><p><strong>axioms</strong></p>

<ul><li>basic axioms <br>
<ul><li><strong>extensionality</strong>. <script type="math/tex" id="MathJax-Element-3">\forall a, b (\forall z, z \in a \to z \in b) \to a =b</script></li>
<li><strong>pairing</strong>. there is a set <script type="math/tex" id="MathJax-Element-4">\{a, b\}</script></li>
<li><strong>schema of separation</strong></li>
<li><strong>regularity (foundation)</strong>. <script type="math/tex" id="MathJax-Element-5">\forall S(S\neq \emptyset \implies (\exists x\in S, S\cap x = \emptyset))</script></li>
<li><strong>union</strong>. it is <script type="math/tex" id="MathJax-Element-6">\bigcup X</script>, not binary</li></ul></li>
<li>size increasing axioms <br>
<ul><li><strong>power set</strong> <script type="math/tex" id="MathJax-Element-7">P(X)</script></li>
<li><strong>schema of replacement</strong> (in Jech this is defined by functions, which is a class, but it can be also formulated by a logical property, which is more extendable)</li></ul></li>
<li><p>size assertion axiom</p>

<ul><li><strong>infinity</strong></li></ul></li>
<li><p><strong>choice</strong>: family of non-empty sets has a choice function</p></li></ul></li></ul></li>
<li>examples <br>
<ul><li><strong>empty set</strong> <script type="math/tex" id="MathJax-Element-8">\emptyset</script> by separation and infinite axioms</li></ul></li>
<li>methods <br>
<ul><li><script type="math/tex" id="MathJax-Element-9">A\cap B</script> <script type="math/tex" id="MathJax-Element-10">A-B</script>, <script type="math/tex" id="MathJax-Element-11">\bigcap C</script> (c is a class) etc. by separation</li>
<li><strong>disjoint</strong> <script type="math/tex" id="MathJax-Element-12">X\cap Y = \emptyset</script></li>
<li><script type="math/tex" id="MathJax-Element-13">A\cup B</script> etc.</li>
<li><script type="math/tex" id="MathJax-Element-14">X\symdiff Y = (X-Y)\cup(Y- X)</script></li>
<li><strong>product set</strong> <script type="math/tex" id="MathJax-Element-15">A\times B</script> is defined by power set axiom, <script type="math/tex" id="MathJax-Element-16">A\times B\times C = (A\times B)\times C</script>, <script type="math/tex" id="MathJax-Element-17">X^n</script></li>
<li>a family of set is disjoint if any two is disjoint. a <strong>partition</strong> of <script type="math/tex" id="MathJax-Element-18">X</script> is a disjoint family of non-empty set with union <script type="math/tex" id="MathJax-Element-19">X</script></li></ul></li>
<li>theorems <br>
<ul><li><strong>well-ordering theroem</strong></li></ul></li></ul></li>
</ul>



<h3 id="other-definitions">other definitions</h3>

<ul>
<li><strong>class</strong> is a logical device, it behaves like set in terms of <script type="math/tex" id="MathJax-Element-20">\subset</script>, <script type="math/tex" id="MathJax-Element-21">C \cup D</script>, <script type="math/tex" id="MathJax-Element-22">C\cap D</script>, <script type="math/tex" id="MathJax-Element-23">\bigcup C</script></li>
<li><strong>ordered pair</strong> can be defined formally as <script type="math/tex" id="MathJax-Element-24">(a,b)=\{\{a\}, \{a, b\}\}</script>, further, <script type="math/tex" id="MathJax-Element-25">(a, b, c) = ((a, b), c)</script>, …</li>
<li><script type="math/tex" id="MathJax-Element-26">n</script>-ary <strong>relation</strong> is just a set of <script type="math/tex" id="MathJax-Element-27">n</script>-triples, <strong>on</strong> <script type="math/tex" id="MathJax-Element-28">X</script> if <script type="math/tex" id="MathJax-Element-29">R\subset X^n</script> <br>
<ul><li><strong>domain</strong> of a relation <script type="math/tex" id="MathJax-Element-30">\dom R</script></li>
<li><strong>range</strong> <script type="math/tex" id="MathJax-Element-31">\ran R</script></li>
<li>in general we can define relation as class</li></ul></li>
<li><strong>function</strong> is a binary relation such that… (also can be a class). <strong>on</strong> X if <script type="math/tex" id="MathJax-Element-32">X = \dom f</script>, <strong>onto</strong> <script type="math/tex" id="MathJax-Element-33">Y</script> if <script type="math/tex" id="MathJax-Element-34">Y = \ran f</script>. all functions with <script type="math/tex" id="MathJax-Element-35">\dom f = X</script> and <script type="math/tex" id="MathJax-Element-36">\ran f \subset Y</script> is <script type="math/tex" id="MathJax-Element-37">Y^X</script> and it is a set <br>
<ul><li>we understand function as it’s graph, so a function might have different “type”</li>
<li><script type="math/tex" id="MathJax-Element-38">x\mapsto x * 2</script> is actually “lambda expression”</li>
<li><strong>injective</strong>. <strong>surjective</strong>. <strong>bijective</strong></li>
<li><strong>restriction</strong> <script type="math/tex" id="MathJax-Element-39">f\funrestri X</script>. <strong>extension</strong></li>
<li><strong>composition</strong></li>
<li><strong>image</strong> <script type="math/tex" id="MathJax-Element-40">f(X)</script>, <script type="math/tex" id="MathJax-Element-41">f\fimg X</script></li>
<li><strong>inverse image</strong> <script type="math/tex" id="MathJax-Element-42">f\iimg Y</script></li>
<li><strong>inverse</strong> <script type="math/tex" id="MathJax-Element-43">f\inv</script></li></ul></li>
<li><strong>binary relations</strong> <br>
<ul><li><strong>reflective</strong>. <strong>transitive</strong>. <strong>symmetry</strong></li>
<li><strong>antisymmetry</strong> <script type="math/tex" id="MathJax-Element-44">p \leq b\land b\leq p \Rightarrow p = b</script></li>
<li><strong>equivalence relation</strong> <script type="math/tex" id="MathJax-Element-45">\equiv</script> is reflective, transitive, symmetry <br>
<ul><li><script type="math/tex" id="MathJax-Element-46">X/\equiv</script> <strong>quotient</strong> of <script type="math/tex" id="MathJax-Element-47">X</script> by <script type="math/tex" id="MathJax-Element-48">\equiv</script> is a partition. conversely a partition defines a equivalence relation…</li></ul></li>
<li><strong>poset</strong> is reflective, transitive, antisymmetry</li>
<li><strong>linear ordering</strong> is poset and (forall <script type="math/tex" id="MathJax-Element-49">p</script>, <script type="math/tex" id="MathJax-Element-50">q</script> we have <script type="math/tex" id="MathJax-Element-51">p \leq q</script> or <script type="math/tex" id="MathJax-Element-52">q \leq p</script>)</li></ul></li>
<li><strong>binary operation</strong>, <strong>law of composition</strong>, <script type="math/tex" id="MathJax-Element-53">X\times X\to X</script> <br>
<ul><li>associative</li></ul></li>
<li><p>poset <script type="math/tex" id="MathJax-Element-54">P</script></p>

<ul><li>methods <br>
<ul><li>subset <script type="math/tex" id="MathJax-Element-55">X\subset P</script> <br>
<ul><li><strong>maximal</strong>: _ not smaller than any</li>
<li><strong>minimal</strong>: no one is smaller than _</li>
<li><strong>greatest</strong></li>
<li><strong>least</strong></li>
<li><strong>upper bound</strong></li>
<li><strong>lower bound</strong></li>
<li><strong>supremum</strong>, <strong>lub</strong>, <strong>least upper bound</strong> <script type="math/tex" id="MathJax-Element-56">\sup X</script></li>
<li><strong>infimum</strong>, <strong>glb</strong>, <strong>greatest lower bound</strong>, <script type="math/tex" id="MathJax-Element-57">\inf X</script></li></ul></li>
<li><script type="math/tex" id="MathJax-Element-58">F: P \to Q</script> <br>
<ul><li><strong>order-preserving</strong>, <strong>increasing</strong>: <script type="math/tex" id="MathJax-Element-59">x < y\implies f(x) < f(y)</script></li></ul></li></ul></li></ul></li>
<li><p><strong>well-ordering</strong> <script type="math/tex" id="MathJax-Element-60">W</script> is a linear ordering such that each non-empty subset hes least element</p>

<ul><li>methods <br>
<ul><li><strong>initial segment</strong> <script type="math/tex" id="MathJax-Element-61">u\in W</script>,  is all elements less than <script type="math/tex" id="MathJax-Element-62">u</script></li></ul></li>
<li>theorems <br>
<ul><li><script type="math/tex" id="MathJax-Element-63">f: W\to W</script> is increasing, then <script type="math/tex" id="MathJax-Element-64">\forall x\in W,f(x)\geq x</script> <br>
<ul><li>corollary. there is only one automorphism and isomorphism if exists between well-orderings</li></ul></li>
<li>two well ordering can be isomorphic or one is isomorphic to the initial segment of the other</li></ul></li></ul></li>
</ul>



<h3 id="ordinal-numbers">ordinal numbers</h3>

<ul>
<li><strong>transitive</strong> set is every element of <script type="math/tex" id="MathJax-Element-65">T</script> is subset of <script type="math/tex" id="MathJax-Element-66">T</script></li>
<li><strong>ordinal number</strong> is transitive and well ordered by <script type="math/tex" id="MathJax-Element-67">\in</script> <br>
<ul><li>methods <br>
<ul><li><script type="math/tex" id="MathJax-Element-68">\alpha + 1 =  \alpha \cup \{\alpha\}</script> is <strong>successor ordinal</strong></li>
<li><strong>limit ordinal</strong>. example <script type="math/tex" id="MathJax-Element-69">0=\emptyset</script>, <script type="math/tex" id="MathJax-Element-70">\omega = \infty</script></li>
<li><strong>finite</strong>. <strong>infinite</strong>. <strong>finite/infinite sequence</strong></li>
<li><strong>transfinite sequence</strong>, <script type="math/tex" id="MathJax-Element-71">\alpha</script>-<strong>sequence</strong></li>
<li><strong>limit</strong> of non-decreasing ordinal <script type="math/tex" id="MathJax-Element-72">\alpha</script>-sequence</li>
<li><strong>normal</strong> sequence <script type="math/tex" id="MathJax-Element-73">\gamma_\alpha</script>: increasing and <strong>continuous</strong> (limit at limit ordinal is itself)</li>
<li><strong>ordinal arithmetic</strong></li>
<li><strong>cumulative hierarchy</strong> <script type="math/tex" id="MathJax-Element-74">V_\alpha</script></li></ul></li>
<li>theorems <br>
<ul><li>every well order set isomorphic to an ordinal</li>
<li><strong>transfinite recursion</strong></li></ul></li></ul></li>
</ul>



<h3 id="cardinal-numbers">cardinal numbers</h3>

<ul>
<li>comparing size of sets <br>
<ul><li>defintion <br>
<ul><li>two set has same <strong>cardinality</strong> if there is bijection</li>
<li><script type="math/tex" id="MathJax-Element-75">|X| \leq |Y|</script> by exists injection</li>
<li><script type="math/tex" id="MathJax-Element-76">\kappa+\lambda = |A\cup B|</script>. where <script type="math/tex" id="MathJax-Element-77">\kappa = </script>…</li>
<li><script type="math/tex" id="MathJax-Element-78">\kappa\cdot\lambda = |A\times B|</script></li>
<li><script type="math/tex" id="MathJax-Element-79">\kappa^\lambda = |A^B|</script></li></ul></li>
<li>theorems <br>
<ul><li><script type="math/tex" id="MathJax-Element-80">|X| <|P(X)|</script></li>
<li><script type="math/tex" id="MathJax-Element-81">|A|\leq |B|</script> and <script type="math/tex" id="MathJax-Element-82">|B|\leq|A|</script> then <script type="math/tex" id="MathJax-Element-83">|A|=|B|</script></li>
<li><script type="math/tex" id="MathJax-Element-84">|P(A)| = 2^{|A|}</script></li>
<li><strong>cardinal arithmetic</strong> …</li></ul></li></ul></li>
<li><strong>cardinal number</strong> is ordinal <script type="math/tex" id="MathJax-Element-85">\alpha</script> such that <script type="math/tex" id="MathJax-Element-86">|\alpha|\neq|\beta|</script> for <script type="math/tex" id="MathJax-Element-87">\beta < \alpha</script>. <br>
<ul><li>methods <br>
<ul><li>infinite cardinal is <strong>aleph</strong>. <strong>countable</strong> is <script type="math/tex" id="MathJax-Element-88">\aleph_0</script>. <strong>uncountable</strong></li>
<li><strong>limit cardinal</strong></li>
<li><strong>strong limit</strong></li>
<li><strong>regular</strong></li>
<li><strong>inaccessible</strong></li>
<li><strong>Grothendieck universe</strong> is <script type="math/tex" id="MathJax-Element-89">V_\alpha</script> for some inaccessible <script type="math/tex" id="MathJax-Element-90">\alpha</script></li></ul></li>
<li>theorems <br>
<ul><li><script type="math/tex" id="MathJax-Element-91">\aleph_\alpha \cdot \aleph_\alpha = \aleph_\alpha</script></li>
<li><script type="math/tex" id="MathJax-Element-92">\RR</script> is uncountable</li></ul></li></ul></li>
</ul>



<h3 id="universe-axiom">universe axiom</h3>

<ul>
<li><strong>universe</strong> any set is contained in a universe <script type="math/tex" id="MathJax-Element-93">U</script> <br>
<ul><li>comments <br>
<ul><li><a href="http://math.stackexchange.com/questions/79343/is-the-axiom-of-universes-harmless">http://math.stackexchange.com/questions/79343/is-the-axiom-of-universes-harmless</a></li></ul></li></ul></li>
</ul>



<h2 id="universal-algebra">universal algebra</h2>



<h3 id="lattice-theory">lattice theory</h3>

<ul>
<li><strong>lattice</strong>: each two objects in the pos has join, <script type="math/tex" id="MathJax-Element-94">\sup</script>, <script type="math/tex" id="MathJax-Element-95">a\lor b</script> and meet, <script type="math/tex" id="MathJax-Element-96">\inf</script>, <script type="math/tex" id="MathJax-Element-97">a\land b</script></li>
<li><strong>bounded lattice</strong>: have <script type="math/tex" id="MathJax-Element-98">0</script> and <script type="math/tex" id="MathJax-Element-99">1</script> and <script type="math/tex" id="MathJax-Element-100">0 \leq p \leq 1</script></li>
<li><strong>distributive lattice</strong>: <script type="math/tex" id="MathJax-Element-101">p \land (q \lor r) = (p\lor q)\land (p \lor r)</script></li>
<li><strong>complete lattice</strong>: all subset has join and meet, so it is a bounded lattice</li>
<li><strong>de Morgan algebra</strong> <br>
<ul><li>defintion <br>
<ul><li>bounded distributive lattice</li>
<li>with <script type="math/tex" id="MathJax-Element-102">1 -p</script> satisfying <br>
<ul><li><script type="math/tex" id="MathJax-Element-103">1-(p\land q) = (1-p)\lor(1-q)</script></li>
<li><script type="math/tex" id="MathJax-Element-104">1-(1-p) = p</script></li></ul></li></ul></li></ul></li>
<li><strong>congruence lattice of a algebra <script type="math/tex" id="MathJax-Element-105">\mathcal{A}</script></strong>: the set of all congruence relations respect to the algebra. because there is a natural meet, and you can define the join by first take relations join, then the meet of all congruence relations containing the join, or say, the closure <br>
<ul><li>theorems <br>
<ul><li>it is complete and distributive lattice</li></ul></li></ul></li>
</ul>



<h2 id="category-theory">category theory</h2>



<h3 id="chapter-01-categories-functors-and-natural-transformations">chapter 01. categories, functors, and natural transformations</h3>

<ul>
<li><p><strong>directed graph</strong> is a set <script type="math/tex" id="MathJax-Element-106">A</script> of <strong>arrows</strong> and set <script type="math/tex" id="MathJax-Element-107">O</script> of <strong>object</strong>. and two function <script type="math/tex" id="MathJax-Element-108">\dom</script> and <script type="math/tex" id="MathJax-Element-109">\cod</script> with type <script type="math/tex" id="MathJax-Element-110">A \to O</script></p>

<ul><li>(formal) product over the graph is just pairs of arrows with <script type="math/tex" id="MathJax-Element-111">\dom g = \text{cod} f</script>. it is just pairs, not triples</li>
<li>expanded graph (? is the compositions finite or not?)</li>
<li>commutative diagram (all possible composition between two object is the same arrow <br>
<ul><li><code>MCHT 1.1</code> show diagram commutative iff expanded diagram commutative</li></ul></li></ul></li>
<li><p>a <strong>category</strong> is a graph with <script type="math/tex" id="MathJax-Element-112">\text{id}: O\to A</script>, <script type="math/tex" id="MathJax-Element-113">\circ : A \times A\to A</script>, where with proper domain conditions, and associativity law of composition, also unit axioms</p>

<ul><li>examples. 1, 2, 3, discrete categories, monoids, groups, groupoids, preorders (only one arrow between two object in one direction), partial orders (only one arrow between two object, this is a great example!), linear order (one and only one), ordinals, <strong>simplicial category</strong> (finite ordinals and order-preserving functions)</li>
<li>methods <br>
<ul><li><strong>hom-set</strong>, <script type="math/tex" id="MathJax-Element-114">\hom_C(a, b)</script> is set of arrows <script type="math/tex" id="MathJax-Element-115">a\to b</script> </li>
<li>it is <strong>small</strong> in universe <script type="math/tex" id="MathJax-Element-116">U</script> if the set of objects and arrows is in <script type="math/tex" id="MathJax-Element-117">U</script></li>
<li><strong>inverse</strong> or <script type="math/tex" id="MathJax-Element-118">f</script> is <script type="math/tex" id="MathJax-Element-119">g</script>: <script type="math/tex" id="MathJax-Element-120">fg = \text{id}, gf = \text{id}</script> <br>
<ul><li>inverse is unique. <script type="math/tex" id="MathJax-Element-121">g=gfg_1=g_1</script></li>
<li>reflective, transitive, and symmetry. thus define a equivalence relation</li>
<li><strong>isomorphism</strong>: a arrow has inverse, <strong>isomorphic</strong> objects has isomorphism between</li></ul></li>
<li><strong>endomorphism</strong> <script type="math/tex" id="MathJax-Element-122">\endo A</script>, <strong>idempotent</strong>, <strong>automorphism</strong> <script type="math/tex" id="MathJax-Element-123">\aut A</script></li></ul></li>
<li><strong>monic</strong> or <strong>left cancelable</strong> <script type="math/tex" id="MathJax-Element-124">m</script>, <script type="math/tex" id="MathJax-Element-125">m\circ f_1=m\circ f_2\implies f_1 = f_2</script>, compose is also monic. <script type="math/tex" id="MathJax-Element-126">g\circ f</script> monic then <script type="math/tex" id="MathJax-Element-127">f</script> monic (trivial)</li>
<li><strong>epi</strong> or <strong>right cancelable</strong> <script type="math/tex" id="MathJax-Element-128">h</script>, <script type="math/tex" id="MathJax-Element-129">g_1\circ h=g_2\circ h\implies g_1 =g_2</script>, compose is also epi</li>
<li>for <script type="math/tex" id="MathJax-Element-130">h: a\to b</script> a <strong>right inverse</strong> or <strong>section</strong> is <script type="math/tex" id="MathJax-Element-131">r: b \to a</script> such that <script type="math/tex" id="MathJax-Element-132">hr=1_b</script> (not usually unique), and makes <script type="math/tex" id="MathJax-Element-133">h</script> a <strong>split epi</strong> <em>(<script type="math/tex" id="MathJax-Element-134">r</script> select from the domain <script type="math/tex" id="MathJax-Element-135">a</script>)</em> <br>
<ul><li><code>MCHT 1.6</code> a arrow having a left inverse which has a left inverse is a isomorphism pair</li>
<li>for <script type="math/tex" id="MathJax-Element-136">h: a\to b</script> a <strong>left inverse</strong> or <strong>retraction</strong> is <script type="math/tex" id="MathJax-Element-137">l : b\to a</script> such that <script type="math/tex" id="MathJax-Element-138">lh=1_a</script> and makes <script type="math/tex" id="MathJax-Element-139">h</script> a <strong>split monic</strong>. the <script type="math/tex" id="MathJax-Element-140">a</script> is sometimes called a <strong>retract</strong> of <script type="math/tex" id="MathJax-Element-141">b</script>. <em>(imagine the domain is larger, and the <script type="math/tex" id="MathJax-Element-142">h</script> is just a embedding, then <script type="math/tex" id="MathJax-Element-143">l</script> will retract the codomain back)</em> <br>
<ul><li><code>MCHT 1.9</code> show that in the arrow category of certain category, <script type="math/tex" id="MathJax-Element-144">f</script> is retract of <script type="math/tex" id="MathJax-Element-145">g</script>. then if <script type="math/tex" id="MathJax-Element-146">g</script> is a isomorphism, <script type="math/tex" id="MathJax-Element-147">f</script> is. and <script type="math/tex" id="MathJax-Element-148">f</script> is, then <script type="math/tex" id="MathJax-Element-149">g</script> maybe not. first part is trivial. second part is also trivial. all other maps is <script type="math/tex" id="MathJax-Element-150">\id</script> except <script type="math/tex" id="MathJax-Element-151">g</script></li></ul></li>
<li>if <script type="math/tex" id="MathJax-Element-152">fg=1_a</script> then there is a left inverse, a right inverse and a idempotent, and it is a <strong>split idempotent</strong></li>
<li><strong>terminal</strong>. <strong>initial</strong></li>
<li><strong>null object</strong>. <strong>pointed category</strong>. <strong>zero arrow</strong> (trivial morphism) factor through null object. <strong>wedge</strong> is coproduct in pointed categories</li></ul></li></ul></li>
<li><p><strong>functor</strong> is a map between two category, consists obj map and arr map, preserve unit and associ, category and functors in one universe <script type="math/tex" id="MathJax-Element-153">U</script> forms <script type="math/tex" id="MathJax-Element-154">\Cat</script> in another universe    </p>

<ul><li><script type="math/tex" id="MathJax-Element-155">T: C\to B</script> and <script type="math/tex" id="MathJax-Element-156">S: B\to A</script> has <strong>composition</strong> <script type="math/tex" id="MathJax-Element-157">S\circ T</script>,  is a functor <script type="math/tex" id="MathJax-Element-158">C\to A</script>. it is associ (because function composition is associ), and there is identity functor, so <script type="math/tex" id="MathJax-Element-159">\Cat</script> of all small categories is a category</li>
<li>isomorphism iff bijection on object and arrows. this is super natual, because category is a set construction so there isomorphism is a set bijection thing</li>
<li>methods <br>
<ul><li><strong>forgetful functor</strong> (vague) may be considered by (a, b) =&gt; (a) of some Sigma type</li>
<li><strong>full functor</strong>, <script type="math/tex" id="MathJax-Element-160">\forall c, c_1, \forall g: Tc\to Tc_1\exists f: c\to c_1: g = Tf</script> <br>
<ul><li>compose is full</li></ul></li>
<li><strong>faithful functor</strong> <script type="math/tex" id="MathJax-Element-161">\forall c, c_1, \forall f, f_1: c\to c_1, Tf = Tf_1\implies f = f_1</script> <br>
<ul><li>compose if faithful</li></ul></li>
<li><strong>subcategory</strong> and <strong>inclusion functor</strong> is faithful <em>(sub meaning get from removing some obj and arr)</em>. <strong>full subcategory</strong> when the inclusion functor is full <em>(you are not removing arrows without removing one of it’s domain)</em></li></ul></li></ul></li>
<li><p><code>CWM c01 p15</code></p>

<ul><li><code>4</code> they are <strong>symmetric groups</strong>, consider the permutations of two elements, then map it two permutations of three elements by ignoring the third element. then map to permutations of two elements by ignoring the third element, the composition is <script type="math/tex" id="MathJax-Element-162">\id</script></li>
<li><code>5</code> <a href="http://mathoverflow.net/questions/4276/two-functors-from-grp-to-grp">evil answer</a></li></ul></li>
<li><p><strong>functor category</strong> <script type="math/tex" id="MathJax-Element-163">B^C</script>, <strong>natural transformation</strong>  <script type="math/tex" id="MathJax-Element-164">\tau</script>, <strong>component</strong> <script type="math/tex" id="MathJax-Element-165">\tau c</script> <strong>natural in</strong> <script type="math/tex" id="MathJax-Element-166">c</script>: from <script type="math/tex" id="MathJax-Element-167">S, T: C\to B</script> assigns each object <script type="math/tex" id="MathJax-Element-168">c</script> an arrow <script type="math/tex" id="MathJax-Element-169">\tau c</script> (the shape), <script type="math/tex" id="MathJax-Element-170">\forall c',f: c\to c', Tf\circ\tau c=\tau c'\circ Sf</script></p>

<ul><li>they form the functor category <script type="math/tex" id="MathJax-Element-171">B^C</script>. and <strong>natural isomorphism</strong> iff each component is isomorphism (trivial. componentwise)</li>
<li><script type="math/tex" id="MathJax-Element-172">B^2</script> is the <strong>category of arrows</strong></li>
<li><strong>equivalence of categories</strong> <script type="math/tex" id="MathJax-Element-173">C</script>, <script type="math/tex" id="MathJax-Element-174">D</script> is <script type="math/tex" id="MathJax-Element-175">(S, T, \tau_1, \tau_2)</script>, such that <script type="math/tex" id="MathJax-Element-176">\tau_1: I_C\simeq T\circ S</script> and <script type="math/tex" id="MathJax-Element-177">\tau_2: I_D\simeq S\circ T</script> <br>
<ul><li>idea: compare alike category of different “size”</li></ul></li></ul></li>
<li><p><code>CWM c01 p18</code></p>

<ol><li><script type="math/tex" id="MathJax-Element-178">e</script> is natural trasformation…</li>
<li>trivial</li>
<li><code>TODO alg</code></li>
<li>if there is, define the natural transform by that arrow. and we know that it is unique… trivial</li>
<li>trivial</li>
<li>trivial</li></ol></li>
<li><p><code>CWM c01 p21</code></p>

<ol><li>trivial</li>
<li>trivial</li>
<li>trivial</li>
<li><code>TODO alg</code></li>
<li><code>TODO alg</code></li>
<li>all idempotents in <script type="math/tex" id="MathJax-Element-179">\Set</script> split. for <script type="math/tex" id="MathJax-Element-180">f: C \to D</script>, <script type="math/tex" id="MathJax-Element-181">A = \{x|f(x) = x\}</script>, then <script type="math/tex" id="MathJax-Element-182">\img f= A</script>, because if <script type="math/tex" id="MathJax-Element-183">y\in\img f\land y = f(x)</script> then <script type="math/tex" id="MathJax-Element-184">f(y)=f(f(x))=f(x)=y</script>, and also clearly <script type="math/tex" id="MathJax-Element-185">A\subset \img f</script> because every <script type="math/tex" id="MathJax-Element-186">x\in A</script> is image of itself. so <script type="math/tex" id="MathJax-Element-187">f = \proj_{\img f}\circ f </script> also <script type="math/tex" id="MathJax-Element-188">\id_{\img f} = f\circ \proj_{\img f}</script></li>
<li>an arrow <script type="math/tex" id="MathJax-Element-189">f: a \to b</script> is <strong>regular</strong> if there is <script type="math/tex" id="MathJax-Element-190">g: b\to a</script> such that <script type="math/tex" id="MathJax-Element-191">f = f g f</script> <br>
<ol><li><script type="math/tex" id="MathJax-Element-192">f</script> has left or right inverse then is regular. trivial</li>
<li>in <script type="math/tex" id="MathJax-Element-193">\Set</script> every arrow with <script type="math/tex" id="MathJax-Element-194">a\neq \emptyset</script> is regular. for everyone in <script type="math/tex" id="MathJax-Element-195">y\in\img f\land f(x) = y</script> define <script type="math/tex" id="MathJax-Element-196">g(y) = x</script> and for other values, define at any element. then <script type="math/tex" id="MathJax-Element-197">\forall x, f(g(f(x)))=f(x_1)</script>, where <script type="math/tex" id="MathJax-Element-198">x_1</script> has property <script type="math/tex" id="MathJax-Element-199">f(x_1) = f(x)</script></li></ol></li>
<li>we define the arrow by pointing <script type="math/tex" id="MathJax-Element-200">f(0)=e'</script> and <script type="math/tex" id="MathJax-Element-201">f(1) = t'(e')</script> and so on. we can see we can define and the definition is unique</li>
<li><script type="math/tex" id="MathJax-Element-202">fg=fk\implies TfTg=TfTk\implies Tg=Tk \implies g=k</script></li></ol></li>
<li><p><code>CWM c01 p24</code></p>

<ol><li>for a function with domain <script type="math/tex" id="MathJax-Element-203">I</script> in <script type="math/tex" id="MathJax-Element-204">U</script> and each value point <script type="math/tex" id="MathJax-Element-205">f_i</script> in <script type="math/tex" id="MathJax-Element-206">U</script>, then the cartesian product <script type="math/tex" id="MathJax-Element-207">\prod_i f_i</script> is in <script type="math/tex" id="MathJax-Element-208">U</script> </li>
<li><code>omit</code></li>
<li><code>omit</code></li></ol></li>
<li><p><strong>concrete category</strong> <script type="math/tex" id="MathJax-Element-209">(C, U)</script> where <script type="math/tex" id="MathJax-Element-210">U: C\to \Set</script> is a faithful functor </p></li>
<li><p><strong>preadditive category</strong> a category where each hom-set is a abelian group, and <script type="math/tex" id="MathJax-Element-211">(g+g')\circ(f+f')=g\circ f+g\circ f'+g'\circ f+g'\circ f'</script></p>

<ul><li>if we use <script type="math/tex" id="MathJax-Element-212">\hom</script> set to define categories, then we see in the definition of preadditive category a similar pattern: using <script type="math/tex" id="MathJax-Element-213">\Ab</script> and tensor product. these is called <strong>enriched category</strong></li>
<li>a functor between two preadditive category is <strong>additive</strong> if each function between hom-sets is a homomorphism. compose is also additive. then <script type="math/tex" id="MathJax-Element-214">\AbCat</script> is is the category of preadditive category with additive functors</li></ul></li>
</ul>



<h3 id="chapter-02-constructions-on-categories">chapter 02. constructions on categories</h3>

<ul>
<li><p><strong>duality in categories</strong> (by <strong>elementary theory of absract category</strong>), <strong>opposite category</strong>, <strong>contravariant functor</strong>, <strong>power-set functor</strong></p>

<ul><li><strong>covariant hom-functor</strong> <script type="math/tex" id="MathJax-Element-215">\hom(a, \_): C \to \Set</script>, for <script type="math/tex" id="MathJax-Element-216">k: b\to b'</script> we have it maps to <script type="math/tex" id="MathJax-Element-217">\hom(a, k)=k_*:\hom(a,b)\to\hom(a, b')</script> by the functor. <script type="math/tex" id="MathJax-Element-218">k_*(f) = k\circ f</script></li>
<li><strong>contravariant hom-functor</strong> <script type="math/tex" id="MathJax-Element-219">\hom(\_, a):C^\op\to \Set</script>, send <script type="math/tex" id="MathJax-Element-220">g</script> to <script type="math/tex" id="MathJax-Element-221">g^*</script>. <script type="math/tex" id="MathJax-Element-222">g^* (f) = f\circ g</script></li>
<li>for <script type="math/tex" id="MathJax-Element-223">g: a\to a'</script>, <script type="math/tex" id="MathJax-Element-224">f: b\to b'</script> we have a diagram <code>img</code>, which is used to proof that <script type="math/tex" id="MathJax-Element-225">\hom</script> is a bifunctor</li></ul></li>
<li><p><strong>product category</strong>, <strong>projection functor</strong>, <strong>product of two functors</strong> <script type="math/tex" id="MathJax-Element-226">U\times V: B\times C\to B'\times C'</script> can be defined by universal arrow</p>

<ul><li><script type="math/tex" id="MathJax-Element-227">(U'\times V')\circ(U\times V)=U'U\times V'V</script></li>
<li>then <script type="math/tex" id="MathJax-Element-228">\times : \Cat\times \Cat \to \Cat</script> can be considered as a functor itself (in the domain, you can consider them formal pairs of categories, the above line proofs associ)</li>
<li><script type="math/tex" id="MathJax-Element-229">(B\times C)^\op \simeq B^\op\times C^\op</script>. because they are just formal pairs</li></ul></li>
<li><p><strong>bifunctors</strong> <script type="math/tex" id="MathJax-Element-230">S: B\times C\to D</script>. euqualivant way to discribe in term of functor: for <script type="math/tex" id="MathJax-Element-231">c\in C</script> and <script type="math/tex" id="MathJax-Element-232">b\in B</script> <script type="math/tex" id="MathJax-Element-233">L_c: B\to D</script> and <script type="math/tex" id="MathJax-Element-234">M_d: C\to D</script> and <script type="math/tex" id="MathJax-Element-235">M_b(c) = L_c(b)</script>, <script type="math/tex" id="MathJax-Element-236">\forall f: b\to b'\forall g: c\to c', M_b' g\circ L_c f = L_{c'} f\circ M_b g</script>. proof: see the book <em>(it is just a easier statement of functoriality in the case of product category)</em>. proof is easy</p>

<ul><li><script type="math/tex" id="MathJax-Element-237">\hom: C^\op\times C\to Set</script> is a bifunctor</li></ul></li>
<li><p><strong>natural transformations of bifunctors</strong> for <script type="math/tex" id="MathJax-Element-238">S, S': B\times C\to D</script>, and <script type="math/tex" id="MathJax-Element-239">\alpha</script> an function <script type="math/tex" id="MathJax-Element-240">(b, c)\mapsto \alpha(b, c)</script> to arrows in <script type="math/tex" id="MathJax-Element-241">D</script>, <script type="math/tex" id="MathJax-Element-242">S(b, c)\to S'(b,c)</script>, <script type="math/tex" id="MathJax-Element-243">\alpha</script> <strong>natural in <script type="math/tex" id="MathJax-Element-244">b</script></strong> (b is dumy variable) if for each <script type="math/tex" id="MathJax-Element-245">c\in C</script>, <script type="math/tex" id="MathJax-Element-246">\alpha(\_, c): S(\_, c)\to S'(\_, c)</script> is a natural transformation of functors <script type="math/tex" id="MathJax-Element-247">B\to D</script>. such an <script type="math/tex" id="MathJax-Element-248">\alpha</script> is a natural transformation iff natural in <script type="math/tex" id="MathJax-Element-249">b</script> for each <script type="math/tex" id="MathJax-Element-250">c</script> and natural in <script type="math/tex" id="MathJax-Element-251">c</script> for each <script type="math/tex" id="MathJax-Element-252">b</script>. proof use projects in dimensions</p></li>
<li><p><strong>universal natural transformation</strong> of <script type="math/tex" id="MathJax-Element-253">C</script>, <script type="math/tex" id="MathJax-Element-254">u</script>, in the sense that for any <script type="math/tex" id="MathJax-Element-255">\tau</script>, we have a unique bifunctor <script type="math/tex" id="MathJax-Element-256">F: C\times 2\to B</script> and <script type="math/tex" id="MathJax-Element-257">Fu=\tau</script></p></li>
<li><p><code>CWM c02 p39</code></p>

<ol><li>trivial</li>
<li>only one times only one is only one</li>
<li>trivial</li>
<li><code>TODO alg</code></li>
<li><code>TODO alg</code></li></ol></li>
<li><p><code>CWM c02 p41</code></p>

<ol><li><code>TODO alg</code></li>
<li>trivial</li>
<li>trivial</li>
<li><script type="math/tex" id="MathJax-Element-258">Q^P</script> is preorder. they are only determined by the nodes in the image, also a natural transformation is requires that all arrows exists. so if there is one, there is only one</li>
<li><code>TODO: alg</code></li>
<li><code>TODO: alg</code></li>
<li>trivial</li>
<li><script type="math/tex" id="MathJax-Element-259">H: C\to B^2</script>, <script type="math/tex" id="MathJax-Element-260">F: C\times 2\to B</script> <code>TODO</code></li></ol></li>
<li><p><strong>horizontal composition of natural transformations</strong> (notice the writing order). proof use the line -&gt; square -&gt; cube diagram</p>

<ul><li><script type="math/tex" id="MathJax-Element-261">\tau'\circ \tau = (T' \circ \tau)\cdot (\tau' \circ S)=\ldots</script></li>
<li><script type="math/tex" id="MathJax-Element-262">(\tau'\cdot\sigma')\circ (\tau\cdot\sigma)=(\tau'\circ\tau)\cdot(\sigma'\circ\sigma)</script>, also <script type="math/tex" id="MathJax-Element-263">\id</script> arrow for horizontal is <script type="math/tex" id="MathJax-Element-264">\id</script> for vertical. proof by the 4 cube diagram</li>
<li><strong>double category</strong> satisfies the interchange law, <strong>2-category</strong> add <script type="math/tex" id="MathJax-Element-265">\id</script> for horizontal composition is <script type="math/tex" id="MathJax-Element-266">\id</script> for vertical</li></ul></li>
<li><p>the functor category <script type="math/tex" id="MathJax-Element-267">\_^{\_}</script> is itself a functor <script type="math/tex" id="MathJax-Element-268">\Cat^\op\times \Cat\to \Cat</script> which looks like <script type="math/tex" id="MathJax-Element-269">\hom</script></p></li>
<li><p><code>CWM c02 p44</code></p>

<ol><li>bijection. first one is by composing with…. <code>TODO</code> too many details</li>
<li><code>TODO</code></li>
<li><code>TODO</code></li>
<li><code>TODO alg</code></li>
<li><em>Hilton-Eckmann</em> <code>TODO</code></li>
<li><code>TODO alg</code></li>
<li><code>TODO</code></li>
<li><code>TODO</code></li></ol></li>
<li><p><strong>comma category</strong> <script type="math/tex" id="MathJax-Element-270">(T\downarrow S)</script> where <script type="math/tex" id="MathJax-Element-271">T: E\to C</script> and <script type="math/tex" id="MathJax-Element-272">S: D\to C</script>. <script type="math/tex" id="MathJax-Element-273">(C\downarrow a)</script> objects over <script type="math/tex" id="MathJax-Element-274">a</script>. <script type="math/tex" id="MathJax-Element-275">a\downarrow C</script> objects under <script type="math/tex" id="MathJax-Element-276">a</script></p></li>
<li><p><code>CWM c02 p48</code></p>

<ol><li><script type="math/tex" id="MathJax-Element-277">K</script>-algebra as comma category</li>
<li>trivial</li>
<li>trivial</li>
<li>trivial</li>
<li><code>TODO</code></li>
<li><code>TODO</code></li></ol></li>
<li><p><strong>free category</strong></p></li>
<li><p><code>CWM c02 p51 TODO</code></p></li>
<li><p><strong>quotient category</strong></p></li>
<li><p><code>CWM c02 p51 TODO</code></p></li>
</ul>



<h3 id="chapter-03-universals-and-limits">chapter 03. universals and limits</h3>

<ul>
<li><p><script type="math/tex" id="MathJax-Element-278">S: D\to C</script> is a functor and <script type="math/tex" id="MathJax-Element-279">c\in C</script> <strong>universal arrow</strong> from <script type="math/tex" id="MathJax-Element-280">c</script> to <script type="math/tex" id="MathJax-Element-281">S</script> is a <script type="math/tex" id="MathJax-Element-282">r\in D</script> and <script type="math/tex" id="MathJax-Element-283">u: c\to Sr</script>, which is inital in comma category <script type="math/tex" id="MathJax-Element-284">(c\downarrow S)</script> (or say: such that every pair <script type="math/tex" id="MathJax-Element-285">d</script>, <script type="math/tex" id="MathJax-Element-286">f</script> there is a unique arrow <script type="math/tex" id="MathJax-Element-287">f': r\to d</script> where <script type="math/tex" id="MathJax-Element-288">Sf'\circ u = f</script>. or every arrow <script type="math/tex" id="MathJax-Element-289">f</script> to <script type="math/tex" id="MathJax-Element-290">S</script> factors uniquely through the universal arrow <script type="math/tex" id="MathJax-Element-291">u</script>)</p>

<ul><li>universal element</li>
<li>iff the compose by <script type="math/tex" id="MathJax-Element-292">u</script> function is a bijection <script type="math/tex" id="MathJax-Element-293">D(r, d)\cong C(c, S d)</script> for each <script type="math/tex" id="MathJax-Element-294">d</script> and natural in <script type="math/tex" id="MathJax-Element-295">d</script> (viewing each side as a <script type="math/tex" id="MathJax-Element-296">C\to \Set</script>). (proof: bijection is easy, natual is )</li>
<li><script type="math/tex" id="MathJax-Element-297">K: D\to \Set</script> is <strong>representable functor</strong> if there is natural isomorphism <script type="math/tex" id="MathJax-Element-298">D(r, \_)\cong K</script></li>
<li><code>TODO</code> any repsentation of functor <script type="math/tex" id="MathJax-Element-299">K</script> is from a universal arrow from one point set <script type="math/tex" id="MathJax-Element-300">*</script></li></ul></li>
<li><p><code>TODO</code> for <script type="math/tex" id="MathJax-Element-301">K: D\to \Set</script> and <script type="math/tex" id="MathJax-Element-302">r\in D</script> there is <script type="math/tex" id="MathJax-Element-303">y: \hom(D(r, \_), K)\cong Kr</script>, and it is natural in (<script type="math/tex" id="MathJax-Element-304">K</script> and <script type="math/tex" id="MathJax-Element-305">r</script>) (both side viewed as a functor from… to <script type="math/tex" id="MathJax-Element-306">\Set</script>)</p></li>
<li><p><code>CWM c03 p59</code></p>

<ol><li><code>TODO</code></li>
<li><code>TODO</code></li>
<li><code>TODO</code></li>
<li><code>TODO</code></li>
<li><code>TODO</code></li>
<li><code>TODO</code></li>
<li><code>TODO</code></li></ol></li>
<li><p><code>CWM c03 p62</code></p>

<ol><li><code>TODO</code></li>
<li><code>TODO</code></li>
<li><code>TODO</code></li>
<li><code>TODO</code></li></ol></li>
<li><p><strong>colimit</strong> is universal arrow from <script type="math/tex" id="MathJax-Element-307">F\in C^J</script> to diagnoal functor <script type="math/tex" id="MathJax-Element-308">\delta: C\to C^J</script> (means it maps into a master object, and the master object maps to other ones which mapped into by old objects) the arrows are <em>cone</em> (maps into the vertex)</p>

<ul><li><strong>diagonal functor</strong>, <strong>coproduct</strong>, <strong>injection</strong> <br>
<ul><li><strong>infinite coproduct</strong></li>
<li><strong>copower</strong> if <script type="math/tex" id="MathJax-Element-309">A</script> in coproduct is equal. <script type="math/tex" id="MathJax-Element-310">\coprod_x b</script> write as <script type="math/tex" id="MathJax-Element-311">X\cdot b</script> (consider in <script type="math/tex" id="MathJax-Element-312">\Set</script> it is <script type="math/tex" id="MathJax-Element-313">X\times Y</script>)</li></ul></li>
<li><strong>cokernel</strong> (normalily a quotient object) <br>
<ul><li><strong>coqualizer</strong></li></ul></li>
<li><strong>pushout</strong> <br>
<ul><li><strong>cokernel pair</strong> is the pushout of same arrow</li></ul></li></ul></li>
<li><p><code>CWM c03 p68 TODO</code></p></li>
<li><p><strong>limit</strong></p>

<ul><li><strong>product</strong>, <strong>projection</strong>, <strong>diagonal map</strong> <br>
<ul><li>for all map <script type="math/tex" id="MathJax-Element-314">f</script> have have <script type="math/tex" id="MathJax-Element-315">f\times f</script></li></ul></li></ul></li>
<li><p><code>CWM c03 p72 TODO</code></p></li>
<li><p><strong>category with finite product</strong></p></li>
<li><p><code>CWM c03 p74 TODO</code></p></li>
<li><p><strong>group object</strong></p></li>
<li><p><code>CWM c03 p76 TODO</code></p></li>
<li><p>any functor <script type="math/tex" id="MathJax-Element-316">K: D\to \Set</script> from a small category <script type="math/tex" id="MathJax-Element-317">D</script> is a colimit of representable functors <script type="math/tex" id="MathJax-Element-318">\hom(d, \_)</script></p></li>
</ul>



<h3 id="chapter-04-adjoints">chapter 04. adjoints</h3>

<ul>
<li><strong>adjoint</strong> <br>
<ul><li>ways to determine an adjoint</li></ul></li>
</ul></div></body>
</html>