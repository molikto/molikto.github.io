<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>cubicaltt</title>
<link href="/favicon.ico" rel="icon" type="image/x-icon" />
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/solarized-dark.css" />

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h1 id="notes-on-paper-cubicalttpdf">notes on paper <code>cubicaltt.pdf</code></h1>

<p><div class="toc">
<ul>
<li><a href="#notes-on-paper-cubicalttpdf">notes on paper cubicaltt.pdf</a><ul>
<li><a href="#lattice-theory">lattice theory</a></li>
<li><a href="#basic-type-theory">basic type theory</a></li>
<li><a href="#path-types">path types</a></li>
<li><a href="#face-lattice">face lattice</a></li>
<li><a href="#systems">systems</a></li>
<li><a href="#composition-operation">composition operation</a></li>
</ul>
</li>
</ul>
</div>
</p>

<ul>
<li>reference <br>
<ul><li><a href="http://www.math.ias.edu/~amortberg/papers/cubicaltt.pdf">http://www.math.ias.edu/~amortberg/papers/cubicaltt.pdf</a></li></ul></li>
</ul>



<p><script type="math/tex; mode=display" id="MathJax-Element-1">
\def\sup{\operatorname{sup}}
\def\inf{\operatorname{inf}}
\def\Con{\operatorname{Con}}
</script></p>



<h2 id="lattice-theory">lattice theory</h2>

<ul>
<li>partialy ordered set <br>
<ul><li>reflective <script type="math/tex" id="MathJax-Element-214">p \leq p</script></li>
<li>transitive <script type="math/tex" id="MathJax-Element-215">p \leq b\land b\leq c\Rightarrow p \leq c</script></li>
<li>antisymmetry <script type="math/tex" id="MathJax-Element-216">p \leq b\land b\leq p \Rightarrow p = b</script></li></ul></li>
<li>lattice: each two objects in the pos has join, <script type="math/tex" id="MathJax-Element-217">\sup</script>, <script type="math/tex" id="MathJax-Element-218">a\lor b</script> and meet, <script type="math/tex" id="MathJax-Element-219">\inf</script>, <script type="math/tex" id="MathJax-Element-220">a\land b</script></li>
<li>bounded lattice: have <script type="math/tex" id="MathJax-Element-221">0</script> and <script type="math/tex" id="MathJax-Element-222">1</script> and <script type="math/tex" id="MathJax-Element-223">0 \leq p \leq 1</script></li>
<li>distributive lattice: <script type="math/tex" id="MathJax-Element-224">p \land (q \lor r) = (p\lor q)\land (p \lor r)</script></li>
<li>complete lattice: all subset has join and meet, so it is a bounded lattice</li>
<li>de Morgan algebra <br>
<ul><li>bounded distributive lattice</li>
<li>with <script type="math/tex" id="MathJax-Element-225">1 -p</script> satisfying <br>
<ul><li><script type="math/tex" id="MathJax-Element-226">1-(p\land q) = (1-p)\lor(1-q)</script></li>
<li><script type="math/tex" id="MathJax-Element-227">1-(1-p) = p</script></li></ul></li></ul></li>
<li>congruence lattice of a algebra <script type="math/tex" id="MathJax-Element-228">\mathcal{A}</script> is the set of all congruence relations respect to the algebra. because there is a natural meet, and you can define the join by first take relations join, then the meet of all congruence relations containing the join, or say, the closure. it is complete and distributive lattice</li>
</ul>

<h2 id="basic-type-theory">basic type theory</h2>

<p><script type="math/tex; mode=display" id="MathJax-Element-30853">
\def\eqs{::=}
\def\s{\operatorname{s}}
\def\natrec{\operatorname{natrec}}
\def\I{\mathbb{I}\ }
\def\F{\mathbb{F}\ }
\newcommand{\P}[3]{\operatorname{Path}#1\ #2\ #3}
\newcommand{\pa}[2]{\left<#1\right >\ #2}
\def\comp{\operatorname{comp}}
\def\fill{\operatorname{fill}}
</script></p>

<p>firstly we define several fundamental concept</p>

<ul>
<li><p>context <script type="math/tex" id="MathJax-Element-30854">\Gamma</script>, <script type="math/tex" id="MathJax-Element-30855">\Delta</script>, variable <script type="math/tex" id="MathJax-Element-30856">x</script></p>

<ul><li>empty context <script type="math/tex" id="MathJax-Element-30857">()</script></li>
<li>context with a variable <script type="math/tex" id="MathJax-Element-30858">x</script> of type <script type="math/tex" id="MathJax-Element-30859">A</script>: <script type="math/tex" id="MathJax-Element-30860">\Gamma, x: A</script></li></ul></li>
<li><p>term <script type="math/tex" id="MathJax-Element-30861">t</script>, <script type="math/tex" id="MathJax-Element-30862">u</script>, type <script type="math/tex" id="MathJax-Element-30863">A</script>, <script type="math/tex" id="MathJax-Element-30864">B</script></p>

<ul><li>variable: <script type="math/tex" id="MathJax-Element-30865">x</script></li>
<li>pi type: <script type="math/tex" id="MathJax-Element-30866">(x: A) \to B</script></li>
<li>lambda: <script type="math/tex" id="MathJax-Element-30867">\lambda x : A. t</script></li>
<li>application: <script type="math/tex" id="MathJax-Element-30868">t\ u</script></li>
<li>sigma type: <script type="math/tex" id="MathJax-Element-30869">(x: A)\times B</script></li>
<li>pair: <script type="math/tex" id="MathJax-Element-30870">(t, u)</script></li>
<li>projection: <script type="math/tex" id="MathJax-Element-30871">t.1</script>, <script type="math/tex" id="MathJax-Element-30872">t.2</script></li>
<li>nat: <script type="math/tex" id="MathJax-Element-30873">N</script></li>
<li>zero, succ: <script type="math/tex" id="MathJax-Element-30874">0</script>, <script type="math/tex" id="MathJax-Element-30875">\s u</script></li>
<li>natrec: <script type="math/tex" id="MathJax-Element-30876">\natrec t\ u</script></li></ul></li>
<li><p>substitutions <script type="math/tex" id="MathJax-Element-30877">\sigma=(x/u, ...,x/u)</script></p></li>
<li><p>then we have 5 judgement and inference rules</p>

<ul><li>is a context: <script type="math/tex" id="MathJax-Element-30878">\Gamma\vdash</script></li>
<li>is a type <strong>under a context</strong>: <script type="math/tex" id="MathJax-Element-30879">\Gamma\vdash A</script></li>
<li>is a term of type <strong>under a context</strong>: <script type="math/tex" id="MathJax-Element-30880">\Gamma\vdash t: A</script></li>
<li>type eq <strong>under a context</strong>: <script type="math/tex" id="MathJax-Element-30881">\Gamma\vdash A = B</script></li>
<li>(<code>TODO</code> why there is a type eq? what about formulate them using universe?)</li>
<li>term eq <strong>under a context</strong>: <script type="math/tex" id="MathJax-Element-30882">\Gamma\vdash a = b: A</script> <br>
<ul><li>computation rule for <script type="math/tex" id="MathJax-Element-30883">(\lambda x: A. t) u = t(x/u)</script></li>
<li>computation rule for sigma</li>
<li>for nat</li></ul></li></ul></li>
<li><p>context morphisms <script type="math/tex" id="MathJax-Element-30884">\Delta\vdash \sigma: \Gamma</script></p>

<ul><li><script type="math/tex" id="MathJax-Element-30885">\Delta\vdash () : ()</script> the first <script type="math/tex" id="MathJax-Element-30886">()</script> is an empty substitution, the second is an empty context</li>
<li><script type="math/tex" id="MathJax-Element-30887">\Delta\vdash (\sigma, x/u): \Gamma, x: A</script> if <script type="math/tex" id="MathJax-Element-30888">\Delta\vdash \sigma: \Gamma</script> and <script type="math/tex" id="MathJax-Element-30889">\Gamma\vdash u: A\sigma</script>. this is adding a variable to a context, as before the context morphism contains more information than the context</li></ul></li>
<li>we use <script type="math/tex" id="MathJax-Element-30890">J</script> for a judgemnt and consider also hypothetical judgements <script type="math/tex" id="MathJax-Element-30891">\Gamma\vdash J</script> <br>
<ul><li>weakening: <script type="math/tex" id="MathJax-Element-30892">\Gamma\vdash J</script> then valid in all extensions of <script type="math/tex" id="MathJax-Element-30893">\Gamma</script></li>
<li>substitution: <script type="math/tex" id="MathJax-Element-30894">\Gamma\vdash J</script> and <script type="math/tex" id="MathJax-Element-30895">\Delta\vdash \sigma : \Gamma</script> then <script type="math/tex" id="MathJax-Element-30896">\Gamma\vdash J\sigma</script></li>
<li>from eq judgements we derive exists judgements and type judgements</li></ul></li>
</ul>

<h2 id="path-types">path types</h2>

<ul>
<li>names <script type="math/tex" id="MathJax-Element-15476">i</script>, <script type="math/tex" id="MathJax-Element-15477">j</script>, <script type="math/tex" id="MathJax-Element-15478">k</script> is a discete infinite set, and <script type="math/tex" id="MathJax-Element-15479">\I</script> the free de Morgan algebra on it, or</li>
<li>lattices nodes <script type="math/tex" id="MathJax-Element-15480">r</script>, <script type="math/tex" id="MathJax-Element-15481">s</script> <br>
<ul><li><script type="math/tex" id="MathJax-Element-15482">0</script>, <script type="math/tex" id="MathJax-Element-15483">1</script>, <script type="math/tex" id="MathJax-Element-15484">i</script>, <script type="math/tex" id="MathJax-Element-15485">1- r</script>, <script type="math/tex" id="MathJax-Element-15486">r\land s</script>, <script type="math/tex" id="MathJax-Element-15487">r\lor s</script></li></ul></li>
<li>we extends context <script type="math/tex" id="MathJax-Element-15488">\Gamma</script>, <script type="math/tex" id="MathJax-Element-15489">\Delta</script> with name declarations <br>
<ul><li><script type="math/tex" id="MathJax-Element-15490">\Gamma, i: \I</script></li>
<li>also a rule that for any context <script type="math/tex" id="MathJax-Element-15491">\Gamma\vdash</script>, and any <script type="math/tex" id="MathJax-Element-15492">i</script> not in the context, <script type="math/tex" id="MathJax-Element-15493">\Gamma, i: \I\vdash</script> <br>
<ul><li>we can understand a type <script type="math/tex" id="MathJax-Element-15494">A</script> in this context as a cube, square, becuase getting this context is easy, then we can use <script type="math/tex" id="MathJax-Element-15495">i</script> inside <script type="math/tex" id="MathJax-Element-15496">A</script> to obtain a type like a cube</li></ul></li>
<li><script type="math/tex" id="MathJax-Element-15497">\Gamma\vdash r: \I</script> means <script type="math/tex" id="MathJax-Element-15498">r</script> is a node depending only on names in <script type="math/tex" id="MathJax-Element-15499">\Gamma</script></li>
<li>judgement <script type="math/tex" id="MathJax-Element-15500">\Gamma\vdash r= s: \I</script></li></ul></li>
<li><p>we extends the terms with</p>

<ul><li>path type: <script type="math/tex" id="MathJax-Element-15501">\P{A}{t}{u}</script></li>
<li>path abstraction: <script type="math/tex" id="MathJax-Element-15502">\pa{i}{t}</script></li>
<li>path application: <script type="math/tex" id="MathJax-Element-15503"> t\ r</script></li></ul></li>
<li><p>extends substitution with <script type="math/tex" id="MathJax-Element-15504">(i/r)</script> forms and <script type="math/tex" id="MathJax-Element-15505">(i/0)</script> written as <script type="math/tex" id="MathJax-Element-15506">(i0)</script></p></li>
<li><p>extends inference rules with</p>

<ul><li><script type="math/tex" id="MathJax-Element-15507">\Gamma\vdash A</script>, <script type="math/tex" id="MathJax-Element-15508">\Gamma\vdash t, u: A</script> <script type="math/tex" id="MathJax-Element-15509">\Rightarrow</script> <script type="math/tex" id="MathJax-Element-15510">\Gamma\vdash\P{A}{t}{u}</script></li>
<li><script type="math/tex" id="MathJax-Element-15511">\Rightarrow</script> <script type="math/tex" id="MathJax-Element-15512">\Gamma\vdash \pa{i}{t}: \P{A}{t(i0)}{t(i1)}</script></li>
<li>a path in type <script type="math/tex" id="MathJax-Element-15513">A</script> when applied with a point in <script type="math/tex" id="MathJax-Element-15514">\I</script> will return again a value in type <script type="math/tex" id="MathJax-Element-15515">A</script>: <script type="math/tex" id="MathJax-Element-15516">\Rightarrow</script> <script type="math/tex" id="MathJax-Element-15517">t\ r : A</script></li>
<li><script type="math/tex" id="MathJax-Element-15518">\Rightarrow</script> <script type="math/tex" id="MathJax-Element-15519">\Gamma\vdash (\pa{i}{t})\ r = t(i/r):A</script></li>
<li>appling at a end will return the end in the path type: <script type="math/tex" id="MathJax-Element-15520">\Rightarrow</script> <script type="math/tex" id="MathJax-Element-15521">t\ 0 = u_0</script> where <script type="math/tex" id="MathJax-Element-15522">t: \P{A}{u_0}{u_1}</script></li>
<li><script type="math/tex" id="MathJax-Element-15523">1_a: \P{A}{a}{a} = \pa{i}{a}</script></li></ul></li>
<li><p>effects of node substitution</p>

<ul><li><script type="math/tex" id="MathJax-Element-15524">(i/j)</script> is renaming dimenstion</li>
<li><script type="math/tex" id="MathJax-Element-15525">(i/1-i)</script> is reversing</li>
<li>connections</li></ul></li>
<li>examples. all of them will request you have a non-trivial path first then get another path, but by far the only way to get a path is by identity <br>
<ul><li>image of equal elements is equal</li>
<li>funext. proof by type checking</li>
<li>singletons is contractible. the proof uses connections</li></ul></li>
</ul>

<h2 id="face-lattice">face lattice</h2>

<ul>
<li><p>face lattice <script type="math/tex" id="MathJax-Element-15526">\varphi, \psi\in\F</script> is free distributive bounded lattice on symbols <script type="math/tex" id="MathJax-Element-15527">(i = 1)</script> <script type="math/tex" id="MathJax-Element-15528">(i= 0)</script> with relation <script type="math/tex" id="MathJax-Element-15529">(i = 0)\land(i = 1) = 0_\F</script></p>

<ul><li>any element is a union (join) of irreducible element (meets of <script type="math/tex" id="MathJax-Element-15530">(i = 1, 0)</script>)</li>
<li>there is a canoical map <script type="math/tex" id="MathJax-Element-15531">\I\to\F</script> <br>
<ul><li>sending <script type="math/tex" id="MathJax-Element-15532">i</script> to <script type="math/tex" id="MathJax-Element-15533">(i = 1)</script></li>
<li>sending <script type="math/tex" id="MathJax-Element-15534">(1-i)</script> to <script type="math/tex" id="MathJax-Element-15535">(i= 0)</script></li>
<li>we write <script type="math/tex" id="MathJax-Element-15536">(r = 1)</script> for the image of <script type="math/tex" id="MathJax-Element-15537">r</script> in <script type="math/tex" id="MathJax-Element-15538">\F</script></li>
<li>we write <script type="math/tex" id="MathJax-Element-15539">(r = 0)</script> for the image of <script type="math/tex" id="MathJax-Element-15540">1-r</script></li>
<li>we have <script type="math/tex" id="MathJax-Element-15541">(r = 1)\land (r = 0) = 0_\F</script></li></ul></li>
<li>it can be seen as sub-polyhedra of a cube <br>
<ul><li>boundary <script type="math/tex" id="MathJax-Element-15542">\partial _I</script> is the greatest element <script type="math/tex" id="MathJax-Element-15543">< 1_\F</script></li></ul></li></ul></li>
<li><p>we extends the judgements: <script type="math/tex" id="MathJax-Element-15544">\Gamma\vdash \psi : \F</script> means <script type="math/tex" id="MathJax-Element-15545">\psi</script> is only using names in <script type="math/tex" id="MathJax-Element-15546">\Gamma</script></p></li>
<li><p>context restriction: <script type="math/tex" id="MathJax-Element-15547">\Gamma\vdash \psi : \F</script> <script type="math/tex" id="MathJax-Element-15548">\Rightarrow</script> <script type="math/tex" id="MathJax-Element-15549">\Gamma, \psi\vdash</script></p>

<ul><li>then we extends the type (<strong>?</strong>), by saying a type in a restricted context is a union of compatible faces of the <strong>original</strong> unrestricted cube</li></ul></li>
<li><p>canonical (lattice) map from <script type="math/tex" id="MathJax-Element-15550">\F</script> to <script type="math/tex" id="MathJax-Element-15551">\Con(\I)</script> (seems the order is <strong>reversed</strong>)</p>

<ul><li><script type="math/tex" id="MathJax-Element-15552">(i = 1)</script> to the congruence identifying <script type="math/tex" id="MathJax-Element-15553">i</script> with <script type="math/tex" id="MathJax-Element-15554">1</script></li>
<li><script type="math/tex" id="MathJax-Element-15555">(i = 0)</script> to the congruence identifying <script type="math/tex" id="MathJax-Element-15556">i</script> with <script type="math/tex" id="MathJax-Element-15557">0</script></li>
<li>then any <script type="math/tex" id="MathJax-Element-15558">\psi\in \F</script> defines a congruence <script type="math/tex" id="MathJax-Element-15559">r = s\mod{\psi}</script></li>
<li>if <script type="math/tex" id="MathJax-Element-15560">\psi</script> is irreducible like <script type="math/tex" id="MathJax-Element-15561">(i = 0)\land(j = 1)</script> then <script type="math/tex" id="MathJax-Element-15562">r = s\mod{\psi}</script> is equivalent to <script type="math/tex" id="MathJax-Element-15563">r(i0)(j1) = s(i0)(j1)</script></li>
<li>and the join is mapped to meet</li></ul></li>
<li>to any context <script type="math/tex" id="MathJax-Element-15564">\Gamma</script> we have a congruence of <script type="math/tex" id="MathJax-Element-15565">\I</script> defined on it. the empty context is identity on <script type="math/tex" id="MathJax-Element-15566">\I</script>, adding variable or name doesn’t change it, adding a restriction will change it</li>
<li>and any context defines a congruence on <script type="math/tex" id="MathJax-Element-15567">\F</script>  with <script type="math/tex" id="MathJax-Element-15568">\Gamma, \psi\vdash\varphi_1 = \varphi_2: \F</script> means <script type="math/tex" id="MathJax-Element-15569">\Gamma\vdash\psi\land\varphi_1= \psi\land\varphi_2: \F</script></li>
<li>we define <script type="math/tex" id="MathJax-Element-15570">\forall i .\varphi</script> as the join of all irreducible elements <script type="math/tex" id="MathJax-Element-15571">\leq \varphi</script> independent of <script type="math/tex" id="MathJax-Element-15572">i</script> <br>
<ul><li>if <script type="math/tex" id="MathJax-Element-15573">\psi</script> is independent of <script type="math/tex" id="MathJax-Element-15574">i</script>, then <script type="math/tex" id="MathJax-Element-15575">\psi \leq \varphi \iff \psi\leq \forall i.\varphi</script></li></ul></li>
</ul>

<h2 id="systems">systems</h2>

<ul>
<li>we extends syntex of term and type by  <br>
<ul><li><script type="math/tex" id="MathJax-Element-18431">S</script> system: <script type="math/tex" id="MathJax-Element-18432">[\varphi_1\ t_1, ..., \varphi_n\ t_n]</script> <br>
<ul><li>can be empty</li></ul></li></ul></li>
<li><p>and judgements, all of them bellow under the condition <script type="math/tex" id="MathJax-Element-18433">\Gamma \vdash \varphi_1\lor...\lor\varphi_n = 1_\F: \F</script>, which means <script type="math/tex" id="MathJax-Element-18434">\Gamma</script> is sufficiently restricted( to allow the system to be a complete thing that can exists under the non <script type="math/tex" id="MathJax-Element-18435">\varphi</script> restricted context <script type="math/tex" id="MathJax-Element-18436">\Gamma</script>)</p>

<ul><li>if under the contexts having types <script type="math/tex" id="MathJax-Element-18437">\Gamma, \varphi_n\vdash A_n</script> we have the types compatible <script type="math/tex" id="MathJax-Element-18438">\Gamma, \varphi_i\land\varphi_j\vdash A_i = A_j</script> then the system is a type <script type="math/tex" id="MathJax-Element-18439">\Gamma\vdash[\varphi_1 A_1,... , \varphi_n A_n]</script> (seems the equality is done by thinking of substitutions)</li>
<li>if we have a <strong>single</strong> type <script type="math/tex" id="MathJax-Element-18440">\Gamma\vdash A</script> and we have <script type="math/tex" id="MathJax-Element-18441">\Gamma, \varphi_n\vdash t_n: A</script> and we have <script type="math/tex" id="MathJax-Element-18442">\Gamma,\varphi_i\land \varphi_j\vdash t_i = t_j: A</script> then <script type="math/tex" id="MathJax-Element-18443">\Gamma\vdash [..., \varphi_i t_i,...]: A</script> <br>
<ul><li>consider the case <script type="math/tex" id="MathJax-Element-18444">n = 0</script> then <script type="math/tex" id="MathJax-Element-18445">\Gamma\vdash []: A</script></li></ul></li>
<li>if a judgement <script type="math/tex" id="MathJax-Element-18446">J</script> is valid in all <script type="math/tex" id="MathJax-Element-18447">\Gamma, \varphi_n</script> then it is valid in <script type="math/tex" id="MathJax-Element-18448">\Gamma</script></li>
<li><script type="math/tex" id="MathJax-Element-18449">\Gamma\vdash \varphi_i = 1_\F: \F</script> then <script type="math/tex" id="MathJax-Element-18450">\Gamma\vdash [...,\varphi_i A_i,...] = A_i</script></li>
<li><script type="math/tex" id="MathJax-Element-18451">\Gamma\vdash [..., \varphi_i t_i,...]: A</script> and <script type="math/tex" id="MathJax-Element-18452">\Gamma\vdash \varphi_i = 1_\F: \F</script> then  <script type="math/tex" id="MathJax-Element-18453">\Gamma\vdash [..., \varphi_i t_i,...]=t_i: A</script></li></ul></li>
<li><p>we extends the substituion judgement by <script type="math/tex" id="MathJax-Element-18454">\Delta\vdash \sigma: \Gamma, \varphi</script> if <script type="math/tex" id="MathJax-Element-18455">\Delta\vdash \sigma:\Gamma</script> and <script type="math/tex" id="MathJax-Element-18456">\Gamma\vdash \varphi :\F</script> and <script type="math/tex" id="MathJax-Element-18457">\Gamma\vdash\varphi\sigma=1_\F: \F</script></p></li>
<li><p>we write <script type="math/tex" id="MathJax-Element-18458">\Gamma\vdash a: A[\varphi_1\to u_1,...,\varphi_k\to u_k]</script> if <script type="math/tex" id="MathJax-Element-18459">\Gamma \vdash a: A</script> and <script type="math/tex" id="MathJax-Element-18460">\Gamma, \varphi_i\vdash a =u_i: A</script></p>

<ul><li>the great element <script type="math/tex" id="MathJax-Element-18461">a</script> is a witness of the parital elements <script type="math/tex" id="MathJax-Element-18462">u</script> is <strong>connected</strong></li></ul></li>
<li><p>the follows rules with <script type="math/tex" id="MathJax-Element-18463">J</script></p>

<ul><li><script type="math/tex" id="MathJax-Element-18464">\Gamma\vdash \varphi\leq \psi</script> then any judgemnt <script type="math/tex" id="MathJax-Element-18465">J</script> valid in bigger restriction is true in the smaller one</li>
<li>adding <script type="math/tex" id="MathJax-Element-18466">1_F</script> is trivial</li>
<li>merging <script type="math/tex" id="MathJax-Element-18467">\varphi</script> and <script type="math/tex" id="MathJax-Element-18468">\psi</script> into <script type="math/tex" id="MathJax-Element-18469">\varphi\land \psi</script> is trivial</li>
<li>if <script type="math/tex" id="MathJax-Element-18470">i</script> and <script type="math/tex" id="MathJax-Element-18471">\varphi</script> is <strong>independent</strong>, then exchange them in context is trivial <br>
<ul><li><script type="math/tex" id="MathJax-Element-18472">\Gamma, i: \I, \varphi\vdash J</script> then <script type="math/tex" id="MathJax-Element-18473">\Gamma, \forall i, \varphi, i: \I\vdash J</script></li></ul></li></ul></li>
</ul>

<h2 id="composition-operation">composition operation</h2>

<ul>
<li>we extends the syntax by <br>
<ul><li><script type="math/tex" id="MathJax-Element-30690">\comp^i A[\varphi\to u] a_0</script> where <script type="math/tex" id="MathJax-Element-30691">u</script> is a system</li></ul></li>
<li>the typing rule <br>
<ul><li>if firstly the context <script type="math/tex" id="MathJax-Element-30692">\Gamma</script> is itself a cube and can be restricted by <script type="math/tex" id="MathJax-Element-30693">\varphi</script>: <script type="math/tex" id="MathJax-Element-30694">\Gamma\vdash \varphi</script></li>
<li>and we have a type <script type="math/tex" id="MathJax-Element-30695">A</script> depending on an extra dimension: <script type="math/tex" id="MathJax-Element-30696">\Gamma, i: \I: A</script></li>
<li>and in theis restricted * new dimension settting we have an element of <script type="math/tex" id="MathJax-Element-30697">A</script>: <script type="math/tex" id="MathJax-Element-30698">\Gamma, \varphi, i: \I\vdash u: A</script></li>
<li>and we have in one end of the new dimension, the partial elemnt <script type="math/tex" id="MathJax-Element-30699">u</script> is connected: <br>
<script type="math/tex" id="MathJax-Element-30700">\Gamma\vdash a_0: A(i0)[\varphi\to  u(i0)]</script></li>
<li>then on the other end it is also connected: <br>
<script type="math/tex" id="MathJax-Element-30701">\Gamma\vdash \comp^i A[\varphi\to u]a_0: A(i1)[\varphi\to  u(i1)]</script>. where <script type="math/tex" id="MathJax-Element-30702">\comp^i</script> binds <script type="math/tex" id="MathJax-Element-30703">i</script> in <script type="math/tex" id="MathJax-Element-30704">A</script> and <script type="math/tex" id="MathJax-Element-30705">u</script> <br>
<ul><li>in particular if <script type="math/tex" id="MathJax-Element-30706">\varphi=1_\F</script>, the last result is written as <script type="math/tex" id="MathJax-Element-30707">\Gamma\vdash \comp^i A [1_\F\to u]a_0=u(i1)</script></li></ul></li></ul></li>
<li><p>if we have a substitution <script type="math/tex" id="MathJax-Element-30708">\Delta\vdash \sigma\Gamma</script> then the <script type="math/tex" id="MathJax-Element-30709">i</script> in <script type="math/tex" id="MathJax-Element-30710">A</script> <script type="math/tex" id="MathJax-Element-30711">u</script> is replaced by a fresh variable <script type="math/tex" id="MathJax-Element-30712">j</script>. corresponds to the <strong>uniformity</strong> (?) of composition</p></li>
<li><p>a troubling remark: use <script type="math/tex" id="MathJax-Element-30713">[\varphi_1\to u_1, ..., \varphi_n\to u_n]</script> for <script type="math/tex" id="MathJax-Element-30714">[\lor_i\varphi_i\to[\varphi_1 u_1, ..., \varphi_n u_n]]]</script>  also <script type="math/tex" id="MathJax-Element-30715">[]</script> for <script type="math/tex" id="MathJax-Element-30716">[0_\F\to []]</script></p></li>
<li>we can proof path transitivity by using comp</li>
</ul>

<h2 id="kan-filling">Kan filling</h2>

<ul>
<li><script type="math/tex" id="MathJax-Element-30978">\Gamma, i: \I\vdash \fill^i A[\varphi\to u]a_0= \comp^j A(i/i\land j)[\varphi\to u(i/i\land j), (i = 0)\to a_0]a_0: A</script></li>
</ul></div></body>
</html>