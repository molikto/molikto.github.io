---
title: Note on various topic on dependent type theory
tag:
- compiler backend
- memory layout
- universe
---

* [Memory layout and staging part 1: type-passing polymorphism, two-level type theory introduction](https://www.youtube.com/watch?v=OmNqXP9Hp_A&t=1725s)
  * only watched the first part
* ordered packages for programming languages
  * take a look at [Lean mathlib](https://github.com/leanprover-community/mathlib/tree/master/src), I wish these packages are ordered like a math book chapters, by dependency relations
  * it is misfit for using folders and files to represent packages
  * the files of a project should be acyclic, [lihaoyi/acyclic for Scala](https://github.com/lihaoyi/acyclic), we should be able to linearly order all files in a project automately
  * but I think it is not so ok to require folders to be acyclic, so we cannot automately reorder folders
  * but still, I think each package should have a z-index, and there should be a linter to suggest reorderings based on dependency
  * it is like my idea of language syntax based on rich text (nolex) instead of plain text, there are some similar design principle: the difference between editing stage and elaboration stage, and doing more stuff at editing stage enables more possibilities
* Why I am not using Lean but doing my own stuff?
  * I don't like universe variables, I wonder if lifting will work?
  * I have some my own ideas on how to have a more natual syntax for math (see above), but arguably one should try improve upon Lean instead do your own.
* trying out Lean4. I don't understand why `camelCase` is prefered
  * it is ugly to write `idComp` and `compId`, the symmetry of `IdComp`/`CompId` or `id_comp`/`comp_id` is lost
  * there are eligibility issues with `snake_case` all the time. but they can be mitigated:
    ![](2021-01-17_demo.svg)