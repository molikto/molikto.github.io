<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>old type theory notes</title>
        <link rel="stylesheet" type="text/css" href="../css/snailya.css" />
    </head>
    <body>
    <script src="../js/jquery.min.js"></script>

    <div class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">snailya</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../mathematics.html">mathematics</a></li>
            <li><a href="../random-notes.html">random notes</a></li>
            <li><a href="../posts.html">posts</a></li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li><a href="https://github.com/molikto">github</a></li>
            <li><a href="http://stackexchange.com/users/1154520/molikto?tab=accounts">stackexchange</a></li>
          </ul>
        </div>
      </div>
    </div>
  <div class="body small-container" id="content">
    



<script>
$("#content").css("max-width", "1100px")
</script>


<div class="row">
    <div class="bs-docs-container">
        <div class="col-md-3">
            <div class="bs-docs-sidebar hidden-print" role="complementary">
            </div>
        </div>
    </div>
    <div class="col-md-8">
        <h2 id="random">random</h2>
<p>set theory is static, it just presents the function as the result, and the <span class="math">\(Nat\)</span> as result. but in type theory, it is not the case</p>
<p>one interesting case is function extensionality, which is implied by univalence axiom, which i believe is good, the functions will be equal not just equal, but there is more in here. if we see the fact that it is implied by univalence, then we should inspect why univalence is true, and also, are all <span class="math">\(id\)</span> is freely generated? because we have three source to generate <span class="math">\(id\)</span>, in higher inductive type and in univalence, they are one for <span class="math">\(=_A\)</span> and one for <span class="math">\(=_\mathcal{U}\)</span>, so we are ok here.</p>
<p>one more issue, if we have a good system to do mathematics in computer, then we should have a pretty printer for as but much cleaver, because machines now understand what we are talking about and can give us much more help</p>
<p>remember in set theory, we also have things like universe, it is the class and set structure, but i think the universe idea is more elegant~</p>
<h3 id="syntax-for-inductive-type-and-higher-inductive-type">syntax for inductive type and higher inductive type</h3>
<ul>
<li>it is possible to think that parameterized inductive type actually brings nothing new, it is just a convenient notation?</li>
<li>the truth is in the inductor, because when you apply a match, you should always be careful how you use them, and this is protected by the inductor (?)</li>
<li>for general inductive type, the constructor do not depend on previous constructors, but for higher inductive type, this is inevitable.</li>
<li>so in ordinary mathematics, the notation of function is collapsed, but in hott, we have a better structure, but why? this seems very unreasonable</li>
<li>the thing is all about we can identify more things, we do this not by making things just equal, i.e. like in ETT and set theory, we forget things, but by equivalences, we identify things and as long as we are not caring what the id results in, i.e. in the type checker level, we just have more power, because we can identify more things equal</li>
<li>in type theory, the notation of equal is by <span class="math">\(X=Y: \forall x(x\in X \iff x\in Y)\)</span>, but in HoTT, all equal is freely generated, although the <span class="math">\(J\)</span> is wired</li>
<li>i still do not understand why type theory</li>
<li><p>the thing is always how are you going to define the inductor.</p></li>
<li><p><span class="math">\(J\)</span> hold but not <span class="math">\(UIP\)</span> <a href="http://homotopytypetheory.org/2011/04/10/just-kidding-understanding-identity-elimination-in-homotopy-type-theory">http://homotopytypetheory.org/2011/04/10/just-kidding-understanding-identity-elimination-in-homotopy-type-theory</a></p></li>
</ul>
<h3 id="problems">problems</h3>
<p>let me state the main problems</p>
<ul>
<li>you do not know how to define a higher inductive type, and now as axioms, it is only propositional equal
<ul>
<li>define the accepted form</li>
<li>define the elem and intro</li>
</ul></li>
<li>there are computation lacking in univalence
<ul>
<li>and inductor for hit</li>
</ul></li>
<li><p>finally i can get an feeling about 0-type, if you have two para path, then they must be joined by an surface, if you have two surface, then they must be joint by a 3-dim ball…. then you will have a very strong point, but it is nonetheless a point!!!</p></li>
<li><p>it seems to me that type theory has some mixed things together. i do not know if this is really good, they are like packaged delivery…</p></li>
<li><p>it is really some kind of miracle that it turns out two entirely different things turns out to be the same. h-types etc..</p></li>
<li><p>on the <strong>effectiveness</strong> of type theory and category theory in mathematics…</p></li>
</ul>
<h3 id="ias-notes">IAS notes</h3>
<ul>
<li>definitional eq is just compute to same value… by Martif</li>
</ul>
<h3 id="ref-cmu-course-notes"><a href="#cross-ref-cmu-course">ref-cmu-course</a> notes</h3>
<p>the course has different way telling HTT, it first use IPL, the <em>type theory without variables</em> and corresponding Hayting algebra, then go IPL with type, then ITT… i think this is wired</p>
<ul>
<li>notes of week 1-3 is not about type theory but ITT</li>
<li>week 4
<ul>
<li>judgments</li>
<li>…</li>
</ul></li>
<li><p>in ITT, <span class="math">\(refl\)</span> is the only intro rule!!!!… so it is so boring….</p></li>
<li><p>think <span class="math">\(Id\)</span> as inductively generated family indexed by <span class="math">\(x\)</span> and <span class="math">\(y\)</span></p></li>
<li>in ITT… he saids the <span class="math">\(Id-elem\)</span> is because we only have one <span class="math">\(Id-intro\)</span> so the whole big formula is just… shitty…
<ul>
<li>we will introduce new form of <span class="math">\(Id\)</span> but the shittly rule will continue to be valid… how?</li>
</ul></li>
<li><p>what i am thinking is that, the computation rule of identity is just that applying <span class="math">\(trans(p_1, p_2)\)</span> will not compute because the inductor <span class="math">\(J\)</span> only compute when <span class="math">\(J(a, a, refl_a)\)</span> so we can see that <span class="math">\(refl_x = relf_x^{-1}\)</span> by definition, or say, by computing the inductive, but we are not going to compute for different <span class="math">\(p_1 \neq p_2\)</span> it is just like <span class="math">\(succ(x)\)</span> will not compute, but can we get something out? like in <span class="math">\(\Pi\)</span>?</p></li>
<li><p>fibers</p></li>
<li><p>by computation, we means that all elements of a type has normal representation. so lem is not computation</p></li>
<li><p>what kind of madness will a guy abstract out something called <span class="math">\(J\)</span> to replace the old-good reflective and transitive? but it is just that all these rules like product etc. is meaningless, the meaning is given by us</p></li>
<li><p>so why it is called induction? you proof the <strong>base case</strong> then you have it for all? it is like no matter how many path you define, the only base case you have is <span class="math">\(refl\)</span>, but why?</p></li>
<li><p>so basically form this, you can deduce the functionality for various types, just use the <span class="math">\(refl\)</span>!… this is silly…</p></li>
<li><strong>lifting property</strong>
<ul>
<li>yes… equal <span class="math">\(x\)</span> gives equal type <span class="math">\(A[x]\)</span>, but what this equal means? for example, if we define a type <span class="math">\(A\)</span> indexed by an interval, then what does two <strong>inductive type</strong> equal means? though it means <span class="math">\(tr(p)\)</span>, but what is it?</li>
<li>he shows that the two type is equal, and also there is a bejection</li>
</ul></li>
<li><p>i think by lecture 08 and the exercises i finally have know what it means in identity type…</p></li>
<li><p>the proof of <span class="math">\(B[a]\)</span> is very related by <span class="math">\(B[a']\)</span>!!! this is what proof-relevant!!!</p></li>
<li><p>inaccessible cardinal, he says that <span class="math">\(\omega\)</span> is an inaccessible cardinal… what a brilliant idea!!!</p></li>
<li><p>h-level: things have large size tends to have large dimension</p></li>
<li><p><span class="math">\(\Pi-F\)</span> is just <span class="math">\(U-I-\Pi\)</span></p></li>
<li>universal polymorphism: i should implement it!!!
<ul>
<li>it is dam difficult to write down the code the universe has no solution…</li>
</ul></li>
<li>axiom of extensionality
<ul>
<li>under context <span class="math">\(x\)</span> <span class="math">\(y\)</span>, you can proof <span class="math">\(x +y = y + x\)</span> and you by transport <span class="math">\(\lambda x. \lambda    y.    x + y = \lambda x. \lambda y.y+x\)</span>, but they are not definitional equal, you can always normalize by applying the function, but how can you normalize a lambda? so we add that if <span class="math">\(Id_A(x, y)\)</span> then <span class="math">\(x\equiv y\)</span></li>
<li>so when you want to know if <span class="math">\(x \equiv y\)</span>, then you have terrible things happening… haha!!! so it is a totally bad idea!!!</li>
<li>actually, with out the extensionality, there is no contradiction in my option…</li>
</ul></li>
<li><p>in mathematics, function is one-side-injection relations, they do not tell at all how the elements is get. but in hott, it is different, set theory use extensionality, but in tt, it is not the case</p></li>
<li><p>if we have extensionality, then because <span class="math">\(x +y\equiv y +x\)</span> then <span class="math">\(\lambda x. \lambda y .x + y \equiv \lambda x. \lambda y. y + x\)</span> then we have the <span class="math">\(refl\)</span></p></li>
<li>he has some remarks about ITT and ETT
<ol style="list-style-type: decimal">
<li>something happened in HoTT is bad</li>
<li>ITT type checking is intractable… why?</li>
</ol></li>
<li><p>so my version is not ETT… it is incomplete ITT…</p></li>
<li><p>so in the past, they use ITT just for the decidable type checking, without even thinking they can add more path…</p></li>
<li><p>why not category - groupoid - set, we can pick anyone… actually??</p></li>
<li><p>in ETT, we have <strong>strict sets</strong> they are just eq, but in ITT we proof that the <span class="math">\(Id\)</span> is equal, but not judgementally, which cannot be done</p></li>
<li><p>in the path thing, we can talk about how a proof can be conveyed to a proof in other place!!</p></li>
<li><p>i think because we have new identity, we have trouble with <span class="math">\(J\)</span></p></li>
<li><p>in ITT, everything is cool, but he do not want to go into meta-theory</p></li>
<li><p>for Harper, if it has no computational meaning, it is basically useless</p></li>
<li><p>yes… the inductive rule of identity, it worried me greatly…</p></li>
<li><p>it is the lie holds only by bigger lies…</p></li>
<li><p>so in hott, functors is more basic than functions!</p></li>
<li><p>homotopy is assembly… and hott is advanced pl…</p></li>
<li><p>compile and encoding nat in sets</p></li>
<li>so it is not safe to say <span class="math">\(=_\mathcal{U}\)</span>, but we say… and make them higher!
<ul>
<li>in ITT they are different, in equivalence, we use homtopoy, not function of types</li>
</ul></li>
<li><p>function extensionality: in the ITT setting, we just do not know, in HoTT, we said there are one path, but we cannot define now. and in ETT, we said they are just equal</p></li>
<li><p>negative of type has easy path structure, but positive type has not….</p></li>
<li><p>i think i begin to have a metal model on what’s going on in this kind of things…</p></li>
<li><p>yes… small type matters in theory</p></li>
<li><p>what is universe? if we can identify universe as a small thing, we might make true progress</p></li>
<li><p>i still cannot understand the book i think</p></li>
</ul>
    </div>
</div>
 
</div>
<script src="../js/jquery.toc.js"></script>
<script src="../js/toc.js"></script>




<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



<!--<script src="/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->

<script>
  MathJax.Hub.Queue(function() {
    $(document.body).scrollspy('refresh')
  })
</script>


  </div>

    <div class="footer">
      <div class="container">
        <span></span>
      </div>
    </div>

      <script src="../js/bootstrap.min.js"></script>
      <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-50798592-1', 'snailya.org');
  ga('send', 'pageview');

</script>
    </body>
</html>
